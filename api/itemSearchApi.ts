/**
 * Pipedrive API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { SearchItemByFieldResponse200 } from '../model/searchItemByFieldResponse200';
import { SearchItemResponse200 } from '../model/searchItemResponse200';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.pipedrive.com/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ItemSearchApiApiKeys {
    api_key,
}

export class ItemSearchApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('query', 'api_token'),
        'oauth2': new OAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ItemSearchApiApiKeys, value: string) {
        (this.authentications as any)[ItemSearchApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Performs a search from your choice of item types and fields.
     * @summary Perform a search from multiple item types
     * @param term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param itemTypes A comma-separated string array. The type of items to perform the search from. Defaults to all.
     * @param fields A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
     * @param searchForRelatedItems When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
     * @param exactMatch When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param includeFields A comma-separated string array. Supports including optional fields in the results which are not provided by default.
     * @param start Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param limit Items shown per page
     */
    public async searchItem (term: string, itemTypes?: 'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment', fields?: 'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title', searchForRelatedItems?: boolean, exactMatch?: boolean, includeFields?: 'deal.cc_email' | 'person.picture' | 'product.price', start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchItemResponse200;  }> {
        const localVarPath = this.basePath + '/itemSearch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'term' is not null or undefined
        if (term === null || term === undefined) {
            throw new Error('Required parameter term was null or undefined when calling searchItem.');
        }

        if (term !== undefined) {
            localVarQueryParameters['term'] = ObjectSerializer.serialize(term, "string");
        }

        if (itemTypes !== undefined) {
            localVarQueryParameters['item_types'] = ObjectSerializer.serialize(itemTypes, "'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment'");
        }

        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title'");
        }

        if (searchForRelatedItems !== undefined) {
            localVarQueryParameters['search_for_related_items'] = ObjectSerializer.serialize(searchForRelatedItems, "boolean");
        }

        if (exactMatch !== undefined) {
            localVarQueryParameters['exact_match'] = ObjectSerializer.serialize(exactMatch, "boolean");
        }

        if (includeFields !== undefined) {
            localVarQueryParameters['include_fields'] = ObjectSerializer.serialize(includeFields, "'deal.cc_email' | 'person.picture' | 'product.price'");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.oauth2.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchItemResponse200;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchItemResponse200");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     * @summary Perform a search using a specific field from an item type
     * @param term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param fieldType The type of the field to perform the search from
     * @param fieldKey The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.).
     * @param exactMatch When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
     * @param returnItemIds Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
     * @param start Pagination start
     * @param limit Items shown per page
     */
    public async searchItemByField (term: string, fieldType: 'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField', fieldKey: string, exactMatch?: boolean, returnItemIds?: boolean, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchItemByFieldResponse200;  }> {
        const localVarPath = this.basePath + '/itemSearch/field';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['applicatoin/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'term' is not null or undefined
        if (term === null || term === undefined) {
            throw new Error('Required parameter term was null or undefined when calling searchItemByField.');
        }

        // verify required parameter 'fieldType' is not null or undefined
        if (fieldType === null || fieldType === undefined) {
            throw new Error('Required parameter fieldType was null or undefined when calling searchItemByField.');
        }

        // verify required parameter 'fieldKey' is not null or undefined
        if (fieldKey === null || fieldKey === undefined) {
            throw new Error('Required parameter fieldKey was null or undefined when calling searchItemByField.');
        }

        if (term !== undefined) {
            localVarQueryParameters['term'] = ObjectSerializer.serialize(term, "string");
        }

        if (fieldType !== undefined) {
            localVarQueryParameters['field_type'] = ObjectSerializer.serialize(fieldType, "'dealField' | 'leadField' | 'personField' | 'organizationField' | 'productField'");
        }

        if (exactMatch !== undefined) {
            localVarQueryParameters['exact_match'] = ObjectSerializer.serialize(exactMatch, "boolean");
        }

        if (fieldKey !== undefined) {
            localVarQueryParameters['field_key'] = ObjectSerializer.serialize(fieldKey, "string");
        }

        if (returnItemIds !== undefined) {
            localVarQueryParameters['return_item_ids'] = ObjectSerializer.serialize(returnItemIds, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.api_key.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.oauth2.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchItemByFieldResponse200;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchItemByFieldResponse200");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
