/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddGoalRequest,
  AddOrUpdateGoalResponse200,
  BasicGoalRequest,
  DeleteGoalResponse200,
  GetGoalResultResponse200,
  GetGoalsResponse200,
} from '../models';
import {
    AddGoalRequestFromJSON,
    AddGoalRequestToJSON,
    AddOrUpdateGoalResponse200FromJSON,
    AddOrUpdateGoalResponse200ToJSON,
    BasicGoalRequestFromJSON,
    BasicGoalRequestToJSON,
    DeleteGoalResponse200FromJSON,
    DeleteGoalResponse200ToJSON,
    GetGoalResultResponse200FromJSON,
    GetGoalResultResponse200ToJSON,
    GetGoalsResponse200FromJSON,
    GetGoalsResponse200ToJSON,
} from '../models';

export interface AddGoalOperationRequest {
    addGoalRequest?: AddGoalRequest;
}

export interface DeleteGoalRequest {
    id: string;
}

export interface GetGoalResultRequest {
    id: string;
    periodStart: Date;
    periodEnd: Date;
}

export interface GetGoalsRequest {
    typeName?: GetGoalsTypeNameEnum;
    title?: string;
    isActive?: GetGoalsIsActiveEnum;
    assigneeId?: number;
    assigneeType?: GetGoalsAssigneeTypeEnum;
    expectedOutcomeTarget?: number;
    expectedOutcomeTrackingMetric?: GetGoalsExpectedOutcomeTrackingMetricEnum;
    expectedOutcomeCurrencyId?: number;
    typeParamsPipelineId?: number;
    typeParamsStageId?: number;
    typeParamsActivityTypeId?: number;
    periodStart?: Date;
    periodEnd?: Date;
}

export interface UpdateGoalRequest {
    id: string;
    basicGoalRequest?: BasicGoalRequest;
}

/**
 * GoalsApi - interface
 * 
 * @export
 * @interface GoalsApiInterface
 */
export interface GoalsApiInterface {
    /**
     * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     * @summary Add a new goal
     * @param {AddGoalRequest} [addGoalRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    addGoalRaw(requestParameters: AddGoalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddOrUpdateGoalResponse200>>;

    /**
     * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     * Add a new goal
     */
    addGoal(requestParameters: AddGoalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddOrUpdateGoalResponse200>;

    /**
     * Marks a goal as deleted.
     * @summary Delete existing goal
     * @param {string} id The ID of the goal to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    deleteGoalRaw(requestParameters: DeleteGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteGoalResponse200>>;

    /**
     * Marks a goal as deleted.
     * Delete existing goal
     */
    deleteGoal(requestParameters: DeleteGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteGoalResponse200>;

    /**
     * Gets the progress of a goal for the specified period.
     * @summary Get result of a goal
     * @param {string} id The ID of the goal that the results are looked for
     * @param {Date} periodStart The start date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or after the goal duration start date.
     * @param {Date} periodEnd The end date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or before the goal duration end date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    getGoalResultRaw(requestParameters: GetGoalResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGoalResultResponse200>>;

    /**
     * Gets the progress of a goal for the specified period.
     * Get result of a goal
     */
    getGoalResult(requestParameters: GetGoalResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGoalResultResponse200>;

    /**
     * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     * @summary Find goals
     * @param {'deals_won' | 'deals_progressed' | 'activities_completed' | 'activities_added' | 'deals_started'} [typeName] The type of the goal. If provided, everyone\&#39;s goals will be returned.
     * @param {string} [title] The title of the goal
     * @param {boolean} [isActive] Whether the goal is active or not
     * @param {number} [assigneeId] The ID of the user who\&#39;s goal to fetch. When omitted, only your goals will be returned.
     * @param {'person' | 'company' | 'team'} [assigneeType] The type of the goal\&#39;s assignee. If provided, everyone\&#39;s goals will be returned.
     * @param {number} [expectedOutcomeTarget] The numeric value of the outcome. If provided, everyone\&#39;s goals will be returned.
     * @param {'quantity' | 'sum'} [expectedOutcomeTrackingMetric] The tracking metric of the expected outcome of the goal. If provided, everyone\&#39;s goals will be returned.
     * @param {number} [expectedOutcomeCurrencyId] The numeric ID of the goal\&#39;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone\&#39;s goals will be returned.
     * @param {number} [typeParamsPipelineId] The ID of the pipeline or &#x60;null&#x60; for all pipelines. If provided, everyone\&#39;s goals will be returned.
     * @param {number} [typeParamsStageId] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone\&#39;s goals will be returned.
     * @param {number} [typeParamsActivityTypeId] The ID of the activity type. Applicable to only &#x60;activities_completed&#x60; or &#x60;activities_added&#x60; types of goals. If provided, everyone\&#39;s goals will be returned.
     * @param {Date} [periodStart] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
     * @param {Date} [periodEnd] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    getGoalsRaw(requestParameters: GetGoalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGoalsResponse200>>;

    /**
     * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     * Find goals
     */
    getGoals(requestParameters: GetGoalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGoalsResponse200>;

    /**
     * Updates an existing goal.
     * @summary Update existing goal
     * @param {string} id The ID of the goal to be updated
     * @param {BasicGoalRequest} [basicGoalRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    updateGoalRaw(requestParameters: UpdateGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddOrUpdateGoalResponse200>>;

    /**
     * Updates an existing goal.
     * Update existing goal
     */
    updateGoal(requestParameters: UpdateGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddOrUpdateGoalResponse200>;

}

/**
 * 
 */
export class GoalsApi extends runtime.BaseAPI implements GoalsApiInterface {

    /**
     * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     * Add a new goal
     */
    async addGoalRaw(requestParameters: AddGoalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddOrUpdateGoalResponse200>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_token"] = this.configuration.apiKey("api_token"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["goals:full"]);
        }

        const response = await this.request({
            path: `/goals`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddGoalRequestToJSON(requestParameters.addGoalRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddOrUpdateGoalResponse200FromJSON(jsonValue));
    }

    /**
     * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     * Add a new goal
     */
    async addGoal(requestParameters: AddGoalOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddOrUpdateGoalResponse200> {
        const response = await this.addGoalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Marks a goal as deleted.
     * Delete existing goal
     */
    async deleteGoalRaw(requestParameters: DeleteGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteGoalResponse200>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteGoal.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_token"] = this.configuration.apiKey("api_token"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["goals:full"]);
        }

        const response = await this.request({
            path: `/goals/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteGoalResponse200FromJSON(jsonValue));
    }

    /**
     * Marks a goal as deleted.
     * Delete existing goal
     */
    async deleteGoal(requestParameters: DeleteGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteGoalResponse200> {
        const response = await this.deleteGoalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the progress of a goal for the specified period.
     * Get result of a goal
     */
    async getGoalResultRaw(requestParameters: GetGoalResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGoalResultResponse200>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getGoalResult.');
        }

        if (requestParameters.periodStart === null || requestParameters.periodStart === undefined) {
            throw new runtime.RequiredError('periodStart','Required parameter requestParameters.periodStart was null or undefined when calling getGoalResult.');
        }

        if (requestParameters.periodEnd === null || requestParameters.periodEnd === undefined) {
            throw new runtime.RequiredError('periodEnd','Required parameter requestParameters.periodEnd was null or undefined when calling getGoalResult.');
        }

        const queryParameters: any = {};

        if (requestParameters.periodStart !== undefined) {
            queryParameters['period.start'] = (requestParameters.periodStart as any).toISOString().substr(0,10);
        }

        if (requestParameters.periodEnd !== undefined) {
            queryParameters['period.end'] = (requestParameters.periodEnd as any).toISOString().substr(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_token"] = this.configuration.apiKey("api_token"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["goals:read", "goals:full"]);
        }

        const response = await this.request({
            path: `/goals/{id}/results`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetGoalResultResponse200FromJSON(jsonValue));
    }

    /**
     * Gets the progress of a goal for the specified period.
     * Get result of a goal
     */
    async getGoalResult(requestParameters: GetGoalResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGoalResultResponse200> {
        const response = await this.getGoalResultRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     * Find goals
     */
    async getGoalsRaw(requestParameters: GetGoalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGoalsResponse200>> {
        const queryParameters: any = {};

        if (requestParameters.typeName !== undefined) {
            queryParameters['type.name'] = requestParameters.typeName;
        }

        if (requestParameters.title !== undefined) {
            queryParameters['title'] = requestParameters.title;
        }

        if (requestParameters.isActive !== undefined) {
            queryParameters['is_active'] = requestParameters.isActive;
        }

        if (requestParameters.assigneeId !== undefined) {
            queryParameters['assignee.id'] = requestParameters.assigneeId;
        }

        if (requestParameters.assigneeType !== undefined) {
            queryParameters['assignee.type'] = requestParameters.assigneeType;
        }

        if (requestParameters.expectedOutcomeTarget !== undefined) {
            queryParameters['expected_outcome.target'] = requestParameters.expectedOutcomeTarget;
        }

        if (requestParameters.expectedOutcomeTrackingMetric !== undefined) {
            queryParameters['expected_outcome.tracking_metric'] = requestParameters.expectedOutcomeTrackingMetric;
        }

        if (requestParameters.expectedOutcomeCurrencyId !== undefined) {
            queryParameters['expected_outcome.currency_id'] = requestParameters.expectedOutcomeCurrencyId;
        }

        if (requestParameters.typeParamsPipelineId !== undefined) {
            queryParameters['type.params.pipeline_id'] = requestParameters.typeParamsPipelineId;
        }

        if (requestParameters.typeParamsStageId !== undefined) {
            queryParameters['type.params.stage_id'] = requestParameters.typeParamsStageId;
        }

        if (requestParameters.typeParamsActivityTypeId !== undefined) {
            queryParameters['type.params.activity_type_id'] = requestParameters.typeParamsActivityTypeId;
        }

        if (requestParameters.periodStart !== undefined) {
            queryParameters['period.start'] = (requestParameters.periodStart as any).toISOString().substr(0,10);
        }

        if (requestParameters.periodEnd !== undefined) {
            queryParameters['period.end'] = (requestParameters.periodEnd as any).toISOString().substr(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_token"] = this.configuration.apiKey("api_token"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["goals:read", "goals:full"]);
        }

        const response = await this.request({
            path: `/goals/find`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetGoalsResponse200FromJSON(jsonValue));
    }

    /**
     * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     * Find goals
     */
    async getGoals(requestParameters: GetGoalsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGoalsResponse200> {
        const response = await this.getGoalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing goal.
     * Update existing goal
     */
    async updateGoalRaw(requestParameters: UpdateGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddOrUpdateGoalResponse200>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateGoal.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["api_token"] = this.configuration.apiKey("api_token"); // api_key authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["goals:full"]);
        }

        const response = await this.request({
            path: `/goals/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BasicGoalRequestToJSON(requestParameters.basicGoalRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddOrUpdateGoalResponse200FromJSON(jsonValue));
    }

    /**
     * Updates an existing goal.
     * Update existing goal
     */
    async updateGoal(requestParameters: UpdateGoalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddOrUpdateGoalResponse200> {
        const response = await this.updateGoalRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum GetGoalsTypeNameEnum {
    DealsWon = 'deals_won',
    DealsProgressed = 'deals_progressed',
    ActivitiesCompleted = 'activities_completed',
    ActivitiesAdded = 'activities_added',
    DealsStarted = 'deals_started'
}
/**
  * @export
  * @enum {string}
  */
export enum GetGoalsIsActiveEnum {
    True = true,
    False = false
}
/**
  * @export
  * @enum {string}
  */
export enum GetGoalsAssigneeTypeEnum {
    Person = 'person',
    Company = 'company',
    Team = 'team'
}
/**
  * @export
  * @enum {string}
  */
export enum GetGoalsExpectedOutcomeTrackingMetricEnum {
    Quantity = 'quantity',
    Sum = 'sum'
}
