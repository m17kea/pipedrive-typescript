/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Pipedrive API v1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.pipedrive.com/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddActivityRequest
 */
export interface AddActivityRequest {
    /**
     * The subject of the activity. When value for subject is not set, it will be given a default value `Call`.
     * @type {string}
     * @memberof AddActivityRequest
     */
    subject?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes. When value for type is not set, it will be given a default value `Call`.
     * @type {string}
     * @memberof AddActivityRequest
     */
    type?: string;
    /**
     * The ID of the user whom the activity is assigned to. If omitted, the activity is assigned to the authorized user.
     * @type {number}
     * @memberof AddActivityRequest
     */
    user_id?: number;
    /**
     * List of multiple persons (participants) this activity is associated with. If omitted, single participant from `person_id` field is used. It requires a structure as follows: `[{\"person_id\":1,\"primary_flag\":true}]`
     * @type {Array<any>}
     * @memberof AddActivityRequest
     */
    participants?: Array<any>;
    /**
     * Set the activity as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset by never setting it or overriding it with `null`. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof AddActivityRequest
     */
    busy_flag?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address. It requires a structure as follows: `[{\"email_address\":\"mail@example.org\"}]` or `[{\"person_id\":1, \"email_address\":\"mail@example.org\"}]`
     * @type {Array<any>}
     * @memberof AddActivityRequest
     */
    attendees?: Array<any>;
    /**
     * Whether the activity is done or not. 0 = Not done, 1 = Done
     * @type {number}
     * @memberof AddActivityRequest
     */
    done?: number;
}
/**
 * 
 * @export
 * @interface AddActivityResponse200
 */
export interface AddActivityResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof AddActivityResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof AddActivityResponse200
     */
    data?: any;
    /**
     * 
     * @type {AddActivityResponse200AdditionalData}
     * @memberof AddActivityResponse200
     */
    additional_data?: AddActivityResponse200AdditionalData;
    /**
     * 
     * @type {UpdateActivityResponse200RelatedObjects}
     * @memberof AddActivityResponse200
     */
    related_objects?: UpdateActivityResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface AddActivityResponse200AdditionalData
 */
export interface AddActivityResponse200AdditionalData {
    /**
     * This field will be deprecated
     * @type {number}
     * @memberof AddActivityResponse200AdditionalData
     */
    updates_story_id?: number;
}
/**
 * 
 * @export
 * @interface AddActivityTypeRequest
 */
export interface AddActivityTypeRequest {
    /**
     * The name of the activity type
     * @type {string}
     * @memberof AddActivityTypeRequest
     */
    name: string;
    /**
     * Icon graphic to use for representing this activity type
     * @type {string}
     * @memberof AddActivityTypeRequest
     */
    icon_key: AddActivityTypeRequest.IconKeyEnum;
    /**
     * A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
     * @type {string}
     * @memberof AddActivityTypeRequest
     */
    color?: string;
}

/**
 * @export
 * @namespace AddActivityTypeRequest
 */
export namespace AddActivityTypeRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum IconKeyEnum {
        Task = <any> 'task',
        Email = <any> 'email',
        Meeting = <any> 'meeting',
        Deadline = <any> 'deadline',
        Call = <any> 'call',
        Lunch = <any> 'lunch',
        Calendar = <any> 'calendar',
        Downarrow = <any> 'downarrow',
        Document = <any> 'document',
        Smartphone = <any> 'smartphone',
        Camera = <any> 'camera',
        Scissors = <any> 'scissors',
        Cogs = <any> 'cogs',
        Bubble = <any> 'bubble',
        Uparrow = <any> 'uparrow',
        Checkbox = <any> 'checkbox',
        Signpost = <any> 'signpost',
        Shuffle = <any> 'shuffle',
        Addressbook = <any> 'addressbook',
        Linegraph = <any> 'linegraph',
        Picture = <any> 'picture',
        Car = <any> 'car',
        World = <any> 'world',
        Search = <any> 'search',
        Clip = <any> 'clip',
        Sound = <any> 'sound',
        Brush = <any> 'brush',
        Key = <any> 'key',
        Padlock = <any> 'padlock',
        Pricetag = <any> 'pricetag',
        Suitcase = <any> 'suitcase',
        Finish = <any> 'finish',
        Plane = <any> 'plane',
        Loop = <any> 'loop',
        Wifi = <any> 'wifi',
        Truck = <any> 'truck',
        Cart = <any> 'cart',
        Bulb = <any> 'bulb',
        Bell = <any> 'bell',
        Presentation = <any> 'presentation'
    }
}
/**
 * 
 * @export
 * @interface AddCallLogAudioFileRequest
 */
export interface AddCallLogAudioFileRequest {
    /**
     * Audio file supported by the HTML5 specification
     * @type {Blob}
     * @memberof AddCallLogAudioFileRequest
     */
    file: Blob;
}
/**
 * 
 * @export
 * @interface AddCallLogAudioFileResponse200
 */
export interface AddCallLogAudioFileResponse200 {
}
/**
 * 
 * @export
 * @interface AddCallLogRequest
 */
export interface AddCallLogRequest {
    /**
     * The ID of the owner of the call log. Please note that a user without account settings access cannot create call logs for other users.
     * @type {number}
     * @memberof AddCallLogRequest
     */
    user_id?: number;
    /**
     * If specified, this activity will be converted into a call log, with the information provided. When this field is used, you don't need to specify `deal_id`, `person_id` or `org_id`, as they will be ignored in favor of the values already available in the activity.
     * @type {number}
     * @memberof AddCallLogRequest
     */
    activity_id?: number;
    /**
     * The name of the activity this call is attached to
     * @type {string}
     * @memberof AddCallLogRequest
     */
    subject?: string;
    /**
     * The duration of the call in seconds
     * @type {string}
     * @memberof AddCallLogRequest
     */
    duration?: string;
    /**
     * Describes the outcome of the call
     * @type {string}
     * @memberof AddCallLogRequest
     */
    outcome: AddCallLogRequest.OutcomeEnum;
    /**
     * The number that made the call
     * @type {string}
     * @memberof AddCallLogRequest
     */
    from_phone_number?: string;
    /**
     * The number called
     * @type {string}
     * @memberof AddCallLogRequest
     */
    to_phone_number: string;
    /**
     * The date and time of the start of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {Date}
     * @memberof AddCallLogRequest
     */
    start_time: Date;
    /**
     * The date and time of the end of the call in UTC. Format: YYYY-MM-DD HH:MM:SS.
     * @type {Date}
     * @memberof AddCallLogRequest
     */
    end_time: Date;
    /**
     * The ID of the person this call is associated with
     * @type {number}
     * @memberof AddCallLogRequest
     */
    person_id?: number;
    /**
     * The ID of the organization this call is associated with
     * @type {number}
     * @memberof AddCallLogRequest
     */
    org_id?: number;
    /**
     * The ID of the deal this call is associated with
     * @type {number}
     * @memberof AddCallLogRequest
     */
    deal_id?: number;
    /**
     * The note for the call log in HTML format
     * @type {string}
     * @memberof AddCallLogRequest
     */
    note?: string;
}

/**
 * @export
 * @namespace AddCallLogRequest
 */
export namespace AddCallLogRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum OutcomeEnum {
        Connected = <any> 'connected',
        NoAnswer = <any> 'no_answer',
        LeftMessage = <any> 'left_message',
        LeftVoicemail = <any> 'left_voicemail',
        WrongNumber = <any> 'wrong_number',
        Busy = <any> 'busy'
    }
}
/**
 * 
 * @export
 * @interface AddCallLogResponse200
 */
export interface AddCallLogResponse200 {
    /**
     * 
     * @type {any}
     * @memberof AddCallLogResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface AddDealFollowerRequest
 */
export interface AddDealFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddDealFollowerRequest
     */
    user_id: number;
}
/**
 * 
 * @export
 * @interface AddDealFollowerResponse200
 */
export interface AddDealFollowerResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof AddDealFollowerResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {AddDealFollowerResponse200Data}
     * @memberof AddDealFollowerResponse200
     */
    data?: AddDealFollowerResponse200Data;
}
/**
 * 
 * @export
 * @interface AddDealFollowerResponse200Data
 */
export interface AddDealFollowerResponse200Data {
    /**
     * The user ID who added the follower
     * @type {number}
     * @memberof AddDealFollowerResponse200Data
     */
    user_id?: number;
    /**
     * The follower ID
     * @type {number}
     * @memberof AddDealFollowerResponse200Data
     */
    id?: number;
    /**
     * The ID of the deal which the follower was added to
     * @type {number}
     * @memberof AddDealFollowerResponse200Data
     */
    deal_id?: number;
    /**
     * The date and time when the deal follower was added
     * @type {string}
     * @memberof AddDealFollowerResponse200Data
     */
    add_time?: string;
}
/**
 * 
 * @export
 * @interface AddDealParticipantRequest
 */
export interface AddDealParticipantRequest {
    /**
     * The ID of the person
     * @type {number}
     * @memberof AddDealParticipantRequest
     */
    person_id: number;
}
/**
 * 
 * @export
 * @interface AddDealParticipantResponse200
 */
export interface AddDealParticipantResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200
     */
    success?: boolean;
    /**
     * The object of participant
     * @type {any}
     * @memberof AddDealParticipantResponse200
     */
    data?: any;
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjects}
     * @memberof AddDealParticipantResponse200
     */
    related_objects?: AddDealParticipantResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface AddDealParticipantResponse200RelatedObjects
 */
export interface AddDealParticipantResponse200RelatedObjects {
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjectsUser}
     * @memberof AddDealParticipantResponse200RelatedObjects
     */
    user?: AddDealParticipantResponse200RelatedObjectsUser;
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjectsOrganization}
     * @memberof AddDealParticipantResponse200RelatedObjects
     */
    organization?: AddDealParticipantResponse200RelatedObjectsOrganization;
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjectsPerson}
     * @memberof AddDealParticipantResponse200RelatedObjects
     */
    person?: AddDealParticipantResponse200RelatedObjectsPerson;
}
/**
 * The organization which is associated with the deal
 * @export
 * @interface AddDealParticipantResponse200RelatedObjectsOrganization
 */
export interface AddDealParticipantResponse200RelatedObjectsOrganization {
    /**
     * The name of the organization associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsOrganization
     */
    name?: string;
    /**
     * The number of people connected with the organization that is associated with the deal
     * @type {number}
     * @memberof AddDealParticipantResponse200RelatedObjectsOrganization
     */
    people_count?: number;
    /**
     * The ID of the owner of the organization that is associated with the deal
     * @type {number}
     * @memberof AddDealParticipantResponse200RelatedObjectsOrganization
     */
    owner_id?: number;
    /**
     * The address of the organization that is associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsOrganization
     */
    address?: string;
    /**
     * Whether the associated organization is active or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200RelatedObjectsOrganization
     */
    active_flag?: boolean;
    /**
     * The BCC email of the organization associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsOrganization
     */
    cc_email?: string;
}
/**
 * The person who is associated with the deal
 * @export
 * @interface AddDealParticipantResponse200RelatedObjectsPerson
 */
export interface AddDealParticipantResponse200RelatedObjectsPerson {
    /**
     * Whether the associated person is active or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200RelatedObjectsPerson
     */
    active_flag?: boolean;
    /**
     * The name of the person associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsPerson
     */
    name?: string;
    /**
     * The emails of the person associated with the deal
     * @type {Array<AddDealParticipantResponse200RelatedObjectsPersonEmail>}
     * @memberof AddDealParticipantResponse200RelatedObjectsPerson
     */
    email?: Array<AddDealParticipantResponse200RelatedObjectsPersonEmail>;
    /**
     * The phone numbers of the person associated with the deal
     * @type {Array<AddDealParticipantResponse200RelatedObjectsPersonPhone>}
     * @memberof AddDealParticipantResponse200RelatedObjectsPerson
     */
    phone?: Array<AddDealParticipantResponse200RelatedObjectsPersonPhone>;
    /**
     * The ID of the owner of the person that is associated with the deal
     * @type {number}
     * @memberof AddDealParticipantResponse200RelatedObjectsPerson
     */
    owner_id?: number;
}
/**
 * 
 * @export
 * @interface AddDealParticipantResponse200RelatedObjectsPersonEmail
 */
export interface AddDealParticipantResponse200RelatedObjectsPersonEmail {
    /**
     * The type of the email
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsPersonEmail
     */
    label?: string;
    /**
     * The email of the associated person
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsPersonEmail
     */
    value?: string;
    /**
     * If this is the primary email or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200RelatedObjectsPersonEmail
     */
    primary?: boolean;
}
/**
 * 
 * @export
 * @interface AddDealParticipantResponse200RelatedObjectsPersonPhone
 */
export interface AddDealParticipantResponse200RelatedObjectsPersonPhone {
    /**
     * The type of the phone number
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsPersonPhone
     */
    label?: string;
    /**
     * The phone number of the person associated with the deal
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsPersonPhone
     */
    value?: string;
    /**
     * If this is the primary phone number or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200RelatedObjectsPersonPhone
     */
    primary?: boolean;
}
/**
 * The user who is associated with the deal
 * @export
 * @interface AddDealParticipantResponse200RelatedObjectsUser
 */
export interface AddDealParticipantResponse200RelatedObjectsUser {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddDealParticipantResponse200RelatedObjectsUser
     */
    id?: number;
    /**
     * The name of the user
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsUser
     */
    name?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsUser
     */
    email?: string;
    /**
     * If the user has a picture or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200RelatedObjectsUser
     */
    has_pic?: boolean;
    /**
     * The user picture hash
     * @type {string}
     * @memberof AddDealParticipantResponse200RelatedObjectsUser
     */
    pic_hash?: string;
    /**
     * Whether the user is active or not
     * @type {boolean}
     * @memberof AddDealParticipantResponse200RelatedObjectsUser
     */
    active_flag?: boolean;
}
/**
 * 
 * @export
 * @interface AddDealProductRequest
 */
export interface AddDealProductRequest {
}
/**
 * 
 * @export
 * @interface AddDealRequest
 */
export interface AddDealRequest {
    /**
     * The value of the deal. If omitted, value will be set to 0.
     * @type {string}
     * @memberof AddDealRequest
     */
    value?: string;
    /**
     * The currency of the deal. Accepts a 3-character currency code. If omitted, currency will be set to the default currency of the authorized user.
     * @type {string}
     * @memberof AddDealRequest
     */
    currency?: string;
    /**
     * The ID of the user which will be the owner of the created deal. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof AddDealRequest
     */
    user_id?: number;
    /**
     * The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first. This property is required unless `org_id` is specified.
     * @type {number}
     * @memberof AddDealRequest
     */
    person_id?: number;
    /**
     * The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first. This property is required unless `person_id` is specified.
     * @type {number}
     * @memberof AddDealRequest
     */
    org_id?: number;
    /**
     * The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored.
     * @type {number}
     * @memberof AddDealRequest
     */
    pipeline_id?: number;
    /**
     * The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`. If omitted, the deal will be placed in the first stage of the default pipeline.
     * @type {number}
     * @memberof AddDealRequest
     */
    stage_id?: number;
    /**
     * open = Open, won = Won, lost = Lost, deleted = Deleted. If omitted, status will be set to open.
     * @type {string}
     * @memberof AddDealRequest
     */
    status?: AddDealRequest.StatusEnum;
    /**
     * The expected close date of the deal. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof AddDealRequest
     */
    expected_close_date?: string;
    /**
     * The success probability percentage of the deal. Used/shown only when `deal_probability` for the pipeline of the deal is enabled.
     * @type {number}
     * @memberof AddDealRequest
     */
    probability?: number;
    /**
     * The optional message about why the deal was lost (to be used when status = lost)
     * @type {string}
     * @memberof AddDealRequest
     */
    lost_reason?: string;
    /**
     * The visibility of the deal. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof AddDealRequest
     */
    visible_to?: string;
    /**
     * The optional creation date & time of the deal in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddDealRequest
     */
    add_time?: string;
}

/**
 * @export
 * @namespace AddDealRequest
 */
export namespace AddDealRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Open = <any> 'open',
        Won = <any> 'won',
        Lost = <any> 'lost',
        Deleted = <any> 'deleted'
    }
}
/**
 * 
 * @export
 * @interface AddFileAndLinkItRequest
 */
export interface AddFileAndLinkItRequest {
    /**
     * The file type
     * @type {string}
     * @memberof AddFileAndLinkItRequest
     */
    file_type: AddFileAndLinkItRequest.FileTypeEnum;
    /**
     * The title of the file
     * @type {string}
     * @memberof AddFileAndLinkItRequest
     */
    title: string;
    /**
     * The item type
     * @type {string}
     * @memberof AddFileAndLinkItRequest
     */
    item_type: AddFileAndLinkItRequest.ItemTypeEnum;
    /**
     * The ID of the item to associate the file with
     * @type {number}
     * @memberof AddFileAndLinkItRequest
     */
    item_id: number;
    /**
     * The location type to send the file to. Only `googledrive` is supported at the moment.
     * @type {string}
     * @memberof AddFileAndLinkItRequest
     */
    remote_location: AddFileAndLinkItRequest.RemoteLocationEnum;
}

/**
 * @export
 * @namespace AddFileAndLinkItRequest
 */
export namespace AddFileAndLinkItRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum FileTypeEnum {
        Gdoc = <any> 'gdoc',
        Gslides = <any> 'gslides',
        Gsheet = <any> 'gsheet',
        Gform = <any> 'gform',
        Gdraw = <any> 'gdraw'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ItemTypeEnum {
        Deal = <any> 'deal',
        Organization = <any> 'organization',
        Person = <any> 'person'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RemoteLocationEnum {
        Googledrive = <any> 'googledrive'
    }
}
/**
 * 
 * @export
 * @interface AddFileAndLinkItResponse200
 */
export interface AddFileAndLinkItResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddFileAndLinkItResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {LinkFileToItemResponse200Data}
     * @memberof AddFileAndLinkItResponse200
     */
    data?: LinkFileToItemResponse200Data;
}
/**
 * 
 * @export
 * @interface AddFileRequest
 */
export interface AddFileRequest {
    /**
     * A single file, supplied in the multipart/form-data encoding and contained within the given boundaries
     * @type {Blob}
     * @memberof AddFileRequest
     */
    file: Blob;
    /**
     * The ID of the deal to associate file(s) with
     * @type {number}
     * @memberof AddFileRequest
     */
    deal_id?: number;
    /**
     * The ID of the person to associate file(s) with
     * @type {number}
     * @memberof AddFileRequest
     */
    person_id?: number;
    /**
     * The ID of the organization to associate file(s) with
     * @type {number}
     * @memberof AddFileRequest
     */
    org_id?: number;
    /**
     * The ID of the product to associate file(s) with
     * @type {number}
     * @memberof AddFileRequest
     */
    product_id?: number;
    /**
     * The ID of the activity to associate file(s) with
     * @type {number}
     * @memberof AddFileRequest
     */
    activity_id?: number;
}
/**
 * 
 * @export
 * @interface AddFileResponse200
 */
export interface AddFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddFileResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {LinkFileToItemResponse200Data}
     * @memberof AddFileResponse200
     */
    data?: LinkFileToItemResponse200Data;
}
/**
 * 
 * @export
 * @interface AddFilterRequest
 */
export interface AddFilterRequest {
    /**
     * The name of the filter
     * @type {string}
     * @memberof AddFilterRequest
     */
    name: string;
    /**
     * The conditions of the filter as a JSON object. It requires a minimum structure as follows: `{\"glue\":\"and\",\"conditions\":[{\"glue\":\"and\",\"conditions\": [CONDITION_OBJECTS]},{\"glue\":\"or\",\"conditions\":[CONDITION_OBJECTS]}]}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: `{\"object\":\"\",\"field_id\":\"\", \"operator\":\"\",\"value\":\"\", \"extra_value\":\"\"}` or leave the array empty. Depending on the object type you should use another API endpoint to get `field_id`. There are five types of objects you can choose from: `\"person\"`, `\"deal\"`, `\"organization\"`, `\"product\"`, `\"activity\"` and you can use these types of operators depending on what type of a field you have: `\"IS NOT NULL\"`, `\"IS NULL\"`, `\"<=\"`, `\">=\"`, `\"<\"`, `\">\"`, `\"!=\"`, `\"=\"`, `\"LIKE '$%'\"`, `\"LIKE '%$%'\"`, `\"NOT LIKE '$%'\"`. To get a better understanding of how filters work try creating them directly from the Pipedrive application.
     * @type {any}
     * @memberof AddFilterRequest
     */
    conditions: any;
    /**
     * The type of filter to create
     * @type {string}
     * @memberof AddFilterRequest
     */
    type: string;
}
/**
 * 
 * @export
 * @interface AddGoalRequest
 */
export interface AddGoalRequest {
}
/**
 * 
 * @export
 * @interface AddLeadLabelRequest
 */
export interface AddLeadLabelRequest {
    /**
     * The name of the lead label
     * @type {string}
     * @memberof AddLeadLabelRequest
     */
    name: string;
    /**
     * The color of the label. Only a subset of colors can be used.
     * @type {string}
     * @memberof AddLeadLabelRequest
     */
    color: AddLeadLabelRequest.ColorEnum;
}

/**
 * @export
 * @namespace AddLeadLabelRequest
 */
export namespace AddLeadLabelRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ColorEnum {
        Green = <any> 'green',
        Blue = <any> 'blue',
        Red = <any> 'red',
        Yellow = <any> 'yellow',
        Purple = <any> 'purple',
        Gray = <any> 'gray'
    }
}
/**
 * 
 * @export
 * @interface AddLeadRequest
 */
export interface AddLeadRequest {
    /**
     * The name of the lead
     * @type {string}
     * @memberof AddLeadRequest
     */
    title: string;
    /**
     * The ID of the user which will be the owner of the created lead. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof AddLeadRequest
     */
    owner_id?: number;
    /**
     * The IDs of the lead labels which will be associated with the lead
     * @type {Array<string>}
     * @memberof AddLeadRequest
     */
    label_ids?: Array<string>;
    /**
     * The ID of a person which this lead will be linked to. If the person does not exist yet, it needs to be created first. This property is required unless `organization_id` is specified.
     * @type {number}
     * @memberof AddLeadRequest
     */
    person_id?: number;
    /**
     * The ID of an organization which this lead will be linked to. If the organization does not exist yet, it needs to be created first. This property is required unless `person_id` is specified.
     * @type {number}
     * @memberof AddLeadRequest
     */
    organization_id?: number;
    /**
     * 
     * @type {LeadsValue}
     * @memberof AddLeadRequest
     */
    value?: LeadsValue;
    /**
     * The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof AddLeadRequest
     */
    expected_close_date?: string;
    /**
     * The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof AddLeadRequest
     */
    visible_to?: string;
    /**
     * A flag indicating whether the lead was seen by someone in the Pipedrive UI
     * @type {boolean}
     * @memberof AddLeadRequest
     */
    was_seen?: boolean;
}
/**
 * 
 * @export
 * @interface AddOrUpdateGoalResponse200
 */
export interface AddOrUpdateGoalResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddOrUpdateGoalResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {AddOrUpdateGoalResponse200Data}
     * @memberof AddOrUpdateGoalResponse200
     */
    data?: AddOrUpdateGoalResponse200Data;
}
/**
 * 
 * @export
 * @interface AddOrUpdateGoalResponse200Data
 */
export interface AddOrUpdateGoalResponse200Data {
    /**
     * 
     * @type {GetGoalsResponse200DataGoals}
     * @memberof AddOrUpdateGoalResponse200Data
     */
    goal?: GetGoalsResponse200DataGoals;
}
/**
 * 
 * @export
 * @interface AddOrUpdateLeadLabelResponse200
 */
export interface AddOrUpdateLeadLabelResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof AddOrUpdateLeadLabelResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {GetLeadLabelsResponse200Data}
     * @memberof AddOrUpdateLeadLabelResponse200
     */
    data?: GetLeadLabelsResponse200Data;
}
/**
 * 
 * @export
 * @interface AddOrUpdateRoleSettingRequest
 */
export interface AddOrUpdateRoleSettingRequest {
    /**
     * 
     * @type {string}
     * @memberof AddOrUpdateRoleSettingRequest
     */
    setting_key: AddOrUpdateRoleSettingRequest.SettingKeyEnum;
    /**
     * Possible values for the `default_visibility` setting depending on the subscription plan:<br> <table class='role-setting'> <caption><b>Essential / Advanced plan</b></caption> <tr><th><b>Value</b></th><th><b>Description</b></th></tr> <tr><td>`1`</td><td>Owner & Followers</td></tr> <tr><td>`3`</td><td>Entire company</td></tr> </table> <br> <table class='role-setting'> <caption><b>Professional / Enterprise plan</b></caption> <tr><th><b>Value</b></th><th><b>Description</b></th></tr> <tr><td>`1`</td><td>Owner only</td></tr> <tr><td>`3`</td><td>Owner&#39;s visibility group</td></tr> <tr><td>`5`</td><td>Owner&#39;s visibility group and sub-groups</td></tr> <tr><td>`7`</td><td>Entire company</td></tr> </table> <br> Read more about visibility groups <a href='https://support.pipedrive.com/en/article/visibility-groups'>here</a>.
     * @type {number}
     * @memberof AddOrUpdateRoleSettingRequest
     */
    value: AddOrUpdateRoleSettingRequest.ValueEnum;
}

/**
 * @export
 * @namespace AddOrUpdateRoleSettingRequest
 */
export namespace AddOrUpdateRoleSettingRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SettingKeyEnum {
        DealDefaultVisibility = <any> 'deal_default_visibility',
        LeadDefaultVisibility = <any> 'lead_default_visibility',
        OrgDefaultVisibility = <any> 'org_default_visibility',
        PersonDefaultVisibility = <any> 'person_default_visibility',
        ProductDefaultVisibility = <any> 'product_default_visibility'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValueEnum {
        NUMBER_1 = <any> 1,
        NUMBER_3 = <any> 3,
        NUMBER_5 = <any> 5,
        NUMBER_7 = <any> 7
    }
}
/**
 * 
 * @export
 * @interface AddOrUpdateRoleSettingResponse200
 */
export interface AddOrUpdateRoleSettingResponse200 {
    /**
     * 
     * @type {AddOrUpdateRoleSettingResponse200Data}
     * @memberof AddOrUpdateRoleSettingResponse200
     */
    data?: AddOrUpdateRoleSettingResponse200Data;
}
/**
 * The response data
 * @export
 * @interface AddOrUpdateRoleSettingResponse200Data
 */
export interface AddOrUpdateRoleSettingResponse200Data {
    /**
     * The ID of the role
     * @type {number}
     * @memberof AddOrUpdateRoleSettingResponse200Data
     */
    id?: number;
    /**
     * The setting
     * @type {number}
     * @memberof AddOrUpdateRoleSettingResponse200Data
     */
    deal_default_visibility?: AddOrUpdateRoleSettingResponse200Data.DealDefaultVisibilityEnum;
}

/**
 * @export
 * @namespace AddOrUpdateRoleSettingResponse200Data
 */
export namespace AddOrUpdateRoleSettingResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum DealDefaultVisibilityEnum {
        NUMBER_1 = <any> 1,
        NUMBER_3 = <any> 3,
        NUMBER_5 = <any> 5,
        NUMBER_7 = <any> 7
    }
}
/**
 * 
 * @export
 * @interface AddOrganizationFollowerRequest
 */
export interface AddOrganizationFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddOrganizationFollowerRequest
     */
    user_id: number;
}
/**
 * 
 * @export
 * @interface AddOrganizationFollowerResponse200
 */
export interface AddOrganizationFollowerResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof AddOrganizationFollowerResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof AddOrganizationFollowerResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface AddOrganizationRelationshipRequest
 */
export interface AddOrganizationRelationshipRequest {
    /**
     * The ID of the base organization for the returned calculated values
     * @type {number}
     * @memberof AddOrganizationRelationshipRequest
     */
    org_id?: number;
    /**
     * The type of organization relationship
     * @type {string}
     * @memberof AddOrganizationRelationshipRequest
     */
    type: AddOrganizationRelationshipRequest.TypeEnum;
    /**
     * The owner of the relationship. If type is `parent`, then the owner is the parent and the linked organization is the daughter.
     * @type {number}
     * @memberof AddOrganizationRelationshipRequest
     */
    rel_owner_org_id: number;
    /**
     * The linked organization in the relationship. If type is `parent`, then the linked organization is the daughter.
     * @type {number}
     * @memberof AddOrganizationRelationshipRequest
     */
    rel_linked_org_id: number;
}

/**
 * @export
 * @namespace AddOrganizationRelationshipRequest
 */
export namespace AddOrganizationRelationshipRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Parent = <any> 'parent',
        Related = <any> 'related'
    }
}
/**
 * 
 * @export
 * @interface AddOrganizationRelationshipResponse200
 */
export interface AddOrganizationRelationshipResponse200 {
    /**
     * 
     * @type {AddOrganizationRelationshipResponse200Data}
     * @memberof AddOrganizationRelationshipResponse200
     */
    data?: AddOrganizationRelationshipResponse200Data;
    /**
     * 
     * @type {GetOrganizationRelationshipsResponse200RelatedObjects}
     * @memberof AddOrganizationRelationshipResponse200
     */
    related_objects?: GetOrganizationRelationshipsResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface AddOrganizationRelationshipResponse200Data
 */
export interface AddOrganizationRelationshipResponse200Data {
    /**
     * The ID of the organization relationship
     * @type {number}
     * @memberof AddOrganizationRelationshipResponse200Data
     */
    id?: number;
    /**
     * The type of the relationship
     * @type {string}
     * @memberof AddOrganizationRelationshipResponse200Data
     */
    type?: string;
    /**
     * 
     * @type {any}
     * @memberof AddOrganizationRelationshipResponse200Data
     */
    rel_owner_org_id?: any;
    /**
     * 
     * @type {any}
     * @memberof AddOrganizationRelationshipResponse200Data
     */
    rel_linked_org_id?: any;
    /**
     * The creation date and time of the relationship
     * @type {string}
     * @memberof AddOrganizationRelationshipResponse200Data
     */
    add_time?: string;
    /**
     * The last updated date and time of the relationship
     * @type {string}
     * @memberof AddOrganizationRelationshipResponse200Data
     */
    update_time?: string;
    /**
     * Whether the relationship is active or not
     * @type {string}
     * @memberof AddOrganizationRelationshipResponse200Data
     */
    active_flag?: string;
}
/**
 * 
 * @export
 * @interface AddOrganizationRequest
 */
export interface AddOrganizationRequest {
    /**
     * The ID of the user who will be marked as the owner of this organization. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddOrganizationRequest
     */
    owner_id?: number;
    /**
     * The visibility of the organization. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof AddOrganizationRequest
     */
    visible_to?: string;
}
/**
 * 
 * @export
 * @interface AddOrganizationResponse200
 */
export interface AddOrganizationResponse200 {
    /**
     * 
     * @type {any}
     * @memberof AddOrganizationResponse200
     */
    data?: any;
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjects}
     * @memberof AddOrganizationResponse200
     */
    related_objects?: UpdateOrganizationResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface AddPersonFollowerRequest
 */
export interface AddPersonFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddPersonFollowerRequest
     */
    user_id: number;
}
/**
 * 
 * @export
 * @interface AddPersonFollowerResponse200
 */
export interface AddPersonFollowerResponse200 {
    /**
     * 
     * @type {AddPersonFollowerResponse200Data}
     * @memberof AddPersonFollowerResponse200
     */
    data?: AddPersonFollowerResponse200Data;
}
/**
 * 
 * @export
 * @interface AddPersonFollowerResponse200Data
 */
export interface AddPersonFollowerResponse200Data {
    /**
     * The ID of the user who was added as a follower to a person
     * @type {number}
     * @memberof AddPersonFollowerResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the follower
     * @type {number}
     * @memberof AddPersonFollowerResponse200Data
     */
    id?: number;
    /**
     * The ID of the person to whom the follower was added
     * @type {number}
     * @memberof AddPersonFollowerResponse200Data
     */
    person_id?: number;
    /**
     * The date and time when the follower was added to a person. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddPersonFollowerResponse200Data
     */
    add_time?: string;
}
/**
 * 
 * @export
 * @interface AddPersonPictureRequest
 */
export interface AddPersonPictureRequest {
    /**
     * One image supplied in the multipart/form-data encoding
     * @type {Blob}
     * @memberof AddPersonPictureRequest
     */
    file: Blob;
    /**
     * X coordinate to where start cropping form (in pixels)
     * @type {number}
     * @memberof AddPersonPictureRequest
     */
    crop_x?: number;
    /**
     * Y coordinate to where start cropping form (in pixels)
     * @type {number}
     * @memberof AddPersonPictureRequest
     */
    crop_y?: number;
    /**
     * The width of the cropping area (in pixels)
     * @type {number}
     * @memberof AddPersonPictureRequest
     */
    crop_width?: number;
    /**
     * The height of the cropping area (in pixels)
     * @type {number}
     * @memberof AddPersonPictureRequest
     */
    crop_height?: number;
}
/**
 * 
 * @export
 * @interface AddPersonPictureResponse200
 */
export interface AddPersonPictureResponse200 {
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjectsPicture}
     * @memberof AddPersonPictureResponse200
     */
    data?: UpdateOrganizationResponse200RelatedObjectsPicture;
}
/**
 * 
 * @export
 * @interface AddPersonRequest
 */
export interface AddPersonRequest {
    /**
     * The ID of the user who will be marked as the owner of this person. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddPersonRequest
     */
    owner_id?: number;
    /**
     * The ID of the organization this person will belong to
     * @type {number}
     * @memberof AddPersonRequest
     */
    org_id?: number;
    /**
     * List of email data related to the person
     * @type {Array<PersonsEmail>}
     * @memberof AddPersonRequest
     */
    email?: Array<PersonsEmail>;
    /**
     * The primary email of the person
     * @type {string}
     * @memberof AddPersonRequest
     */
    primary_email?: string;
    /**
     * List of phone data related to the person
     * @type {Array<PersonsPhone>}
     * @memberof AddPersonRequest
     */
    phone?: Array<PersonsPhone>;
    /**
     * The visibility of the person. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof AddPersonRequest
     */
    visible_to?: string;
    /**
     * If the person does not have a valid email address, then the marketing status is **not set** and `no_consent` is returned for the `marketing_status` value when the new person is created. If the change is forbidden, the status will remain unchanged for every call that tries to modify the marketing status. Please be aware that it is only allowed **once** to change the marketing status from an old status to a new one.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`no_consent`</td><td>The customer has not given consent to receive any marketing communications</td></tr><tr><td>`unsubscribed`</td><td>The customers have unsubscribed from ALL marketing communications</td></tr><tr><td>`subscribed`</td><td>The customers are subscribed and are counted towards marketing caps</td></tr><tr><td>`archived`</td><td>The customers with `subscribed` status can be moved to `archived` to save consent, but they are not paid for</td></tr></table>
     * @type {string}
     * @memberof AddPersonRequest
     */
    marketing_status?: string;
    /**
     * The optional creation date & time of the person in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof AddPersonRequest
     */
    add_time?: string;
}
/**
 * 
 * @export
 * @interface AddPersonResponse200
 */
export interface AddPersonResponse200 {
    /**
     * 
     * @type {any}
     * @memberof AddPersonResponse200
     */
    data?: any;
    /**
     * 
     * @type {AddPersonResponse200RelatedObjects}
     * @memberof AddPersonResponse200
     */
    related_objects?: AddPersonResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface AddPersonResponse200RelatedObjects
 */
export interface AddPersonResponse200RelatedObjects {
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof AddPersonResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
}
/**
 * 
 * @export
 * @interface AddPipelineResponse200
 */
export interface AddPipelineResponse200 {
    /**
     * 
     * @type {AddPipelineResponse200Data}
     * @memberof AddPipelineResponse200
     */
    data?: AddPipelineResponse200Data;
}
/**
 * The pipeline object
 * @export
 * @interface AddPipelineResponse200Data
 */
export interface AddPipelineResponse200Data {
    /**
     * The ID of the pipeline
     * @type {number}
     * @memberof AddPipelineResponse200Data
     */
    id?: number;
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof AddPipelineResponse200Data
     */
    name?: string;
    /**
     * The pipeline title displayed in the URL
     * @type {string}
     * @memberof AddPipelineResponse200Data
     */
    url_title?: string;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof AddPipelineResponse200Data
     */
    order_nr?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {boolean}
     * @memberof AddPipelineResponse200Data
     */
    active?: boolean;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {boolean}
     * @memberof AddPipelineResponse200Data
     */
    deal_probability?: boolean;
    /**
     * The pipeline creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof AddPipelineResponse200Data
     */
    add_time?: string;
    /**
     * The pipeline update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof AddPipelineResponse200Data
     */
    update_time?: string;
}
/**
 * 
 * @export
 * @interface AddProductFollowerRequest
 */
export interface AddProductFollowerRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddProductFollowerRequest
     */
    user_id: number;
}
/**
 * 
 * @export
 * @interface AddProductRequest
 */
export interface AddProductRequest {
    /**
     * The product code
     * @type {string}
     * @memberof AddProductRequest
     */
    code?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof AddProductRequest
     */
    unit?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof AddProductRequest
     */
    tax?: number;
    /**
     * Whether this product will be made active or not
     * @type {number}
     * @memberof AddProductRequest
     */
    active_flag?: AddProductRequest.ActiveFlagEnum;
    /**
     * Whether this product can be selected in deals or not
     * @type {number}
     * @memberof AddProductRequest
     */
    selectable?: AddProductRequest.SelectableEnum;
    /**
     * The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof AddProductRequest
     */
    visible_to?: string;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddProductRequest
     */
    owner_id?: number;
    /**
     * An array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `overhead_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and a default currency based on the company's currency will be assigned.
     * @type {Array<any>}
     * @memberof AddProductRequest
     */
    prices?: Array<any>;
}

/**
 * @export
 * @namespace AddProductRequest
 */
export namespace AddProductRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ActiveFlagEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SelectableEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface AddProductRequest1
 */
export interface AddProductRequest1 {
    /**
     * The product code
     * @type {string}
     * @memberof AddProductRequest1
     */
    code?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof AddProductRequest1
     */
    unit?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof AddProductRequest1
     */
    tax?: number;
    /**
     * Whether this product will be made active or not
     * @type {number}
     * @memberof AddProductRequest1
     */
    active_flag?: AddProductRequest1.ActiveFlagEnum;
    /**
     * Whether this product can be selected in deals or not
     * @type {number}
     * @memberof AddProductRequest1
     */
    selectable?: AddProductRequest1.SelectableEnum;
    /**
     * The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof AddProductRequest1
     */
    visible_to?: string;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof AddProductRequest1
     */
    owner_id?: number;
    /**
     * An array of objects, each containing: `currency` (string), `price` (number), `cost` (number, optional), `overhead_cost` (number, optional). Note that there can only be one price per product per currency. When `prices` is omitted altogether, a default price of 0 and a default currency based on the company's currency will be assigned.
     * @type {Array<any>}
     * @memberof AddProductRequest1
     */
    prices?: Array<any>;
}

/**
 * @export
 * @namespace AddProductRequest1
 */
export namespace AddProductRequest1 {
    /**
     * @export
     * @enum {string}
     */
    export enum ActiveFlagEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SelectableEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface AddRecurringSubscriptionRequest
 */
export interface AddRecurringSubscriptionRequest {
    /**
     * The ID of the deal this recurring subscription is associated with
     * @type {number}
     * @memberof AddRecurringSubscriptionRequest
     */
    deal_id: number;
    /**
     * The currency of the recurring subscription. Accepts a 3-character currency code.
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    currency: string;
    /**
     * The description of the recurring subscription
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    description?: string;
    /**
     * The interval between payments
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    cadence_type: AddRecurringSubscriptionRequest.CadenceTypeEnum;
    /**
     * Shows how many payments the subscription has. Note that one field must be set: `cycles_count` or `infinite`. If `cycles_count` is set, then `cycle_amount` and `start_date` are also required.
     * @type {number}
     * @memberof AddRecurringSubscriptionRequest
     */
    cycles_count?: number;
    /**
     * The amount of each payment
     * @type {number}
     * @memberof AddRecurringSubscriptionRequest
     */
    cycle_amount: number;
    /**
     * The start date of the recurring subscription. Format: YYYY-MM-DD
     * @type {string}
     * @memberof AddRecurringSubscriptionRequest
     */
    start_date: string;
    /**
     * This indicates that the recurring subscription will last until it's manually canceled or deleted. Note that only one field must be set: `cycles_count` or `infinite`.
     * @type {boolean}
     * @memberof AddRecurringSubscriptionRequest
     */
    infinite?: boolean;
    /**
     * Array of additional payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with an explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<any>}
     * @memberof AddRecurringSubscriptionRequest
     */
    payments?: Array<any>;
    /**
     * Indicates that the deal value must be set to recurring subscription's MRR value
     * @type {boolean}
     * @memberof AddRecurringSubscriptionRequest
     */
    update_deal_value?: boolean;
}

/**
 * @export
 * @namespace AddRecurringSubscriptionRequest
 */
export namespace AddRecurringSubscriptionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum CadenceTypeEnum {
        Weekly = <any> 'weekly',
        Monthly = <any> 'monthly',
        Quarterly = <any> 'quarterly',
        Yearly = <any> 'yearly'
    }
}
/**
 * 
 * @export
 * @interface AddRoleAssignmentRequest
 */
export interface AddRoleAssignmentRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof AddRoleAssignmentRequest
     */
    user_id: number;
}
/**
 * 
 * @export
 * @interface AddRoleAssignmentResponse200
 */
export interface AddRoleAssignmentResponse200 {
    /**
     * 
     * @type {AddRoleAssignmentResponse200Data}
     * @memberof AddRoleAssignmentResponse200
     */
    data?: AddRoleAssignmentResponse200Data;
}
/**
 * The response data
 * @export
 * @interface AddRoleAssignmentResponse200Data
 */
export interface AddRoleAssignmentResponse200Data {
    /**
     * The ID of the user that was added to the role
     * @type {number}
     * @memberof AddRoleAssignmentResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the role the user was added to
     * @type {number}
     * @memberof AddRoleAssignmentResponse200Data
     */
    role_id?: number;
}
/**
 * The details of the role
 * @export
 * @interface AddRoleRequest
 */
export interface AddRoleRequest {
    /**
     * The name of the role
     * @type {string}
     * @memberof AddRoleRequest
     */
    name: string;
    /**
     * The ID of the parent role
     * @type {number}
     * @memberof AddRoleRequest
     */
    parent_role_id?: number;
}
/**
 * 
 * @export
 * @interface AddRoleResponse200
 */
export interface AddRoleResponse200 {
    /**
     * 
     * @type {AddRoleResponse200Data}
     * @memberof AddRoleResponse200
     */
    data?: AddRoleResponse200Data;
}
/**
 * The response data
 * @export
 * @interface AddRoleResponse200Data
 */
export interface AddRoleResponse200Data {
    /**
     * The ID of the created role
     * @type {number}
     * @memberof AddRoleResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AddStageRequest
 */
export interface AddStageRequest {
    /**
     * The name of the stage
     * @type {string}
     * @memberof AddStageRequest
     */
    name: string;
    /**
     * The ID of the pipeline to add stage to
     * @type {number}
     * @memberof AddStageRequest
     */
    pipeline_id: number;
    /**
     * The success probability percentage of the deal. Used/shown when deal weighted values are used.
     * @type {number}
     * @memberof AddStageRequest
     */
    deal_probability?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof AddStageRequest
     */
    rotten_flag?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof AddStageRequest
     */
    rotten_days?: number;
}
/**
 * 
 * @export
 * @interface AddSubscriptionInstallmentRequest
 */
export interface AddSubscriptionInstallmentRequest {
    /**
     * The ID of the deal this installment subscription is associated with
     * @type {number}
     * @memberof AddSubscriptionInstallmentRequest
     */
    deal_id: number;
    /**
     * The currency of the installment subscription. Accepts a 3-character currency code.
     * @type {string}
     * @memberof AddSubscriptionInstallmentRequest
     */
    currency: string;
    /**
     * Array of payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with an explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<any>}
     * @memberof AddSubscriptionInstallmentRequest
     */
    payments: Array<any>;
    /**
     * Indicates that the deal value must be set to the installment subscription's total value
     * @type {boolean}
     * @memberof AddSubscriptionInstallmentRequest
     */
    update_deal_value?: boolean;
}
/**
 * 
 * @export
 * @interface AddTeamRequest
 */
export interface AddTeamRequest {
    /**
     * The team name
     * @type {string}
     * @memberof AddTeamRequest
     */
    name: string;
    /**
     * The team description
     * @type {string}
     * @memberof AddTeamRequest
     */
    description?: string;
    /**
     * The team manager ID
     * @type {number}
     * @memberof AddTeamRequest
     */
    manager_id: number;
    /**
     * The IDs of the users that belong to the team
     * @type {Array<number>}
     * @memberof AddTeamRequest
     */
    users?: Array<number>;
}
/**
 * 
 * @export
 * @interface AddTeamUserRequest
 */
export interface AddTeamUserRequest {
    /**
     * The list of user IDs
     * @type {Array<number>}
     * @memberof AddTeamUserRequest
     */
    users: Array<number>;
}
/**
 * 
 * @export
 * @interface AddUserRequest
 */
export interface AddUserRequest {
    /**
     * The email of the user
     * @type {string}
     * @memberof AddUserRequest
     */
    email: string;
    /**
     * The name of the user
     * @type {string}
     * @memberof AddUserRequest
     */
    name?: string;
    /**
     * The access given to the user. Each item in the array represents access to a specific app. Optionally may include either admin flag or permission set ID to specify which access to give within the app. If both are omitted, the default access for the corresponding app will be used. It requires structure as follows: `[{ app: 'sales', permission_set_id: '62cc4d7f-4038-4352-abf3-a8c1c822b631' }, { app: 'global', admin: true }, { app: 'account_settings' }]` 
     * @type {Array<UsersAccess>}
     * @memberof AddUserRequest
     */
    access?: Array<UsersAccess>;
    /**
     * Whether the user is active or not. `false` = Not activated, `true` = Activated
     * @type {boolean}
     * @memberof AddUserRequest
     */
    active_flag?: boolean;
}
/**
 * 
 * @export
 * @interface AddWebhookRequest
 */
export interface AddWebhookRequest {
    /**
     * A full, valid, publicly accessible URL which determines where to send the notifications. Please note that you cannot use Pipedrive API endpoints as the `subscription_url` and the chosen URL must not redirect to another link.
     * @type {string}
     * @memberof AddWebhookRequest
     */
    subscription_url: string;
    /**
     * The type of action to receive notifications about. Wildcard will match all supported actions.
     * @type {string}
     * @memberof AddWebhookRequest
     */
    event_action: AddWebhookRequest.EventActionEnum;
    /**
     * The type of object to receive notifications about. Wildcard will match all supported objects.
     * @type {string}
     * @memberof AddWebhookRequest
     */
    event_object: AddWebhookRequest.EventObjectEnum;
    /**
     * The ID of the user this Webhook will be authorized with. If not set, current authorized user will be used. Note that this does not filter only certain user's events  rather, this specifies the user's permissions under which each event is checked. Events about objects the selected user is not entitled to access are not sent. If you want to receive notifications for all events, a top-level admin user should be used.
     * @type {number}
     * @memberof AddWebhookRequest
     */
    user_id?: number;
    /**
     * The HTTP basic auth username of the subscription URL endpoint (if required)
     * @type {string}
     * @memberof AddWebhookRequest
     */
    http_auth_user?: string;
    /**
     * The HTTP basic auth password of the subscription URL endpoint (if required)
     * @type {string}
     * @memberof AddWebhookRequest
     */
    http_auth_password?: string;
}

/**
 * @export
 * @namespace AddWebhookRequest
 */
export namespace AddWebhookRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum EventActionEnum {
        Added = <any> 'added',
        Updated = <any> 'updated',
        Merged = <any> 'merged',
        Deleted = <any> 'deleted',
        Star = <any> '*'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EventObjectEnum {
        Activity = <any> 'activity',
        ActivityType = <any> 'activityType',
        Deal = <any> 'deal',
        Note = <any> 'note',
        Organization = <any> 'organization',
        Person = <any> 'person',
        Pipeline = <any> 'pipeline',
        Product = <any> 'product',
        Stage = <any> 'stage',
        User = <any> 'user',
        Star = <any> '*'
    }
}
/**
 * 
 * @export
 * @interface BaseResponse200
 */
export interface BaseResponse200 {
    /**
     * The status of the response
     * @type {string}
     * @memberof BaseResponse200
     */
    status?: string;
}
/**
 * The details of the role
 * @export
 * @interface BaseRoleRequest
 */
export interface BaseRoleRequest {
    /**
     * The ID of the parent role
     * @type {number}
     * @memberof BaseRoleRequest
     */
    parent_role_id?: number;
    /**
     * The name of the role
     * @type {string}
     * @memberof BaseRoleRequest
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface BasicDealProductRequest
 */
export interface BasicDealProductRequest {
    /**
     * The price at which this product will be added to the deal
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    item_price: number;
    /**
     * Quantity  e.g. how many items of this product will be added to the deal
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    quantity: number;
    /**
     * The discount %. If omitted, will be set to 0.
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    discount_percentage?: number;
    /**
     * The duration of the product (when product durations are not enabled for the company or if omitted, defaults to 1)
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    duration?: number;
    /**
     * The ID of the product variation to use. When omitted, no variation will be used.
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    product_variation_id?: number;
    /**
     * Any textual comment associated with this product-deal attachment. Visible and editable in the application UI.
     * @type {string}
     * @memberof BasicDealProductRequest
     */
    comments?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    tax?: number;
    /**
     * Whether the product is enabled on the deal or not. This makes it possible to add products to a deal with a specific price and discount criteria - but keep them disabled, which refrains them from being included in the deal price calculation. When omitted, the product will be marked as enabled by default.
     * @type {number}
     * @memberof BasicDealProductRequest
     */
    enabled_flag?: number;
}
/**
 * 
 * @export
 * @interface BasicGoalRequest
 */
export interface BasicGoalRequest {
    /**
     * The title of the goal
     * @type {string}
     * @memberof BasicGoalRequest
     */
    title?: string;
    /**
     * Who this goal is assigned to. It requires the following JSON structure: { \"id\": \"1\", \"type\": \"person\" }. `type` can be either `person`, `company` or `team`. ID of the assignee person, company or team.
     * @type {any}
     * @memberof BasicGoalRequest
     */
    assignee?: any;
    /**
     * The type of the goal. It requires the following JSON structure: { \"name\": \"deals_started\", \"params\": { \"pipeline_id\": 1 } }. Type can be one of: `deals_won`, `deals_progressed`, `activities_completed`, `activities_added`, `deals_started` or `revenue_forecast`. `params` can include `pipeline_id`, `stage_id` or `activity_type_id`. `stage_id` is related to only `deals_progressed` type of goals and `activity_type_id` to `activities_completed` or `activities_added` types of goals. To track goal in all pipelines set `pipeline_id` as `null`.
     * @type {any}
     * @memberof BasicGoalRequest
     */
    type?: any;
    /**
     * The expected outcome of the goal. Expected outcome can be tracked either by `quantity` or by `sum`. It requires the following JSON structure: { \"target\": \"50\", \"tracking_metric\": \"quantity\" } or { \"target\": \"50\", \"tracking_metric\": \"sum\", \"currency_id\": 1 }. `currency_id` should only be added to `sum` type of goals.
     * @type {any}
     * @memberof BasicGoalRequest
     */
    expected_outcome?: any;
    /**
     * The date when the goal starts and ends. It requires the following JSON structure: { \"start\": \"2019-01-01\", \"end\": \"2022-12-31\" }. Date in format of YYYY-MM-DD. \"end\" can be set to `null` for an infinite, open-ended goal.
     * @type {any}
     * @memberof BasicGoalRequest
     */
    duration?: any;
    /**
     * The interval of the goal
     * @type {string}
     * @memberof BasicGoalRequest
     */
    interval?: BasicGoalRequest.IntervalEnum;
}

/**
 * @export
 * @namespace BasicGoalRequest
 */
export namespace BasicGoalRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum IntervalEnum {
        Weekly = <any> 'weekly',
        Monthly = <any> 'monthly',
        Quarterly = <any> 'quarterly',
        Yearly = <any> 'yearly'
    }
}
/**
 * 
 * @export
 * @interface CallLogResponse400
 */
export interface CallLogResponse400 {
    /**
     * 
     * @type {boolean}
     * @memberof CallLogResponse400
     */
    success?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse400
     */
    error?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse400
     */
    error_info?: string;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse400
     */
    data?: any;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse400
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface CallLogResponse403
 */
export interface CallLogResponse403 {
    /**
     * 
     * @type {boolean}
     * @memberof CallLogResponse403
     */
    success?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse403
     */
    error?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse403
     */
    error_info?: string;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse403
     */
    data?: any;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse403
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface CallLogResponse404
 */
export interface CallLogResponse404 {
    /**
     * 
     * @type {boolean}
     * @memberof CallLogResponse404
     */
    success?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse404
     */
    error?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse404
     */
    error_info?: string;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse404
     */
    data?: any;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse404
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface CallLogResponse409
 */
export interface CallLogResponse409 {
    /**
     * 
     * @type {boolean}
     * @memberof CallLogResponse409
     */
    success?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse409
     */
    error?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse409
     */
    error_info?: string;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse409
     */
    data?: any;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse409
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface CallLogResponse410
 */
export interface CallLogResponse410 {
    /**
     * 
     * @type {boolean}
     * @memberof CallLogResponse410
     */
    success?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse410
     */
    error?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse410
     */
    error_info?: string;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse410
     */
    data?: any;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse410
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface CallLogResponse500
 */
export interface CallLogResponse500 {
    /**
     * 
     * @type {boolean}
     * @memberof CallLogResponse500
     */
    success?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof CallLogResponse500
     */
    error?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof CallLogResponse500
     */
    error_info?: string;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse500
     */
    data?: any;
    /**
     * 
     * @type {any}
     * @memberof CallLogResponse500
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface CancelRecurringSubscriptionRequest
 */
export interface CancelRecurringSubscriptionRequest {
    /**
     * The subscription termination date. All payments after specified date will be deleted. Default value is the current date.
     * @type {string}
     * @memberof CancelRecurringSubscriptionRequest
     */
    end_date?: string;
}
/**
 * 
 * @export
 * @interface ChannelsBody
 */
export interface ChannelsBody {
    /**
     * The name of the channel
     * @type {string}
     * @memberof ChannelsBody
     */
    name: string;
    /**
     * The channel ID
     * @type {string}
     * @memberof ChannelsBody
     */
    provider_channel_id: string;
    /**
     * The URL for an icon that represents your channel
     * @type {string}
     * @memberof ChannelsBody
     */
    avatar_url?: string;
    /**
     * If true, enables templates logic on UI. Requires getTemplates endpoint implemented. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension).
     * @type {boolean}
     * @memberof ChannelsBody
     */
    template_support?: boolean;
    /**
     * It controls the icons (like the icon next to the conversation)
     * @type {string}
     * @memberof ChannelsBody
     */
    provider_type?: ChannelsBody.ProviderTypeEnum;
}

/**
 * @export
 * @namespace ChannelsBody
 */
export namespace ChannelsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum ProviderTypeEnum {
        Facebook = <any> 'facebook',
        Whatsapp = <any> 'whatsapp',
        Other = <any> 'other'
    }
}
/**
 * 
 * @export
 * @interface ChannelsmessagesreceiveAttachments
 */
export interface ChannelsmessagesreceiveAttachments {
    /**
     * The ID of the attachment
     * @type {string}
     * @memberof ChannelsmessagesreceiveAttachments
     */
    id: string;
    /**
     * The mime-type of the attachment
     * @type {string}
     * @memberof ChannelsmessagesreceiveAttachments
     */
    type: string;
    /**
     * The name of the attachment
     * @type {string}
     * @memberof ChannelsmessagesreceiveAttachments
     */
    name?: string;
    /**
     * The size of the attachment
     * @type {number}
     * @memberof ChannelsmessagesreceiveAttachments
     */
    size?: number;
    /**
     * A URL to the file
     * @type {string}
     * @memberof ChannelsmessagesreceiveAttachments
     */
    url: string;
    /**
     * A URL to a preview picture of the file
     * @type {string}
     * @memberof ChannelsmessagesreceiveAttachments
     */
    preview_url?: string;
    /**
     * If true, it will use the getMessageById endpoint for fetching updated attachment's urls. Find out more [here](https://pipedrive.readme.io/docs/implementing-messaging-app-extension)
     * @type {boolean}
     * @memberof ChannelsmessagesreceiveAttachments
     */
    link_expires?: boolean;
}
/**
 * 
 * @export
 * @interface CommentPostPutObject
 */
export interface CommentPostPutObject {
    /**
     * The content of the comment in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof CommentPostPutObject
     */
    content: string;
}
/**
 * 
 * @export
 * @interface CommentPostPutObject1
 */
export interface CommentPostPutObject1 {
    /**
     * The content of the comment in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof CommentPostPutObject1
     */
    content: string;
}
/**
 * 
 * @export
 * @interface CreateFieldRequest
 */
export interface CreateFieldRequest {
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item's visibility setting</td></tr></table>
     * @type {string}
     * @memberof CreateFieldRequest
     */
    field_type: CreateFieldRequest.FieldTypeEnum;
}

/**
 * @export
 * @namespace CreateFieldRequest
 */
export namespace CreateFieldRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldTypeEnum {
        Address = <any> 'address',
        Date = <any> 'date',
        Daterange = <any> 'daterange',
        Double = <any> 'double',
        Enum = <any> 'enum',
        Monetary = <any> 'monetary',
        Org = <any> 'org',
        People = <any> 'people',
        Phone = <any> 'phone',
        Set = <any> 'set',
        Text = <any> 'text',
        Time = <any> 'time',
        Timerange = <any> 'timerange',
        User = <any> 'user',
        Varchar = <any> 'varchar',
        VarcharAuto = <any> 'varchar_auto',
        VisibleTo = <any> 'visible_to'
    }
}
/**
 * 
 * @export
 * @interface CreateFieldRequest1
 */
export interface CreateFieldRequest1 {
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item's visibility setting</td></tr></table>
     * @type {string}
     * @memberof CreateFieldRequest1
     */
    field_type: CreateFieldRequest1.FieldTypeEnum;
}

/**
 * @export
 * @namespace CreateFieldRequest1
 */
export namespace CreateFieldRequest1 {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldTypeEnum {
        Address = <any> 'address',
        Date = <any> 'date',
        Daterange = <any> 'daterange',
        Double = <any> 'double',
        Enum = <any> 'enum',
        Monetary = <any> 'monetary',
        Org = <any> 'org',
        People = <any> 'people',
        Phone = <any> 'phone',
        Set = <any> 'set',
        Text = <any> 'text',
        Time = <any> 'time',
        Timerange = <any> 'timerange',
        User = <any> 'user',
        Varchar = <any> 'varchar',
        VarcharAuto = <any> 'varchar_auto',
        VisibleTo = <any> 'visible_to'
    }
}
/**
 * 
 * @export
 * @interface CreateFieldRequest2
 */
export interface CreateFieldRequest2 {
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item's visibility setting</td></tr></table>
     * @type {string}
     * @memberof CreateFieldRequest2
     */
    field_type: CreateFieldRequest2.FieldTypeEnum;
}

/**
 * @export
 * @namespace CreateFieldRequest2
 */
export namespace CreateFieldRequest2 {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldTypeEnum {
        Address = <any> 'address',
        Date = <any> 'date',
        Daterange = <any> 'daterange',
        Double = <any> 'double',
        Enum = <any> 'enum',
        Monetary = <any> 'monetary',
        Org = <any> 'org',
        People = <any> 'people',
        Phone = <any> 'phone',
        Set = <any> 'set',
        Text = <any> 'text',
        Time = <any> 'time',
        Timerange = <any> 'timerange',
        User = <any> 'user',
        Varchar = <any> 'varchar',
        VarcharAuto = <any> 'varchar_auto',
        VisibleTo = <any> 'visible_to'
    }
}
/**
 * 
 * @export
 * @interface CreateUpdateDeleteActivityTypeResponse200
 */
export interface CreateUpdateDeleteActivityTypeResponse200 {
    /**
     * 
     * @type {GetActivityTypesResponse200Data}
     * @memberof CreateUpdateDeleteActivityTypeResponse200
     */
    data?: GetActivityTypesResponse200Data;
}
/**
 * 
 * @export
 * @interface DealResponse200
 */
export interface DealResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DealResponse200
     */
    success?: boolean;
    /**
     * The deal object
     * @type {any}
     * @memberof DealResponse200
     */
    data?: any;
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjects}
     * @memberof DealResponse200
     */
    related_objects?: AddDealParticipantResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface DeleteActivitiesResponse200
 */
export interface DeleteActivitiesResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteActivitiesResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteActivitiesResponse200Data}
     * @memberof DeleteActivitiesResponse200
     */
    data?: DeleteActivitiesResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteActivitiesResponse200Data
 */
export interface DeleteActivitiesResponse200Data {
    /**
     * An array of the IDs of activities that were deleted
     * @type {Array<number>}
     * @memberof DeleteActivitiesResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteActivityResponse200
 */
export interface DeleteActivityResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteActivityResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteActivityResponse200Data}
     * @memberof DeleteActivityResponse200
     */
    data?: DeleteActivityResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteActivityResponse200Data
 */
export interface DeleteActivityResponse200Data {
    /**
     * The ID of the activity that was deleted
     * @type {number}
     * @memberof DeleteActivityResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteActivityTypesResponse200
 */
export interface DeleteActivityTypesResponse200 {
    /**
     * 
     * @type {DeleteActivityTypesResponse200Data}
     * @memberof DeleteActivityTypesResponse200
     */
    data?: DeleteActivityTypesResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteActivityTypesResponse200Data
 */
export interface DeleteActivityTypesResponse200Data {
    /**
     * The IDs of the deleted activity types
     * @type {Array<number>}
     * @memberof DeleteActivityTypesResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteCallLogResponse200
 */
export interface DeleteCallLogResponse200 {
}
/**
 * 
 * @export
 * @interface DeleteCommentResponse200
 */
export interface DeleteCommentResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteCommentResponse200
     */
    success?: boolean;
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteCommentResponse200
     */
    data?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteDealFollowerResponse200
 */
export interface DeleteDealFollowerResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealFollowerResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteDealFollowerResponse200Data}
     * @memberof DeleteDealFollowerResponse200
     */
    data?: DeleteDealFollowerResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteDealFollowerResponse200Data
 */
export interface DeleteDealFollowerResponse200Data {
    /**
     * The ID of the deal follower that was deleted
     * @type {number}
     * @memberof DeleteDealFollowerResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteDealParticipantResponse200
 */
export interface DeleteDealParticipantResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealParticipantResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteDealParticipantResponse200Data}
     * @memberof DeleteDealParticipantResponse200
     */
    data?: DeleteDealParticipantResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteDealParticipantResponse200Data
 */
export interface DeleteDealParticipantResponse200Data {
    /**
     * The ID of the deal participant that was deleted
     * @type {number}
     * @memberof DeleteDealParticipantResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteDealProductResponse200
 */
export interface DeleteDealProductResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealProductResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteDealProductResponse200Data}
     * @memberof DeleteDealProductResponse200
     */
    data?: DeleteDealProductResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteDealProductResponse200Data
 */
export interface DeleteDealProductResponse200Data {
    /**
     * The ID of an attached product that was deleted from the deal
     * @type {number}
     * @memberof DeleteDealProductResponse200Data
     */
    id?: number;
    /**
     * The ID of an attached product that was deleted from the deal
     * @type {number}
     * @memberof DeleteDealProductResponse200Data
     */
    product_attachment_id?: number;
}
/**
 * 
 * @export
 * @interface DeleteDealResponse200
 */
export interface DeleteDealResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteDealResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteDealResponse200Data}
     * @memberof DeleteDealResponse200
     */
    data?: DeleteDealResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteDealResponse200Data
 */
export interface DeleteDealResponse200Data {
    /**
     * The ID of the deal that was deleted
     * @type {number}
     * @memberof DeleteDealResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteDealsResponse200
 */
export interface DeleteDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteDealsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteDealsResponse200Data}
     * @memberof DeleteDealsResponse200
     */
    data?: DeleteDealsResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteDealsResponse200Data
 */
export interface DeleteDealsResponse200Data {
    /**
     * The list of deleted deals IDs
     * @type {Array<number>}
     * @memberof DeleteDealsResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteFieldResponse200
 */
export interface DeleteFieldResponse200 {
    /**
     * 
     * @type {DeleteFieldResponse200Data}
     * @memberof DeleteFieldResponse200
     */
    data?: DeleteFieldResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteFieldResponse200Data
 */
export interface DeleteFieldResponse200Data {
    /**
     * The ID of the field that was deleted
     * @type {number}
     * @memberof DeleteFieldResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteFieldsResponse200
 */
export interface DeleteFieldsResponse200 {
    /**
     * 
     * @type {DeleteFieldsResponse200Data}
     * @memberof DeleteFieldsResponse200
     */
    data?: DeleteFieldsResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteFieldsResponse200Data
 */
export interface DeleteFieldsResponse200Data {
    /**
     * The list of deleted field IDs
     * @type {Array<number>}
     * @memberof DeleteFieldsResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteFileResponse200
 */
export interface DeleteFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteFileResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteFileResponse200Data}
     * @memberof DeleteFileResponse200
     */
    data?: DeleteFileResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteFileResponse200Data
 */
export interface DeleteFileResponse200Data {
    /**
     * The ID of the file
     * @type {number}
     * @memberof DeleteFileResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteFilterResponse200
 */
export interface DeleteFilterResponse200 {
    /**
     * 
     * @type {DeleteFilterResponse200Data}
     * @memberof DeleteFilterResponse200
     */
    data?: DeleteFilterResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteFilterResponse200Data
 */
export interface DeleteFilterResponse200Data {
    /**
     * The ID of the deleted filter
     * @type {number}
     * @memberof DeleteFilterResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteFiltersResponse200
 */
export interface DeleteFiltersResponse200 {
    /**
     * 
     * @type {DeleteFiltersResponse200Data}
     * @memberof DeleteFiltersResponse200
     */
    data?: DeleteFiltersResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteFiltersResponse200Data
 */
export interface DeleteFiltersResponse200Data {
    /**
     * The array of the IDs of the deleted filter
     * @type {Array<number>}
     * @memberof DeleteFiltersResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteGoalResponse200
 */
export interface DeleteGoalResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteGoalResponse200
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteMailThreadResponse200
 */
export interface DeleteMailThreadResponse200 {
    /**
     * An array of mail threads
     * @type {Array<any>}
     * @memberof DeleteMailThreadResponse200
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface DeleteNoteResponse200
 */
export interface DeleteNoteResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteNoteResponse200
     */
    success?: boolean;
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteNoteResponse200
     */
    data?: boolean;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationFollowerResponse200
 */
export interface DeleteOrganizationFollowerResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteOrganizationFollowerResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteOrganizationFollowerResponse200Data}
     * @memberof DeleteOrganizationFollowerResponse200
     */
    data?: DeleteOrganizationFollowerResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationFollowerResponse200Data
 */
export interface DeleteOrganizationFollowerResponse200Data {
    /**
     * The ID of the follower that was deleted from the organization
     * @type {number}
     * @memberof DeleteOrganizationFollowerResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationRelationshipResponse200
 */
export interface DeleteOrganizationRelationshipResponse200 {
    /**
     * 
     * @type {DeleteOrganizationRelationshipResponse200Data}
     * @memberof DeleteOrganizationRelationshipResponse200
     */
    data?: DeleteOrganizationRelationshipResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationRelationshipResponse200Data
 */
export interface DeleteOrganizationRelationshipResponse200Data {
    /**
     * The ID of the deleted organization relationship
     * @type {number}
     * @memberof DeleteOrganizationRelationshipResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationResponse200
 */
export interface DeleteOrganizationResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteOrganizationResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteOrganizationResponse200Data}
     * @memberof DeleteOrganizationResponse200
     */
    data?: DeleteOrganizationResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationResponse200Data
 */
export interface DeleteOrganizationResponse200Data {
    /**
     * The ID of the organization that was deleted
     * @type {number}
     * @memberof DeleteOrganizationResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationsResponse200
 */
export interface DeleteOrganizationsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteOrganizationsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteOrganizationsResponse200Data}
     * @memberof DeleteOrganizationsResponse200
     */
    data?: DeleteOrganizationsResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteOrganizationsResponse200Data
 */
export interface DeleteOrganizationsResponse200Data {
    /**
     * The IDs of the organizations that were deleted
     * @type {Array<number>}
     * @memberof DeleteOrganizationsResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeletePersonResponse200
 */
export interface DeletePersonResponse200 {
    /**
     * 
     * @type {DeletePersonResponse200Data}
     * @memberof DeletePersonResponse200
     */
    data?: DeletePersonResponse200Data;
}
/**
 * 
 * @export
 * @interface DeletePersonResponse200Data
 */
export interface DeletePersonResponse200Data {
    /**
     * The ID of the deleted person
     * @type {number}
     * @memberof DeletePersonResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeletePersonsResponse200
 */
export interface DeletePersonsResponse200 {
    /**
     * 
     * @type {DeletePersonsResponse200Data}
     * @memberof DeletePersonsResponse200
     */
    data?: DeletePersonsResponse200Data;
}
/**
 * 
 * @export
 * @interface DeletePersonsResponse200Data
 */
export interface DeletePersonsResponse200Data {
    /**
     * The list of deleted persons IDs
     * @type {Array<number>}
     * @memberof DeletePersonsResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeletePipelineResponse200
 */
export interface DeletePipelineResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeletePipelineResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeletePipelineResponse200Data}
     * @memberof DeletePipelineResponse200
     */
    data?: DeletePipelineResponse200Data;
}
/**
 * 
 * @export
 * @interface DeletePipelineResponse200Data
 */
export interface DeletePipelineResponse200Data {
    /**
     * Deleted Pipeline ID
     * @type {number}
     * @memberof DeletePipelineResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteProductFieldResponse200
 */
export interface DeleteProductFieldResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductFieldResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteProductFieldResponse200Data}
     * @memberof DeleteProductFieldResponse200
     */
    data?: DeleteProductFieldResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteProductFieldResponse200Data
 */
export interface DeleteProductFieldResponse200Data {
    /**
     * The ID of the deleted product field
     * @type {number}
     * @memberof DeleteProductFieldResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteProductFieldsResponse200
 */
export interface DeleteProductFieldsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductFieldsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteProductFieldsResponse200Data}
     * @memberof DeleteProductFieldsResponse200
     */
    data?: DeleteProductFieldsResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteProductFieldsResponse200Data
 */
export interface DeleteProductFieldsResponse200Data {
    /**
     * Array of all the IDs of the deleted product fields
     * @type {Array<number>}
     * @memberof DeleteProductFieldsResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteProductFollowerResponse200
 */
export interface DeleteProductFollowerResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductFollowerResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteProductFollowerResponse200Data}
     * @memberof DeleteProductFollowerResponse200
     */
    data?: DeleteProductFollowerResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteProductFollowerResponse200Data
 */
export interface DeleteProductFollowerResponse200Data {
    /**
     * The ID of the removed follower
     * @type {number}
     * @memberof DeleteProductFollowerResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteProductResponse200
 */
export interface DeleteProductResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DeleteProductResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteProductResponse200Data}
     * @memberof DeleteProductResponse200
     */
    data?: DeleteProductResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteProductResponse200Data
 */
export interface DeleteProductResponse200Data {
    /**
     * The ID of the removed product
     * @type {number}
     * @memberof DeleteProductResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteRoleAssignmentRequest
 */
export interface DeleteRoleAssignmentRequest {
    /**
     * The ID of the user
     * @type {number}
     * @memberof DeleteRoleAssignmentRequest
     */
    user_id: number;
}
/**
 * 
 * @export
 * @interface DeleteRoleAssignmentResponse200
 */
export interface DeleteRoleAssignmentResponse200 {
    /**
     * 
     * @type {DeleteRoleAssignmentResponse200Data}
     * @memberof DeleteRoleAssignmentResponse200
     */
    data?: DeleteRoleAssignmentResponse200Data;
}
/**
 * The response data
 * @export
 * @interface DeleteRoleAssignmentResponse200Data
 */
export interface DeleteRoleAssignmentResponse200Data {
    /**
     * The ID of the role the user was removed from
     * @type {number}
     * @memberof DeleteRoleAssignmentResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteRoleResponse200
 */
export interface DeleteRoleResponse200 {
    /**
     * 
     * @type {DeleteRoleResponse200Data}
     * @memberof DeleteRoleResponse200
     */
    data?: DeleteRoleResponse200Data;
}
/**
 * The response data
 * @export
 * @interface DeleteRoleResponse200Data
 */
export interface DeleteRoleResponse200Data {
    /**
     * The ID of the deleted role
     * @type {number}
     * @memberof DeleteRoleResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteStageResponse200
 */
export interface DeleteStageResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteStageResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteStageResponse200Data}
     * @memberof DeleteStageResponse200
     */
    data?: DeleteStageResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteStageResponse200Data
 */
export interface DeleteStageResponse200Data {
    /**
     * Deleted stage ID
     * @type {number}
     * @memberof DeleteStageResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface DeleteStagesResponse200
 */
export interface DeleteStagesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof DeleteStagesResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {DeleteStagesResponse200Data}
     * @memberof DeleteStagesResponse200
     */
    data?: DeleteStagesResponse200Data;
}
/**
 * 
 * @export
 * @interface DeleteStagesResponse200Data
 */
export interface DeleteStagesResponse200Data {
    /**
     * The list of deleted stage IDs
     * @type {Array<number>}
     * @memberof DeleteStagesResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface DeleteTeamUserRequest
 */
export interface DeleteTeamUserRequest {
    /**
     * The list of user IDs
     * @type {Array<number>}
     * @memberof DeleteTeamUserRequest
     */
    users: Array<number>;
}
/**
 * 
 * @export
 * @interface DuplicateDealResponse200
 */
export interface DuplicateDealResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof DuplicateDealResponse200
     */
    success?: boolean;
    /**
     * The deal object
     * @type {any}
     * @memberof DuplicateDealResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface FailResponse
 */
export interface FailResponse {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof FailResponse
     */
    success?: boolean;
    /**
     * The error message
     * @type {string}
     * @memberof FailResponse
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface FieldResponse200
 */
export interface FieldResponse200 {
    /**
     * 
     * @type {FieldsResponse200Data}
     * @memberof FieldResponse200
     */
    data?: FieldsResponse200Data;
}
/**
 * 
 * @export
 * @interface FieldsResponse200
 */
export interface FieldsResponse200 {
    /**
     * 
     * @type {Array<FieldsResponse200Data>}
     * @memberof FieldsResponse200
     */
    data?: Array<FieldsResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof FieldsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface FieldsResponse200Data
 */
export interface FieldsResponse200Data {
    /**
     * The ID of the field. Value is `null` in case of subfields.
     * @type {number}
     * @memberof FieldsResponse200Data
     */
    id?: number;
    /**
     * The key of the field. For custom fields this is generated upon creation.
     * @type {string}
     * @memberof FieldsResponse200Data
     */
    key?: string;
    /**
     * The name of the field
     * @type {string}
     * @memberof FieldsResponse200Data
     */
    name?: string;
    /**
     * The order number of the field
     * @type {number}
     * @memberof FieldsResponse200Data
     */
    order_nr?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldsResponse200Data
     */
    field_type?: string;
    /**
     * The creation time of the field
     * @type {string}
     * @memberof FieldsResponse200Data
     */
    add_time?: string;
    /**
     * The update time of the field
     * @type {string}
     * @memberof FieldsResponse200Data
     */
    update_time?: string;
    /**
     * The ID of the user who created or most recently updated the field, only applicable for custom fields
     * @type {number}
     * @memberof FieldsResponse200Data
     */
    last_updated_by_user_id?: number;
    /**
     * The active flag of the field
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    active_flag?: boolean;
    /**
     * The edit flag of the field
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    edit_flag?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    index_visible_flag?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    details_visible_flag?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    add_visible_flag?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    important_flag?: boolean;
    /**
     * Whether or not the field of an item can be edited in bulk
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    bulk_edit_allowed?: boolean;
    /**
     * Whether or not items can be searched by this field
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    searchable_flag?: boolean;
    /**
     * Whether or not items can be filtered by this field
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    filtering_allowed?: boolean;
    /**
     * Whether or not items can be sorted by this field
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    sortable_flag?: boolean;
    /**
     * Whether or not the field is mandatory
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    mandatory_flag?: boolean;
    /**
     * The options of the field. When there are no options, `null` is returned.
     * @type {Array<any>}
     * @memberof FieldsResponse200Data
     */
    options?: Array<any>;
    /**
     * The deleted options of the field. Only present when there is at least 1 deleted option.
     * @type {Array<any>}
     * @memberof FieldsResponse200Data
     */
    options_deleted?: Array<any>;
    /**
     * Whether or not the field is a subfield of another field. Only present if field is subfield.
     * @type {boolean}
     * @memberof FieldsResponse200Data
     */
    is_subfield?: boolean;
    /**
     * The subfields of the field. Only present when the field has subfields.
     * @type {Array<any>}
     * @memberof FieldsResponse200Data
     */
    subfields?: Array<any>;
}
/**
 * 
 * @export
 * @interface GetActivitiesResponse200
 */
export interface GetActivitiesResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetActivitiesResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof GetActivitiesResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof GetActivitiesResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjects}
     * @memberof GetActivitiesResponse200
     */
    related_objects?: UpdateProductResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetActivityResponse200
 */
export interface GetActivityResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetActivityResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof GetActivityResponse200
     */
    data?: any;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjects}
     * @memberof GetActivityResponse200
     */
    related_objects?: UpdateProductResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetActivityTypesResponse200
 */
export interface GetActivityTypesResponse200 {
    /**
     * The array of activity types
     * @type {Array<GetActivityTypesResponse200Data>}
     * @memberof GetActivityTypesResponse200
     */
    data?: Array<GetActivityTypesResponse200Data>;
}
/**
 * 
 * @export
 * @interface GetActivityTypesResponse200Data
 */
export interface GetActivityTypesResponse200Data {
    /**
     * The ID of the activity type
     * @type {number}
     * @memberof GetActivityTypesResponse200Data
     */
    id?: number;
    /**
     * The name of the activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200Data
     */
    name?: string;
    /**
     * Icon graphic to use for representing this activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200Data
     */
    icon_key?: GetActivityTypesResponse200Data.IconKeyEnum;
    /**
     * A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
     * @type {string}
     * @memberof GetActivityTypesResponse200Data
     */
    color?: string;
    /**
     * An order number for the activity type. Order numbers should be used to order the types in the activity type selections.
     * @type {number}
     * @memberof GetActivityTypesResponse200Data
     */
    order_nr?: number;
    /**
     * A string that is generated by the API based on the given name of the activity type upon creation
     * @type {string}
     * @memberof GetActivityTypesResponse200Data
     */
    key_string?: string;
    /**
     * The active flag of the activity type
     * @type {boolean}
     * @memberof GetActivityTypesResponse200Data
     */
    active_flag?: boolean;
    /**
     * Whether the activity type is a custom one or not
     * @type {boolean}
     * @memberof GetActivityTypesResponse200Data
     */
    is_custom_flag?: boolean;
    /**
     * The creation time of the activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200Data
     */
    add_time?: string;
    /**
     * The update time of the activity type
     * @type {string}
     * @memberof GetActivityTypesResponse200Data
     */
    update_time?: string;
}

/**
 * @export
 * @namespace GetActivityTypesResponse200Data
 */
export namespace GetActivityTypesResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum IconKeyEnum {
        Task = <any> 'task',
        Email = <any> 'email',
        Meeting = <any> 'meeting',
        Deadline = <any> 'deadline',
        Call = <any> 'call',
        Lunch = <any> 'lunch',
        Calendar = <any> 'calendar',
        Downarrow = <any> 'downarrow',
        Document = <any> 'document',
        Smartphone = <any> 'smartphone',
        Camera = <any> 'camera',
        Scissors = <any> 'scissors',
        Cogs = <any> 'cogs',
        Bubble = <any> 'bubble',
        Uparrow = <any> 'uparrow',
        Checkbox = <any> 'checkbox',
        Signpost = <any> 'signpost',
        Shuffle = <any> 'shuffle',
        Addressbook = <any> 'addressbook',
        Linegraph = <any> 'linegraph',
        Picture = <any> 'picture',
        Car = <any> 'car',
        World = <any> 'world',
        Search = <any> 'search',
        Clip = <any> 'clip',
        Sound = <any> 'sound',
        Brush = <any> 'brush',
        Key = <any> 'key',
        Padlock = <any> 'padlock',
        Pricetag = <any> 'pricetag',
        Suitcase = <any> 'suitcase',
        Finish = <any> 'finish',
        Plane = <any> 'plane',
        Loop = <any> 'loop',
        Wifi = <any> 'wifi',
        Truck = <any> 'truck',
        Cart = <any> 'cart',
        Bulb = <any> 'bulb',
        Bell = <any> 'bell',
        Presentation = <any> 'presentation'
    }
}
/**
 * 
 * @export
 * @interface GetAddProductAttachementResponse200
 */
export interface GetAddProductAttachementResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetAddProductAttachementResponse200
     */
    success?: boolean;
    /**
     * The added product object attached to the deal
     * @type {any}
     * @memberof GetAddProductAttachementResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetAllMailMessagesOfMailThreadResponse200
 */
export interface GetAllMailMessagesOfMailThreadResponse200 {
    /**
     * The array of the mail messages of the mail thread
     * @type {Array<any>}
     * @memberof GetAllMailMessagesOfMailThreadResponse200
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface GetAssociatedActivitiesResponse200
 */
export interface GetAssociatedActivitiesResponse200 {
    /**
     * The array of activities
     * @type {Array<any>}
     * @memberof GetAssociatedActivitiesResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {any}
     * @memberof GetAssociatedActivitiesResponse200
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface GetAssociatedDealsResponse200
 */
export interface GetAssociatedDealsResponse200 {
    /**
     * The array of deals
     * @type {Array<any>}
     * @memberof GetAssociatedDealsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetAssociatedDealsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {GetAssociatedDealsResponse200RelatedObjects}
     * @memberof GetAssociatedDealsResponse200
     */
    related_objects?: GetAssociatedDealsResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetAssociatedDealsResponse200RelatedObjects
 */
export interface GetAssociatedDealsResponse200RelatedObjects {
    /**
     * 
     * @type {ListPersonsResponse200RelatedObjectsOrganization}
     * @memberof GetAssociatedDealsResponse200RelatedObjects
     */
    organization?: ListPersonsResponse200RelatedObjectsOrganization;
    /**
     * 
     * @type {GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson}
     * @memberof GetAssociatedDealsResponse200RelatedObjects
     */
    person?: GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof GetAssociatedDealsResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
}
/**
 * 
 * @export
 * @interface GetAssociatedFilesResponse200
 */
export interface GetAssociatedFilesResponse200 {
    /**
     * The array of files
     * @type {Array<GetAssociatedFilesResponse200Data>}
     * @memberof GetAssociatedFilesResponse200
     */
    data?: Array<GetAssociatedFilesResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetAssociatedFilesResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * The file data
 * @export
 * @interface GetAssociatedFilesResponse200Data
 */
export interface GetAssociatedFilesResponse200Data {
    /**
     * The ID of the file
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    id?: number;
    /**
     * The ID of the user to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the deal to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    deal_id?: number;
    /**
     * The ID of the person to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    person_id?: number;
    /**
     * The ID of the organization to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    org_id?: number;
    /**
     * The ID of the product to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    product_id?: number;
    /**
     * The ID of the activity to associate the file with
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    activity_id?: number;
    /**
     * The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    add_time?: string;
    /**
     * The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    update_time?: string;
    /**
     * The original name of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    file_name?: string;
    /**
     * The size of the file
     * @type {number}
     * @memberof GetAssociatedFilesResponse200Data
     */
    file_size?: number;
    /**
     * Whether the user is active or not. false = Not activated, true = Activated
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse200Data
     */
    active_flag?: boolean;
    /**
     * Whether the file was uploaded as inline or not
     * @type {boolean}
     * @memberof GetAssociatedFilesResponse200Data
     */
    inline_flag?: boolean;
    /**
     * The location type to send the file to. Only googledrive is supported at the moment.
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    remote_location?: string;
    /**
     * The ID of the remote item
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    remote_id?: string;
    /**
     * The ID of the inline attachment
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    cid?: string;
    /**
     * The location of the cloud storage
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    s3_bucket?: string;
    /**
     * The ID of the mail message to associate the file with
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    mail_message_id?: string;
    /**
     * The ID of the mail template to associate the file with
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    mail_template_id?: string;
    /**
     * The name of the deal associated with the dile
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    deal_name?: string;
    /**
     * The name of the person associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    person_name?: string;
    /**
     * The name of the organization associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    org_name?: string;
    /**
     * The name of the product associated with the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    product_name?: string;
    /**
     * The URL of the download file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    url?: string;
    /**
     * The visible name of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    name?: string;
    /**
     * The description of the file
     * @type {string}
     * @memberof GetAssociatedFilesResponse200Data
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface GetAssociatedFollowersResponse200
 */
export interface GetAssociatedFollowersResponse200 {
    /**
     * The list of followers
     * @type {Array<GetAssociatedFollowersResponse200Data>}
     * @memberof GetAssociatedFollowersResponse200
     */
    data?: Array<GetAssociatedFollowersResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetAssociatedFollowersResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetAssociatedFollowersResponse2001
 */
export interface GetAssociatedFollowersResponse2001 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetAssociatedFollowersResponse2001
     */
    success?: boolean;
    /**
     * The array of followers
     * @type {Array<any>}
     * @memberof GetAssociatedFollowersResponse2001
     */
    data?: Array<any>;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof GetAssociatedFollowersResponse2001
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetAssociatedFollowersResponse200Data
 */
export interface GetAssociatedFollowersResponse200Data {
    /**
     * The ID of the user
     * @type {number}
     * @memberof GetAssociatedFollowersResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the user follower
     * @type {number}
     * @memberof GetAssociatedFollowersResponse200Data
     */
    id?: number;
    /**
     * The ID of the person
     * @type {number}
     * @memberof GetAssociatedFollowersResponse200Data
     */
    person_id?: number;
    /**
     * The date and time when the follower was added to the person
     * @type {string}
     * @memberof GetAssociatedFollowersResponse200Data
     */
    add_time?: string;
}
/**
 * 
 * @export
 * @interface GetAssociatedMailMessagesResponse200
 */
export interface GetAssociatedMailMessagesResponse200 {
    /**
     * The array of mail messages
     * @type {Array<GetAssociatedMailMessagesResponse200Data>}
     * @memberof GetAssociatedMailMessagesResponse200
     */
    data?: Array<GetAssociatedMailMessagesResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetAssociatedMailMessagesResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetAssociatedMailMessagesResponse200Data
 */
export interface GetAssociatedMailMessagesResponse200Data {
    /**
     * The type of the data item
     * @type {string}
     * @memberof GetAssociatedMailMessagesResponse200Data
     */
    object?: string;
    /**
     * The date and time when the item was created
     * @type {string}
     * @memberof GetAssociatedMailMessagesResponse200Data
     */
    timestamp?: string;
    /**
     * 
     * @type {any}
     * @memberof GetAssociatedMailMessagesResponse200Data
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetAssociatedPersonUpdatesResponse200
 */
export interface GetAssociatedPersonUpdatesResponse200 {
    /**
     * 
     * @type {Array<GetAssociatedPersonUpdatesResponse200Data>}
     * @memberof GetAssociatedPersonUpdatesResponse200
     */
    data?: Array<GetAssociatedPersonUpdatesResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetAssociatedPersonUpdatesResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {GetAssociatedPersonUpdatesResponse200RelatedObjects}
     * @memberof GetAssociatedPersonUpdatesResponse200
     */
    related_objects?: GetAssociatedPersonUpdatesResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetAssociatedPersonUpdatesResponse200Data
 */
export interface GetAssociatedPersonUpdatesResponse200Data {
    /**
     * The type of the person update. (Possible object types - personChange, note, activity, file)
     * @type {string}
     * @memberof GetAssociatedPersonUpdatesResponse200Data
     */
    object?: string;
    /**
     * The creation date and time of the update
     * @type {string}
     * @memberof GetAssociatedPersonUpdatesResponse200Data
     */
    timestamp?: string;
    /**
     * The data related to the update
     * @type {any}
     * @memberof GetAssociatedPersonUpdatesResponse200Data
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetAssociatedPersonUpdatesResponse200RelatedObjects
 */
export interface GetAssociatedPersonUpdatesResponse200RelatedObjects {
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjectsDeal}
     * @memberof GetAssociatedPersonUpdatesResponse200RelatedObjects
     */
    deal?: UpdateProductResponse200RelatedObjectsDeal;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsOrganization}
     * @memberof GetAssociatedPersonUpdatesResponse200RelatedObjects
     */
    organization?: GetAssociatedUpdatesResponse200RelatedObjectsOrganization;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof GetAssociatedPersonUpdatesResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
    /**
     * 
     * @type {GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson}
     * @memberof GetAssociatedPersonUpdatesResponse200RelatedObjects
     */
    person?: GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson;
}
/**
 * 
 * @export
 * @interface GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson
 */
export interface GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson {
    /**
     * The ID of the person associated with the item
     * @type {any}
     * @memberof GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson
     */
    PERSON_ID?: any;
}
/**
 * 
 * @export
 * @interface GetAssociatedUpdatesResponse200
 */
export interface GetAssociatedUpdatesResponse200 {
    /**
     * 
     * @type {Array<GetAssociatedUpdatesResponse200Data>}
     * @memberof GetAssociatedUpdatesResponse200
     */
    data?: Array<GetAssociatedUpdatesResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetAssociatedUpdatesResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjects}
     * @memberof GetAssociatedUpdatesResponse200
     */
    related_objects?: GetAssociatedUpdatesResponse200RelatedObjects;
}
/**
 * The additional data of the list
 * @export
 * @interface GetAssociatedUpdatesResponse200AdditionalData
 */
export interface GetAssociatedUpdatesResponse200AdditionalData {
    /**
     * Pagination start
     * @type {number}
     * @memberof GetAssociatedUpdatesResponse200AdditionalData
     */
    start?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof GetAssociatedUpdatesResponse200AdditionalData
     */
    limit?: number;
    /**
     * If there are more list items in the collection than displayed or not
     * @type {boolean}
     * @memberof GetAssociatedUpdatesResponse200AdditionalData
     */
    more_items_in_collection?: boolean;
}
/**
 * 
 * @export
 * @interface GetAssociatedUpdatesResponse200Data
 */
export interface GetAssociatedUpdatesResponse200Data {
    /**
     * The type of the person update. (Possible object types - organizationChange, dealChange, file, activity)
     * @type {string}
     * @memberof GetAssociatedUpdatesResponse200Data
     */
    object?: string;
    /**
     * The creation date and time of the update
     * @type {string}
     * @memberof GetAssociatedUpdatesResponse200Data
     */
    timestamp?: string;
    /**
     * The data related to the update
     * @type {any}
     * @memberof GetAssociatedUpdatesResponse200Data
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetAssociatedUpdatesResponse200RelatedObjects
 */
export interface GetAssociatedUpdatesResponse200RelatedObjects {
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsOrganization}
     * @memberof GetAssociatedUpdatesResponse200RelatedObjects
     */
    organization?: GetAssociatedUpdatesResponse200RelatedObjectsOrganization;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof GetAssociatedUpdatesResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
}
/**
 * 
 * @export
 * @interface GetAssociatedUpdatesResponse200RelatedObjectsOrganization
 */
export interface GetAssociatedUpdatesResponse200RelatedObjectsOrganization {
    /**
     * The ID of the organization associated with the item
     * @type {any}
     * @memberof GetAssociatedUpdatesResponse200RelatedObjectsOrganization
     */
    ORGANIZATION_ID?: any;
}
/**
 * 
 * @export
 * @interface GetAssociatedUpdatesResponse200RelatedObjectsUser
 */
export interface GetAssociatedUpdatesResponse200RelatedObjectsUser {
    /**
     * 
     * @type {any}
     * @memberof GetAssociatedUpdatesResponse200RelatedObjectsUser
     */
    USER_ID?: any;
}
/**
 * 
 * @export
 * @interface GetCommentsResponse200
 */
export interface GetCommentsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetCommentsResponse200
     */
    success?: boolean;
    /**
     * The array of comments
     * @type {Array<GetCommentsResponse200Data>}
     * @memberof GetCommentsResponse200
     */
    data?: Array<GetCommentsResponse200Data>;
    /**
     * 
     * @type {GetCommentsResponse200AdditionalData}
     * @memberof GetCommentsResponse200
     */
    additional_data?: GetCommentsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetCommentsResponse200AdditionalData
 */
export interface GetCommentsResponse200AdditionalData {
    /**
     * The pagination details of the list
     * @type {any}
     * @memberof GetCommentsResponse200AdditionalData
     */
    pagination?: any;
}
/**
 * 
 * @export
 * @interface GetCommentsResponse200Data
 */
export interface GetCommentsResponse200Data {
    /**
     * The ID of the note
     * @type {string}
     * @memberof GetCommentsResponse200Data
     */
    uuid?: string;
    /**
     * Whether the note is active or deleted
     * @type {boolean}
     * @memberof GetCommentsResponse200Data
     */
    active_flag?: boolean;
    /**
     * The creation date and time of the note
     * @type {string}
     * @memberof GetCommentsResponse200Data
     */
    add_time?: string;
    /**
     * The creation date and time of the note
     * @type {string}
     * @memberof GetCommentsResponse200Data
     */
    update_time?: string;
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof GetCommentsResponse200Data
     */
    content?: string;
    /**
     * The ID of the object that the comment is attached to, will be the id of the note
     * @type {string}
     * @memberof GetCommentsResponse200Data
     */
    object_id?: string;
    /**
     * The type of object that the comment is attached to, will be \"note\"
     * @type {string}
     * @memberof GetCommentsResponse200Data
     */
    object_type?: string;
    /**
     * The ID of the user who created the comment
     * @type {number}
     * @memberof GetCommentsResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the user who last updated the comment
     * @type {number}
     * @memberof GetCommentsResponse200Data
     */
    updater_id?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetCommentsResponse200Data
     */
    company_id?: number;
}
/**
 * 
 * @export
 * @interface GetCurrenciesResponse200
 */
export interface GetCurrenciesResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetCurrenciesResponse200
     */
    success?: boolean;
    /**
     * The array of currencies
     * @type {Array<GetCurrenciesResponse200Data>}
     * @memberof GetCurrenciesResponse200
     */
    data?: Array<GetCurrenciesResponse200Data>;
}
/**
 * 
 * @export
 * @interface GetCurrenciesResponse200Data
 */
export interface GetCurrenciesResponse200Data {
    /**
     * The ID of the currency
     * @type {number}
     * @memberof GetCurrenciesResponse200Data
     */
    id?: number;
    /**
     * The code of the currency
     * @type {string}
     * @memberof GetCurrenciesResponse200Data
     */
    code?: string;
    /**
     * The name of the currency
     * @type {string}
     * @memberof GetCurrenciesResponse200Data
     */
    name?: string;
    /**
     * The amount of decimal points of the currency
     * @type {number}
     * @memberof GetCurrenciesResponse200Data
     */
    decimal_points?: number;
    /**
     * The symbol of the currency
     * @type {string}
     * @memberof GetCurrenciesResponse200Data
     */
    symbol?: string;
    /**
     * Whether the currency is active or not
     * @type {boolean}
     * @memberof GetCurrenciesResponse200Data
     */
    active_flag?: boolean;
    /**
     * Whether the currency is a custom one or not
     * @type {boolean}
     * @memberof GetCurrenciesResponse200Data
     */
    is_custom_flag?: boolean;
}
/**
 * 
 * @export
 * @interface GetCurrentUserResponse200
 */
export interface GetCurrentUserResponse200 {
    /**
     * 
     * @type {any}
     * @memberof GetCurrentUserResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetDealActivitiesResponse200
 */
export interface GetDealActivitiesResponse200 {
    /**
     * The array of activities
     * @type {Array<any>}
     * @memberof GetDealActivitiesResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {any}
     * @memberof GetDealActivitiesResponse200
     */
    additional_data?: any;
    /**
     * 
     * @type {GetDealActivitiesResponse200RelatedObjects}
     * @memberof GetDealActivitiesResponse200
     */
    related_objects?: GetDealActivitiesResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetDealActivitiesResponse200RelatedObjects
 */
export interface GetDealActivitiesResponse200RelatedObjects {
    /**
     * 
     * @type {ListPersonsResponse200RelatedObjectsOrganization}
     * @memberof GetDealActivitiesResponse200RelatedObjects
     */
    organization?: ListPersonsResponse200RelatedObjectsOrganization;
    /**
     * 
     * @type {GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson}
     * @memberof GetDealActivitiesResponse200RelatedObjects
     */
    person?: GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjectsDeal}
     * @memberof GetDealActivitiesResponse200RelatedObjects
     */
    deal?: UpdateProductResponse200RelatedObjectsDeal;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof GetDealActivitiesResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
}
/**
 * 
 * @export
 * @interface GetDealParticipantsResponse200
 */
export interface GetDealParticipantsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetDealParticipantsResponse200
     */
    success?: boolean;
    /**
     * The array of participants
     * @type {Array<any>}
     * @memberof GetDealParticipantsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetDealParticipantsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjects}
     * @memberof GetDealParticipantsResponse200
     */
    related_objects?: AddDealParticipantResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetDealResponse200
 */
export interface GetDealResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof GetDealResponse200
     */
    data?: any;
    /**
     * 
     * @type {GetDealResponse200AdditionalData}
     * @memberof GetDealResponse200
     */
    additional_data?: GetDealResponse200AdditionalData;
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjects}
     * @memberof GetDealResponse200
     */
    related_objects?: AddDealParticipantResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetDealResponse200AdditionalData
 */
export interface GetDealResponse200AdditionalData {
    /**
     * The BCC email of the deal
     * @type {string}
     * @memberof GetDealResponse200AdditionalData
     */
    dropbox_email?: string;
}
/**
 * 
 * @export
 * @interface GetDealUpdatesResponse200
 */
export interface GetDealUpdatesResponse200 {
    /**
     * 
     * @type {Array<GetDealUpdatesResponse200Data>}
     * @memberof GetDealUpdatesResponse200
     */
    data?: Array<GetDealUpdatesResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetDealUpdatesResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {GetAssociatedPersonUpdatesResponse200RelatedObjects}
     * @memberof GetDealUpdatesResponse200
     */
    related_objects?: GetAssociatedPersonUpdatesResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetDealUpdatesResponse200Data
 */
export interface GetDealUpdatesResponse200Data {
    /**
     * The type of the deal update. (Possible object types - dealChange, note, activity, mailMessage, invoice, document, file)
     * @type {string}
     * @memberof GetDealUpdatesResponse200Data
     */
    object?: string;
    /**
     * The creation date and time of the update
     * @type {string}
     * @memberof GetDealUpdatesResponse200Data
     */
    timestamp?: string;
    /**
     * The data related to the update
     * @type {any}
     * @memberof GetDealUpdatesResponse200Data
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetDealsResponse200
 */
export interface GetDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealsResponse200
     */
    success?: boolean;
    /**
     * The array of deals
     * @type {Array<any>}
     * @memberof GetDealsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetDealsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {AddDealParticipantResponse200RelatedObjects}
     * @memberof GetDealsResponse200
     */
    related_objects?: AddDealParticipantResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetDealsSummaryResponse200
 */
export interface GetDealsSummaryResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealsSummaryResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {GetDealsSummaryResponse200Data}
     * @memberof GetDealsSummaryResponse200
     */
    data?: GetDealsSummaryResponse200Data;
}
/**
 * The summary of deals
 * @export
 * @interface GetDealsSummaryResponse200Data
 */
export interface GetDealsSummaryResponse200Data {
    /**
     * 
     * @type {GetDealsSummaryResponse200DataValuesTotal}
     * @memberof GetDealsSummaryResponse200Data
     */
    values_total?: GetDealsSummaryResponse200DataValuesTotal;
    /**
     * 
     * @type {GetDealsSummaryResponse200DataWeightedValuesTotal}
     * @memberof GetDealsSummaryResponse200Data
     */
    weighted_values_total?: GetDealsSummaryResponse200DataWeightedValuesTotal;
    /**
     * The total number of deals
     * @type {number}
     * @memberof GetDealsSummaryResponse200Data
     */
    total_count?: number;
    /**
     * The total value of deals converted into the company default currency
     * @type {number}
     * @memberof GetDealsSummaryResponse200Data
     */
    total_currency_converted_value?: number;
    /**
     * The total weighted value of deals converted into the company default currency
     * @type {number}
     * @memberof GetDealsSummaryResponse200Data
     */
    total_weighted_currency_converted_value?: number;
    /**
     * The total converted value of deals formatted with the company default currency. E.g. US$5,100.96
     * @type {string}
     * @memberof GetDealsSummaryResponse200Data
     */
    total_currency_converted_value_formatted?: string;
    /**
     * The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96
     * @type {string}
     * @memberof GetDealsSummaryResponse200Data
     */
    total_weighted_currency_converted_value_formatted?: string;
}
/**
 * The total values of the deals grouped by deal currency
 * @export
 * @interface GetDealsSummaryResponse200DataValuesTotal
 */
export interface GetDealsSummaryResponse200DataValuesTotal {
    /**
     * The total value of deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    value?: number;
    /**
     * The number of deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    count?: number;
    /**
     * The total value of deals converted into the company default currency
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    value_converted?: number;
    /**
     * The total value of deals formatted with deal currency. E.g. 50
     * @type {string}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    value_formatted?: string;
    /**
     * The value_converted formatted with deal currency. E.g. US$50.10
     * @type {string}
     * @memberof GetDealsSummaryResponse200DataValuesTotal
     */
    value_converted_formatted?: string;
}
/**
 * The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.
 * @export
 * @interface GetDealsSummaryResponse200DataWeightedValuesTotal
 */
export interface GetDealsSummaryResponse200DataWeightedValuesTotal {
    /**
     * The total weighted value of the deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataWeightedValuesTotal
     */
    value?: number;
    /**
     * The number of deals in the deal currency group
     * @type {number}
     * @memberof GetDealsSummaryResponse200DataWeightedValuesTotal
     */
    count?: number;
    /**
     * The total weighted value of the deals formatted with deal currency. E.g. 50
     * @type {string}
     * @memberof GetDealsSummaryResponse200DataWeightedValuesTotal
     */
    value_formatted?: string;
}
/**
 * 
 * @export
 * @interface GetDealsTimelineResponse200
 */
export interface GetDealsTimelineResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetDealsTimelineResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {GetDealsTimelineResponse200Data}
     * @memberof GetDealsTimelineResponse200
     */
    data?: GetDealsTimelineResponse200Data;
}
/**
 * Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)
 * @export
 * @interface GetDealsTimelineResponse200Data
 */
export interface GetDealsTimelineResponse200Data {
    /**
     * The start date and time of the period
     * @type {string}
     * @memberof GetDealsTimelineResponse200Data
     */
    period_start?: string;
    /**
     * The end date and time of the period
     * @type {string}
     * @memberof GetDealsTimelineResponse200Data
     */
    period_end?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof GetDealsTimelineResponse200Data
     */
    deals?: Array<any>;
    /**
     * 
     * @type {GetDealsTimelineResponse200DataTotals}
     * @memberof GetDealsTimelineResponse200Data
     */
    totals?: GetDealsTimelineResponse200DataTotals;
}
/**
 * The total values of deals for the given period
 * @export
 * @interface GetDealsTimelineResponse200DataTotals
 */
export interface GetDealsTimelineResponse200DataTotals {
    /**
     * The number of deals for the given period
     * @type {number}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    count?: number;
    /**
     * The total values of deals grouped by deal currency
     * @type {any}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    values?: any;
    /**
     * The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
     * @type {any}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    weighted_values?: any;
    /**
     * The number of open deals for the given period
     * @type {number}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    open_count?: number;
    /**
     * The total values of open deals for the given period grouped by deal currency
     * @type {any}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    open_values?: any;
    /**
     * The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value.
     * @type {any}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    weighted_open_values?: any;
    /**
     * The number of won deals for the given period
     * @type {number}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    won_count?: number;
    /**
     * The total values of won deals for the given period grouped by deal currency
     * @type {any}
     * @memberof GetDealsTimelineResponse200DataTotals
     */
    won_values?: any;
}
/**
 * 
 * @export
 * @interface GetFileResponse200
 */
export interface GetFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetFileResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {LinkFileToItemResponse200Data}
     * @memberof GetFileResponse200
     */
    data?: LinkFileToItemResponse200Data;
}
/**
 * 
 * @export
 * @interface GetFilesResponse200
 */
export interface GetFilesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetFilesResponse200
     */
    success?: boolean;
    /**
     * The array of all uploaded files
     * @type {Array<LinkFileToItemResponse200Data>}
     * @memberof GetFilesResponse200
     */
    data?: Array<LinkFileToItemResponse200Data>;
    /**
     * 
     * @type {GetFilesResponse200AdditionalData}
     * @memberof GetFilesResponse200
     */
    additional_data?: GetFilesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetFilesResponse200AdditionalData
 */
export interface GetFilesResponse200AdditionalData {
    /**
     * Pagination details of the list
     * @type {any}
     * @memberof GetFilesResponse200AdditionalData
     */
    pagination?: any;
}
/**
 * 
 * @export
 * @interface GetFilterResponse200
 */
export interface GetFilterResponse200 {
    /**
     * 
     * @type {GetFiltersResponse200Data}
     * @memberof GetFilterResponse200
     */
    data?: GetFiltersResponse200Data;
}
/**
 * 
 * @export
 * @interface GetFiltersResponse200
 */
export interface GetFiltersResponse200 {
    /**
     * The array of filters
     * @type {Array<GetFiltersResponse200Data>}
     * @memberof GetFiltersResponse200
     */
    data?: Array<GetFiltersResponse200Data>;
}
/**
 * The filter object
 * @export
 * @interface GetFiltersResponse200Data
 */
export interface GetFiltersResponse200Data {
    /**
     * The ID of the filter
     * @type {number}
     * @memberof GetFiltersResponse200Data
     */
    id?: number;
    /**
     * The name of the filter
     * @type {string}
     * @memberof GetFiltersResponse200Data
     */
    name?: string;
    /**
     * The active flag of the filter
     * @type {boolean}
     * @memberof GetFiltersResponse200Data
     */
    active_flag?: boolean;
    /**
     * The type of the item
     * @type {string}
     * @memberof GetFiltersResponse200Data
     */
    type?: string;
    /**
     * The owner of the filter
     * @type {number}
     * @memberof GetFiltersResponse200Data
     */
    user_id?: number;
    /**
     * The date and time when the filter was added
     * @type {string}
     * @memberof GetFiltersResponse200Data
     */
    add_time?: string;
    /**
     * The date and time when the filter was updated
     * @type {string}
     * @memberof GetFiltersResponse200Data
     */
    update_time?: string;
    /**
     * The visibility group ID of who can see then filter
     * @type {number}
     * @memberof GetFiltersResponse200Data
     */
    visible_to?: number;
    /**
     * Used by Pipedrive webapp
     * @type {number}
     * @memberof GetFiltersResponse200Data
     */
    custom_view_id?: number;
}
/**
 * 
 * @export
 * @interface GetGoalResultResponse200
 */
export interface GetGoalResultResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetGoalResultResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {GetGoalResultResponse200Data}
     * @memberof GetGoalResultResponse200
     */
    data?: GetGoalResultResponse200Data;
}
/**
 * 
 * @export
 * @interface GetGoalResultResponse200Data
 */
export interface GetGoalResultResponse200Data {
    /**
     * The numeric progress of the goal
     * @type {number}
     * @memberof GetGoalResultResponse200Data
     */
    progress?: number;
    /**
     * 
     * @type {GetGoalsResponse200DataGoals}
     * @memberof GetGoalResultResponse200Data
     */
    goal?: GetGoalsResponse200DataGoals;
}
/**
 * 
 * @export
 * @interface GetGoalsResponse200
 */
export interface GetGoalsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetGoalsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {GetGoalsResponse200Data}
     * @memberof GetGoalsResponse200
     */
    data?: GetGoalsResponse200Data;
}
/**
 * 
 * @export
 * @interface GetGoalsResponse200Data
 */
export interface GetGoalsResponse200Data {
    /**
     * 
     * @type {Array<GetGoalsResponse200DataGoals>}
     * @memberof GetGoalsResponse200Data
     */
    goals?: Array<GetGoalsResponse200DataGoals>;
}
/**
 * Who the goal is assigned to
 * @export
 * @interface GetGoalsResponse200DataAssignee
 */
export interface GetGoalsResponse200DataAssignee {
    /**
     * The ID of the goal assignee
     * @type {number}
     * @memberof GetGoalsResponse200DataAssignee
     */
    id?: number;
    /**
     * The type of the assignee
     * @type {string}
     * @memberof GetGoalsResponse200DataAssignee
     */
    type?: string;
}
/**
 * The duration of the goal
 * @export
 * @interface GetGoalsResponse200DataDuration
 */
export interface GetGoalsResponse200DataDuration {
    /**
     * The start date of the goal
     * @type {string}
     * @memberof GetGoalsResponse200DataDuration
     */
    start?: string;
    /**
     * The end date of the goal
     * @type {string}
     * @memberof GetGoalsResponse200DataDuration
     */
    end?: string;
}
/**
 * The expected outcome of the goal
 * @export
 * @interface GetGoalsResponse200DataExpectedOutcome
 */
export interface GetGoalsResponse200DataExpectedOutcome {
    /**
     * The numeric target of the goal
     * @type {number}
     * @memberof GetGoalsResponse200DataExpectedOutcome
     */
    target?: number;
    /**
     * The tracking metric of the goal
     * @type {string}
     * @memberof GetGoalsResponse200DataExpectedOutcome
     */
    tracking_metric?: string;
}
/**
 * 
 * @export
 * @interface GetGoalsResponse200DataGoals
 */
export interface GetGoalsResponse200DataGoals {
    /**
     * The ID of the goal
     * @type {string}
     * @memberof GetGoalsResponse200DataGoals
     */
    id?: string;
    /**
     * The ID of the creator of the goal
     * @type {number}
     * @memberof GetGoalsResponse200DataGoals
     */
    owner_id?: number;
    /**
     * The title of the goal
     * @type {string}
     * @memberof GetGoalsResponse200DataGoals
     */
    title?: string;
    /**
     * 
     * @type {GetGoalsResponse200DataType}
     * @memberof GetGoalsResponse200DataGoals
     */
    type?: GetGoalsResponse200DataType;
    /**
     * 
     * @type {GetGoalsResponse200DataAssignee}
     * @memberof GetGoalsResponse200DataGoals
     */
    assignee?: GetGoalsResponse200DataAssignee;
    /**
     * The interval of the goal
     * @type {string}
     * @memberof GetGoalsResponse200DataGoals
     */
    interval?: string;
    /**
     * 
     * @type {GetGoalsResponse200DataDuration}
     * @memberof GetGoalsResponse200DataGoals
     */
    duration?: GetGoalsResponse200DataDuration;
    /**
     * 
     * @type {GetGoalsResponse200DataExpectedOutcome}
     * @memberof GetGoalsResponse200DataGoals
     */
    expected_outcome?: GetGoalsResponse200DataExpectedOutcome;
    /**
     * Whether the goal is currently active or not
     * @type {boolean}
     * @memberof GetGoalsResponse200DataGoals
     */
    is_active?: boolean;
    /**
     * The IDs of the reports that belong to the goal
     * @type {Array<string>}
     * @memberof GetGoalsResponse200DataGoals
     */
    report_ids?: Array<string>;
}
/**
 * The type of the goal
 * @export
 * @interface GetGoalsResponse200DataType
 */
export interface GetGoalsResponse200DataType {
    /**
     * The name of the goal type
     * @type {string}
     * @memberof GetGoalsResponse200DataType
     */
    name?: string;
    /**
     * 
     * @type {GetGoalsResponse200DataTypeParams}
     * @memberof GetGoalsResponse200DataType
     */
    params?: GetGoalsResponse200DataTypeParams;
}
/**
 * The parameters that accompany the goal type
 * @export
 * @interface GetGoalsResponse200DataTypeParams
 */
export interface GetGoalsResponse200DataTypeParams {
    /**
     * The pipeline ID of the goal
     * @type {string}
     * @memberof GetGoalsResponse200DataTypeParams
     */
    pipeline_id?: string;
}
/**
 * 
 * @export
 * @interface GetLeadLabelsResponse200
 */
export interface GetLeadLabelsResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetLeadLabelsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {Array<GetLeadLabelsResponse200Data>}
     * @memberof GetLeadLabelsResponse200
     */
    data?: Array<GetLeadLabelsResponse200Data>;
}
/**
 * 
 * @export
 * @interface GetLeadLabelsResponse200Data
 */
export interface GetLeadLabelsResponse200Data {
    /**
     * The unique ID of the lead label
     * @type {string}
     * @memberof GetLeadLabelsResponse200Data
     */
    id?: string;
    /**
     * The name of the lead label
     * @type {string}
     * @memberof GetLeadLabelsResponse200Data
     */
    name?: string;
    /**
     * The color of the label. Only a subset of colors can be used.
     * @type {string}
     * @memberof GetLeadLabelsResponse200Data
     */
    color?: GetLeadLabelsResponse200Data.ColorEnum;
    /**
     * The date and time of when the lead label was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {Date}
     * @memberof GetLeadLabelsResponse200Data
     */
    add_time?: Date;
    /**
     * The date and time of when the lead label was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {Date}
     * @memberof GetLeadLabelsResponse200Data
     */
    update_time?: Date;
}

/**
 * @export
 * @namespace GetLeadLabelsResponse200Data
 */
export namespace GetLeadLabelsResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum ColorEnum {
        Green = <any> 'green',
        Blue = <any> 'blue',
        Red = <any> 'red',
        Yellow = <any> 'yellow',
        Purple = <any> 'purple',
        Gray = <any> 'gray'
    }
}
/**
 * 
 * @export
 * @interface GetLeadSourcesResponse200
 */
export interface GetLeadSourcesResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetLeadSourcesResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {Array<GetLeadSourcesResponse200Data>}
     * @memberof GetLeadSourcesResponse200
     */
    data?: Array<GetLeadSourcesResponse200Data>;
}
/**
 * 
 * @export
 * @interface GetLeadSourcesResponse200Data
 */
export interface GetLeadSourcesResponse200Data {
    /**
     * The unique name of a lead source
     * @type {string}
     * @memberof GetLeadSourcesResponse200Data
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GetLeadsResponse200
 */
export interface GetLeadsResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetLeadsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {Array<OneLeadResponse200Data>}
     * @memberof GetLeadsResponse200
     */
    data?: Array<OneLeadResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetLeadsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetMailThreadsResponse200
 */
export interface GetMailThreadsResponse200 {
    /**
     * The array of mail threads
     * @type {Array<any>}
     * @memberof GetMailThreadsResponse200
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface GetNoteFieldsResponse200
 */
export interface GetNoteFieldsResponse200 {
    /**
     * 
     * @type {Array<GetNoteFieldsResponse200Data>}
     * @memberof GetNoteFieldsResponse200
     */
    data?: Array<GetNoteFieldsResponse200Data>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetNoteFieldsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetNoteFieldsResponse200Data
 */
export interface GetNoteFieldsResponse200Data {
    /**
     * The ID of the field
     * @type {number}
     * @memberof GetNoteFieldsResponse200Data
     */
    id?: number;
    /**
     * The key of the field
     * @type {string}
     * @memberof GetNoteFieldsResponse200Data
     */
    key?: string;
    /**
     * The name of the field
     * @type {string}
     * @memberof GetNoteFieldsResponse200Data
     */
    name?: string;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`address`</td><td>Address field (has multiple subfields, autocompleted by Google Maps)</td></tr><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td></tr><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td></tr><tr><td>`double`</td><td>Numeric value</td></tr><tr><td>`enum`</td><td>Options field with a single possible chosen option</td></tr><tr></tr><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td></tr><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td></tr><tr><td>`people`</td><td>Person field (contains a person ID which is stored on the same account)</td></tr><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td></tr><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td></tr><tr><td>`text`</td><td>Long text (up to 65k characters)</td></tr><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td></tr><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td></tr><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td></tr><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td></tr><tr><td>`visible_to`</td><td>System field that keeps item's visibility setting</td></tr></table>
     * @type {string}
     * @memberof GetNoteFieldsResponse200Data
     */
    field_type?: GetNoteFieldsResponse200Data.FieldTypeEnum;
    /**
     * The active flag of the field
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200Data
     */
    active_flag?: boolean;
    /**
     * The edit flag of the field
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200Data
     */
    edit_flag?: boolean;
    /**
     * Not used
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200Data
     */
    bulk_edit_allowed?: boolean;
    /**
     * Whether or not the field is mandatory
     * @type {boolean}
     * @memberof GetNoteFieldsResponse200Data
     */
    mandatory_flag?: boolean;
    /**
     * The options of the field. When there are no options, `null` is returned.
     * @type {Array<GetNoteFieldsResponse200Options>}
     * @memberof GetNoteFieldsResponse200Data
     */
    options?: Array<GetNoteFieldsResponse200Options>;
}

/**
 * @export
 * @namespace GetNoteFieldsResponse200Data
 */
export namespace GetNoteFieldsResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldTypeEnum {
        Address = <any> 'address',
        Date = <any> 'date',
        Daterange = <any> 'daterange',
        Double = <any> 'double',
        Enum = <any> 'enum',
        Monetary = <any> 'monetary',
        Org = <any> 'org',
        People = <any> 'people',
        Phone = <any> 'phone',
        Set = <any> 'set',
        Text = <any> 'text',
        Time = <any> 'time',
        Timerange = <any> 'timerange',
        User = <any> 'user',
        Varchar = <any> 'varchar',
        VarcharAuto = <any> 'varchar_auto',
        VisibleTo = <any> 'visible_to'
    }
}
/**
 * 
 * @export
 * @interface GetNoteFieldsResponse200Options
 */
export interface GetNoteFieldsResponse200Options {
    /**
     * 
     * @type {number}
     * @memberof GetNoteFieldsResponse200Options
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GetNoteFieldsResponse200Options
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface GetNotesResponse200
 */
export interface GetNotesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetNotesResponse200
     */
    success?: boolean;
    /**
     * The array of notes
     * @type {Array<GetNotesResponse200Data>}
     * @memberof GetNotesResponse200
     */
    data?: Array<GetNotesResponse200Data>;
    /**
     * 
     * @type {GetCommentsResponse200AdditionalData}
     * @memberof GetNotesResponse200
     */
    additional_data?: GetCommentsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetNotesResponse200Data
 */
export interface GetNotesResponse200Data {
    /**
     * The ID of the note
     * @type {number}
     * @memberof GetNotesResponse200Data
     */
    id?: number;
    /**
     * Whether the note is active or deleted
     * @type {boolean}
     * @memberof GetNotesResponse200Data
     */
    active_flag?: boolean;
    /**
     * The creation date and time of the note
     * @type {string}
     * @memberof GetNotesResponse200Data
     */
    add_time?: string;
    /**
     * The content of the note in HTML format. Subject to sanitization on the back-end.
     * @type {string}
     * @memberof GetNotesResponse200Data
     */
    content?: string;
    /**
     * 
     * @type {GetNotesResponse200Deal}
     * @memberof GetNotesResponse200Data
     */
    deal?: GetNotesResponse200Deal;
    /**
     * The ID of the lead the note is attached to
     * @type {string}
     * @memberof GetNotesResponse200Data
     */
    lead_id?: string;
    /**
     * The ID of the deal the note is attached to
     * @type {number}
     * @memberof GetNotesResponse200Data
     */
    deal_id?: number;
    /**
     * The ID of the user who last updated the note
     * @type {number}
     * @memberof GetNotesResponse200Data
     */
    last_update_user_id?: number;
    /**
     * The ID of the organization the note is attached to
     * @type {number}
     * @memberof GetNotesResponse200Data
     */
    org_id?: number;
    /**
     * 
     * @type {GetNotesResponse200Organization}
     * @memberof GetNotesResponse200Data
     */
    organization?: GetNotesResponse200Organization;
    /**
     * 
     * @type {GetNotesResponse200Person}
     * @memberof GetNotesResponse200Data
     */
    person?: GetNotesResponse200Person;
    /**
     * The ID of the person the note is attached to
     * @type {number}
     * @memberof GetNotesResponse200Data
     */
    person_id?: number;
    /**
     * If true, the results are filtered by note to deal pinning state
     * @type {boolean}
     * @memberof GetNotesResponse200Data
     */
    pinned_to_deal_flag?: boolean;
    /**
     * If true, the results are filtered by note to organization pinning state
     * @type {boolean}
     * @memberof GetNotesResponse200Data
     */
    pinned_to_organization_flag?: boolean;
    /**
     * If true, the results are filtered by note to person pinning state
     * @type {boolean}
     * @memberof GetNotesResponse200Data
     */
    pinned_to_person_flag?: boolean;
    /**
     * The last updated date and time of the note
     * @type {string}
     * @memberof GetNotesResponse200Data
     */
    update_time?: string;
    /**
     * 
     * @type {GetNotesResponse200User}
     * @memberof GetNotesResponse200Data
     */
    user?: GetNotesResponse200User;
    /**
     * The ID of the note creator
     * @type {number}
     * @memberof GetNotesResponse200Data
     */
    user_id?: number;
}
/**
 * The deal this note is attached to
 * @export
 * @interface GetNotesResponse200Deal
 */
export interface GetNotesResponse200Deal {
    /**
     * The title of the deal this note is attached to
     * @type {string}
     * @memberof GetNotesResponse200Deal
     */
    title?: string;
}
/**
 * The organization the note is attached to
 * @export
 * @interface GetNotesResponse200Organization
 */
export interface GetNotesResponse200Organization {
    /**
     * The name of the organization the note is attached to
     * @type {string}
     * @memberof GetNotesResponse200Organization
     */
    name?: string;
}
/**
 * The person the note is attached to
 * @export
 * @interface GetNotesResponse200Person
 */
export interface GetNotesResponse200Person {
    /**
     * The name of the person the note is attached to
     * @type {string}
     * @memberof GetNotesResponse200Person
     */
    name?: string;
}
/**
 * The user who created the note
 * @export
 * @interface GetNotesResponse200User
 */
export interface GetNotesResponse200User {
    /**
     * The email of the note creator
     * @type {string}
     * @memberof GetNotesResponse200User
     */
    email?: string;
    /**
     * The URL of the note creator avatar picture
     * @type {string}
     * @memberof GetNotesResponse200User
     */
    icon_url?: string;
    /**
     * Whether the note is created by you or not
     * @type {boolean}
     * @memberof GetNotesResponse200User
     */
    is_you?: boolean;
    /**
     * The name of the note creator
     * @type {string}
     * @memberof GetNotesResponse200User
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GetOneMailThreadResponse200
 */
export interface GetOneMailThreadResponse200 {
    /**
     * The mail thread object
     * @type {any}
     * @memberof GetOneMailThreadResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetOrganizationRelationshipResponse200
 */
export interface GetOrganizationRelationshipResponse200 {
    /**
     * 
     * @type {any}
     * @memberof GetOrganizationRelationshipResponse200
     */
    data?: any;
    /**
     * 
     * @type {GetOrganizationRelationshipsResponse200RelatedObjects}
     * @memberof GetOrganizationRelationshipResponse200
     */
    related_objects?: GetOrganizationRelationshipsResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetOrganizationRelationshipsResponse200
 */
export interface GetOrganizationRelationshipsResponse200 {
    /**
     * The array of organization relationships
     * @type {Array<any>}
     * @memberof GetOrganizationRelationshipsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetOrganizationRelationshipsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {GetOrganizationRelationshipsResponse200RelatedObjects}
     * @memberof GetOrganizationRelationshipsResponse200
     */
    related_objects?: GetOrganizationRelationshipsResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetOrganizationRelationshipsResponse200RelatedObjects
 */
export interface GetOrganizationRelationshipsResponse200RelatedObjects {
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsOrganization}
     * @memberof GetOrganizationRelationshipsResponse200RelatedObjects
     */
    organization?: GetAssociatedUpdatesResponse200RelatedObjectsOrganization;
}
/**
 * 
 * @export
 * @interface GetOrganizationResponse200
 */
export interface GetOrganizationResponse200 {
    /**
     * 
     * @type {any}
     * @memberof GetOrganizationResponse200
     */
    data?: any;
    /**
     * 
     * @type {GetOrganizationResponse200AdditionalData}
     * @memberof GetOrganizationResponse200
     */
    additional_data?: GetOrganizationResponse200AdditionalData;
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjects}
     * @memberof GetOrganizationResponse200
     */
    related_objects?: UpdateOrganizationResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetOrganizationResponse200AdditionalData
 */
export interface GetOrganizationResponse200AdditionalData {
    /**
     * 
     * @type {GetOrganizationResponse200AdditionalDataFollowers}
     * @memberof GetOrganizationResponse200AdditionalData
     */
    followers?: GetOrganizationResponse200AdditionalDataFollowers;
    /**
     * Dropbox email for the organization
     * @type {string}
     * @memberof GetOrganizationResponse200AdditionalData
     */
    dropbox_email?: string;
}
/**
 * The follower that is associated with the item
 * @export
 * @interface GetOrganizationResponse200AdditionalDataFollowers
 */
export interface GetOrganizationResponse200AdditionalDataFollowers {
    /**
     * The user ID of the follower
     * @type {any}
     * @memberof GetOrganizationResponse200AdditionalDataFollowers
     */
    FOLLOWER_USER_ID?: any;
}
/**
 * 
 * @export
 * @interface GetOrganizationsResponse200
 */
export interface GetOrganizationsResponse200 {
    /**
     * The array of organizations
     * @type {Array<any>}
     * @memberof GetOrganizationsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof GetOrganizationsResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjects}
     * @memberof GetOrganizationsResponse200
     */
    related_objects?: UpdateOrganizationResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetPermissionSetsResponse200
 */
export interface GetPermissionSetsResponse200 {
    /**
     * The array of permission set
     * @type {Array<GetPermissionSetsResponse200Data>}
     * @memberof GetPermissionSetsResponse200
     */
    data?: Array<GetPermissionSetsResponse200Data>;
}
/**
 * 
 * @export
 * @interface GetPermissionSetsResponse200Data
 */
export interface GetPermissionSetsResponse200Data {
    /**
     * The ID of user permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200Data
     */
    id?: string;
    /**
     * The name of the permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200Data
     */
    name?: string;
    /**
     * The description of the permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200Data
     */
    description?: string;
    /**
     * The app that permission set belongs to
     * @type {string}
     * @memberof GetPermissionSetsResponse200Data
     */
    app?: GetPermissionSetsResponse200Data.AppEnum;
    /**
     * The type of permission set
     * @type {string}
     * @memberof GetPermissionSetsResponse200Data
     */
    type?: GetPermissionSetsResponse200Data.TypeEnum;
    /**
     * The number of users assigned to this permission set
     * @type {number}
     * @memberof GetPermissionSetsResponse200Data
     */
    assignment_count?: number;
}

/**
 * @export
 * @namespace GetPermissionSetsResponse200Data
 */
export namespace GetPermissionSetsResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum AppEnum {
        Sales = <any> 'sales',
        Projects = <any> 'projects',
        Campaigns = <any> 'campaigns',
        Global = <any> 'global',
        AccountSettings = <any> 'account_settings'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Admin = <any> 'admin',
        Manager = <any> 'manager',
        Regular = <any> 'regular',
        Custom = <any> 'custom'
    }
}
/**
 * 
 * @export
 * @interface GetPersonProductsResponse200
 */
export interface GetPersonProductsResponse200 {
    /**
     * The array of deal products
     * @type {Array<GetPersonProductsResponse200Data>}
     * @memberof GetPersonProductsResponse200
     */
    data?: Array<GetPersonProductsResponse200Data>;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof GetPersonProductsResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetPersonProductsResponse200DEALID
 */
export interface GetPersonProductsResponse200DEALID {
    /**
     * 
     * @type {GetPersonProductsResponse200DEALIDDeal}
     * @memberof GetPersonProductsResponse200DEALID
     */
    deal?: GetPersonProductsResponse200DEALIDDeal;
    /**
     * 
     * @type {GetPersonProductsResponse200DEALIDProduct}
     * @memberof GetPersonProductsResponse200DEALID
     */
    product?: GetPersonProductsResponse200DEALIDProduct;
}
/**
 * 
 * @export
 * @interface GetPersonProductsResponse200DEALIDDeal
 */
export interface GetPersonProductsResponse200DEALIDDeal {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    id?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    company_id?: number;
    /**
     * The ID of the deal creator
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    creator_user_id?: number;
    /**
     * The ID of the user
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    user_id?: number;
    /**
     * The ID of the person associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    person_id?: number;
    /**
     * The ID of the organization associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    org_id?: number;
    /**
     * The ID of the deal stage
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    stage_id?: number;
    /**
     * The title of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    title?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    value?: number;
    /**
     * The currency associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    currency?: string;
    /**
     * The creation date and time of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    add_time?: string;
    /**
     * The first creation date and time of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    first_add_time?: string;
    /**
     * The last updated date and time of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    update_time?: string;
    /**
     * The last updated date and time of the deal stage
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    stage_change_time?: string;
    /**
     * Whether the deal is active or not
     * @type {boolean}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    active?: boolean;
    /**
     * Whether the deal is deleted or not
     * @type {boolean}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    deleted?: boolean;
    /**
     * The status of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    status?: string;
    /**
     * The success probability percentage of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    probability?: number;
    /**
     * The date of the next activity associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    next_activity_date?: string;
    /**
     * The time of the next activity associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    next_activity_time?: string;
    /**
     * The ID of the next activity associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    next_activity_id?: number;
    /**
     * The ID of the last activity associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    last_activity_id?: number;
    /**
     * The date of the last activity associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    last_activity_date?: string;
    /**
     * The reason for losing the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    lost_reason?: string;
    /**
     * The visibility of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    visible_to?: string;
    /**
     * The date and time of closing the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    close_time?: string;
    /**
     * The ID of pipeline associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    pipeline_id?: number;
    /**
     * The date and time of changing the deal status as won
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    won_time?: string;
    /**
     * The date and time of the first time changing the deal status as won
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    first_won_time?: string;
    /**
     * The date and time of changing the deal status as lost
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    lost_time?: string;
    /**
     * The number of products associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    products_count?: number;
    /**
     * The number of files associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    files_count?: number;
    /**
     * The number of notes associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    notes_count?: number;
    /**
     * The number of followers associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    followers_count?: number;
    /**
     * The number of emails associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    email_messages_count?: number;
    /**
     * The number of activities associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    activities_count?: number;
    /**
     * The number of completed activities associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    done_activities_count?: number;
    /**
     * The number of incomplete activities associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    undone_activities_count?: number;
    /**
     * The number of participants associated with the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    participants_count?: number;
    /**
     * The expected close date of the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    expected_close_date?: string;
    /**
     * The date and time of the last incoming email associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    last_incoming_mail_time?: string;
    /**
     * The date and time of the last outgoing email associated with the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    last_outgoing_mail_time?: string;
    /**
     * The label assigned to the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDDeal
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface GetPersonProductsResponse200DEALIDProduct
 */
export interface GetPersonProductsResponse200DEALIDProduct {
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    id?: number;
    /**
     * The ID of the company
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    company_id?: number;
    /**
     * The name of the product
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    name?: string;
    /**
     * The product code
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    code?: string;
    /**
     * The description of the product
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    description?: string;
    /**
     * The unit in which this product is sold
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    unit?: string;
    /**
     * The tax percentage
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    tax?: number;
    /**
     * The category of the product
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    category?: string;
    /**
     * Whether this product will be made active or not
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    active_flag?: GetPersonProductsResponse200DEALIDProduct.ActiveFlagEnum;
    /**
     * Whether this product can be selected in deals or not
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    selectable?: GetPersonProductsResponse200DEALIDProduct.SelectableEnum;
    /**
     * The first letter of the product name
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    first_char?: string;
    /**
     * The visibility of the product. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    visible_to?: string;
    /**
     * The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    owner_id?: number;
    /**
     * The count of files
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    files_count?: number;
    /**
     * The count of followers
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    followers_count?: number;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    add_time?: string;
    /**
     * The date and time when the product was updated to the deal
     * @type {string}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    update_time?: string;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof GetPersonProductsResponse200DEALIDProduct
     */
    deal_id?: number;
}

/**
 * @export
 * @namespace GetPersonProductsResponse200DEALIDProduct
 */
export namespace GetPersonProductsResponse200DEALIDProduct {
    /**
     * @export
     * @enum {string}
     */
    export enum ActiveFlagEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SelectableEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}
/**
 * 
 * @export
 * @interface GetPersonProductsResponse200Data
 */
export interface GetPersonProductsResponse200Data {
    /**
     * 
     * @type {GetPersonProductsResponse200DEALID}
     * @memberof GetPersonProductsResponse200Data
     */
    DEAL_ID?: GetPersonProductsResponse200DEALID;
}
/**
 * 
 * @export
 * @interface GetPersonResponse200
 */
export interface GetPersonResponse200 {
    /**
     * 
     * @type {any}
     * @memberof GetPersonResponse200
     */
    data?: any;
    /**
     * 
     * @type {GetPersonResponse200AdditionalData}
     * @memberof GetPersonResponse200
     */
    additional_data?: GetPersonResponse200AdditionalData;
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjects}
     * @memberof GetPersonResponse200
     */
    related_objects?: UpdateOrganizationResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetPersonResponse200AdditionalData
 */
export interface GetPersonResponse200AdditionalData {
    /**
     * Dropbox email for the person
     * @type {string}
     * @memberof GetPersonResponse200AdditionalData
     */
    dropbox_email?: string;
}
/**
 * 
 * @export
 * @interface GetPersonsResponse200
 */
export interface GetPersonsResponse200 {
    /**
     * The array of persons
     * @type {Array<any>}
     * @memberof GetPersonsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof GetPersonsResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjects}
     * @memberof GetPersonsResponse200
     */
    related_objects?: UpdateOrganizationResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetPipelineConversionStatisticsResponse200
 */
export interface GetPipelineConversionStatisticsResponse200 {
    /**
     * 
     * @type {GetPipelineConversionStatisticsResponse200Data}
     * @memberof GetPipelineConversionStatisticsResponse200
     */
    data?: GetPipelineConversionStatisticsResponse200Data;
}
/**
 * The pipeline object
 * @export
 * @interface GetPipelineConversionStatisticsResponse200Data
 */
export interface GetPipelineConversionStatisticsResponse200Data {
    /**
     * The stage conversions
     * @type {Array<GetPipelineConversionStatisticsResponse200DataStageConversions>}
     * @memberof GetPipelineConversionStatisticsResponse200Data
     */
    stage_conversions?: Array<GetPipelineConversionStatisticsResponse200DataStageConversions>;
    /**
     * The won conversion
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200Data
     */
    won_conversion?: number;
    /**
     * The lost conversion
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200Data
     */
    lost_conversion?: number;
}
/**
 * 
 * @export
 * @interface GetPipelineConversionStatisticsResponse200DataStageConversions
 */
export interface GetPipelineConversionStatisticsResponse200DataStageConversions {
    /**
     * The stage ID from where conversion starts
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200DataStageConversions
     */
    from_stage_id?: number;
    /**
     * The stage ID to where conversion ends
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200DataStageConversions
     */
    to_stage_id?: number;
    /**
     * The conversion rate
     * @type {number}
     * @memberof GetPipelineConversionStatisticsResponse200DataStageConversions
     */
    conversion_rate?: number;
}
/**
 * 
 * @export
 * @interface GetPipelineMovementStatisticsResponse200
 */
export interface GetPipelineMovementStatisticsResponse200 {
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200Data}
     * @memberof GetPipelineMovementStatisticsResponse200
     */
    data?: GetPipelineMovementStatisticsResponse200Data;
}
/**
 * The pipeline object
 * @export
 * @interface GetPipelineMovementStatisticsResponse200Data
 */
export interface GetPipelineMovementStatisticsResponse200Data {
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataMovementsBetweenStages}
     * @memberof GetPipelineMovementStatisticsResponse200Data
     */
    movements_between_stages?: GetPipelineMovementStatisticsResponse200DataMovementsBetweenStages;
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200Data
     */
    new_deals?: GetPipelineMovementStatisticsResponse200DataNewDeals;
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200Data
     */
    deals_left_open?: GetPipelineMovementStatisticsResponse200DataNewDeals;
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200Data
     */
    won_deals?: GetPipelineMovementStatisticsResponse200DataNewDeals;
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataNewDeals}
     * @memberof GetPipelineMovementStatisticsResponse200Data
     */
    lost_deals?: GetPipelineMovementStatisticsResponse200DataNewDeals;
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataAverageAgeInDays}
     * @memberof GetPipelineMovementStatisticsResponse200Data
     */
    average_age_in_days?: GetPipelineMovementStatisticsResponse200DataAverageAgeInDays;
}
/**
 * The moved deals average age in days
 * @export
 * @interface GetPipelineMovementStatisticsResponse200DataAverageAgeInDays
 */
export interface GetPipelineMovementStatisticsResponse200DataAverageAgeInDays {
    /**
     * The moved deals average age across all stages
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200DataAverageAgeInDays
     */
    across_all_stages?: number;
    /**
     * The moved deals average age by stages
     * @type {Array<GetPipelineMovementStatisticsResponse200DataAverageAgeInDaysByStages>}
     * @memberof GetPipelineMovementStatisticsResponse200DataAverageAgeInDays
     */
    by_stages?: Array<GetPipelineMovementStatisticsResponse200DataAverageAgeInDaysByStages>;
}
/**
 * The moved deals average age by the stage
 * @export
 * @interface GetPipelineMovementStatisticsResponse200DataAverageAgeInDaysByStages
 */
export interface GetPipelineMovementStatisticsResponse200DataAverageAgeInDaysByStages {
    /**
     * The stage ID
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200DataAverageAgeInDaysByStages
     */
    stage_id?: number;
    /**
     * The average deals age in specific stage
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200DataAverageAgeInDaysByStages
     */
    value?: number;
}
/**
 * Movements between stages
 * @export
 * @interface GetPipelineMovementStatisticsResponse200DataMovementsBetweenStages
 */
export interface GetPipelineMovementStatisticsResponse200DataMovementsBetweenStages {
    /**
     * The count of the deals that have been moved between stages
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200DataMovementsBetweenStages
     */
    count?: number;
}
/**
 * Deals summary
 * @export
 * @interface GetPipelineMovementStatisticsResponse200DataNewDeals
 */
export interface GetPipelineMovementStatisticsResponse200DataNewDeals {
    /**
     * The count of the deals
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200DataNewDeals
     */
    count?: number;
    /**
     * The IDs of the deals that have been moved
     * @type {Array<number>}
     * @memberof GetPipelineMovementStatisticsResponse200DataNewDeals
     */
    deals_ids?: Array<number>;
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataNewDealsValues}
     * @memberof GetPipelineMovementStatisticsResponse200DataNewDeals
     */
    values?: GetPipelineMovementStatisticsResponse200DataNewDealsValues;
    /**
     * 
     * @type {GetPipelineMovementStatisticsResponse200DataNewDealsFormattedValues}
     * @memberof GetPipelineMovementStatisticsResponse200DataNewDeals
     */
    formatted_values?: GetPipelineMovementStatisticsResponse200DataNewDealsFormattedValues;
}
/**
 * The formatted values of the deals
 * @export
 * @interface GetPipelineMovementStatisticsResponse200DataNewDealsFormattedValues
 */
export interface GetPipelineMovementStatisticsResponse200DataNewDealsFormattedValues {
    /**
     * The formatted values of the deals
     * @type {string}
     * @memberof GetPipelineMovementStatisticsResponse200DataNewDealsFormattedValues
     */
    CURRENCY_ID?: string;
}
/**
 * The values of the deals
 * @export
 * @interface GetPipelineMovementStatisticsResponse200DataNewDealsValues
 */
export interface GetPipelineMovementStatisticsResponse200DataNewDealsValues {
    /**
     * The value of the deals
     * @type {number}
     * @memberof GetPipelineMovementStatisticsResponse200DataNewDealsValues
     */
    CURRENCY_ID?: number;
}
/**
 * 
 * @export
 * @interface GetPipelineResponse200
 */
export interface GetPipelineResponse200 {
    /**
     * The pipeline object
     * @type {any}
     * @memberof GetPipelineResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetPipelinesResponse200
 */
export interface GetPipelinesResponse200 {
    /**
     * Pipelines array
     * @type {Array<any>}
     * @memberof GetPipelinesResponse200
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface GetProductAttachementResponse200
 */
export interface GetProductAttachementResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductAttachementResponse200
     */
    success?: boolean;
    /**
     * The updated product object attached to the deal
     * @type {any}
     * @memberof GetProductAttachementResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetProductFieldResponse200
 */
export interface GetProductFieldResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductFieldResponse200
     */
    success?: boolean;
    /**
     * All data for the product field
     * @type {any}
     * @memberof GetProductFieldResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetProductFieldsResponse200
 */
export interface GetProductFieldsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductFieldsResponse200
     */
    success?: boolean;
    /**
     * Array containing data for all product fields
     * @type {Array<any>}
     * @memberof GetProductFieldsResponse200
     */
    data?: Array<any>;
    /**
     * Additional data for the product field, such as pagination
     * @type {any}
     * @memberof GetProductFieldsResponse200
     */
    additional_data?: any;
}
/**
 * 
 * @export
 * @interface GetProductFollowersResponseSuccess
 */
export interface GetProductFollowersResponseSuccess {
    /**
     * The list of followers
     * @type {Array<GetProductFollowersResponseSuccessData>}
     * @memberof GetProductFollowersResponseSuccess
     */
    data?: Array<GetProductFollowersResponseSuccessData>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetProductFollowersResponseSuccess
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetProductFollowersResponseSuccessData
 */
export interface GetProductFollowersResponseSuccessData {
    /**
     * The ID of the user
     * @type {number}
     * @memberof GetProductFollowersResponseSuccessData
     */
    user_id?: number;
    /**
     * The ID of the user follower
     * @type {number}
     * @memberof GetProductFollowersResponseSuccessData
     */
    id?: number;
    /**
     * The ID of the product
     * @type {number}
     * @memberof GetProductFollowersResponseSuccessData
     */
    product_id?: number;
    /**
     * The date and time when the follower was added to the person
     * @type {string}
     * @memberof GetProductFollowersResponseSuccessData
     */
    add_time?: string;
}
/**
 * 
 * @export
 * @interface GetProductsResponse200
 */
export interface GetProductsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetProductsResponse200
     */
    success?: boolean;
    /**
     * Array containing data for all products
     * @type {Array<GetproductResponse2001>}
     * @memberof GetProductsResponse200
     */
    data?: Array<GetproductResponse2001>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetProductsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjects}
     * @memberof GetProductsResponse200
     */
    related_objects?: UpdateProductResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetRecentsResponse200
 */
export interface GetRecentsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetRecentsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof GetRecentsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetRecentsResponse200AdditionalData}
     * @memberof GetRecentsResponse200
     */
    additional_data?: GetRecentsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetRecentsResponse200AdditionalData
 */
export interface GetRecentsResponse200AdditionalData {
    /**
     * The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetRecentsResponse200AdditionalData
     */
    since_timestamp?: string;
    /**
     * The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof GetRecentsResponse200AdditionalData
     */
    last_timestamp_on_page?: string;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetRecentsResponse200AdditionalData
     */
    pagination?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetRoleResponse200
 */
export interface GetRoleResponse200 {
    /**
     * The details of the sub-role
     * @type {any}
     * @memberof GetRoleResponse200
     */
    data?: any;
    /**
     * 
     * @type {GetRoleResponse200AdditionalData}
     * @memberof GetRoleResponse200
     */
    additional_data?: GetRoleResponse200AdditionalData;
}
/**
 * The additional data in the role
 * @export
 * @interface GetRoleResponse200AdditionalData
 */
export interface GetRoleResponse200AdditionalData {
    /**
     * 
     * @type {GetRoleResponse200AdditionalDataSettings}
     * @memberof GetRoleResponse200AdditionalData
     */
    settings?: GetRoleResponse200AdditionalDataSettings;
}
/**
 * The settings for the role
 * @export
 * @interface GetRoleResponse200AdditionalDataSettings
 */
export interface GetRoleResponse200AdditionalDataSettings {
    /**
     * The default visibility level of the deals for the role
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    deal_default_visibility?: number;
    /**
     * The default visibility level of the leads for the role
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    lead_default_visibility?: number;
    /**
     * The default visibility level of the organizations for the role
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    org_default_visibility?: number;
    /**
     * The default visibility level of the people for the role
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    person_default_visibility?: number;
    /**
     * The default visibility level of the products for the role
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    product_default_visibility?: number;
    /**
     * The access level of the deals for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    deal_access_level?: number;
    /**
     * The access level of the organizations for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    org_access_level?: number;
    /**
     * The access level of the people for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    person_access_level?: number;
    /**
     * The access level of the products for the role (only for default role)
     * @type {number}
     * @memberof GetRoleResponse200AdditionalDataSettings
     */
    product_access_level?: number;
}
/**
 * 
 * @export
 * @interface GetRoleSettingsResponse200
 */
export interface GetRoleSettingsResponse200 {
    /**
     * 
     * @type {GetRoleResponse200AdditionalDataSettings}
     * @memberof GetRoleSettingsResponse200
     */
    data?: GetRoleResponse200AdditionalDataSettings;
}
/**
 * 
 * @export
 * @interface GetRoleSubrolesResponse200
 */
export interface GetRoleSubrolesResponse200 {
    /**
     * The array of sub-roles
     * @type {Array<any>}
     * @memberof GetRoleSubrolesResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetRoleSubrolesResponse200AdditionalData}
     * @memberof GetRoleSubrolesResponse200
     */
    additional_data?: GetRoleSubrolesResponse200AdditionalData;
}
/**
 * The additional data in the role list
 * @export
 * @interface GetRoleSubrolesResponse200AdditionalData
 */
export interface GetRoleSubrolesResponse200AdditionalData {
    /**
     * 
     * @type {GetRoleSubrolesResponse200AdditionalDataPagination}
     * @memberof GetRoleSubrolesResponse200AdditionalData
     */
    pagination?: GetRoleSubrolesResponse200AdditionalDataPagination;
}
/**
 * The pagination details in the role list
 * @export
 * @interface GetRoleSubrolesResponse200AdditionalDataPagination
 */
export interface GetRoleSubrolesResponse200AdditionalDataPagination {
    /**
     * Pagination start
     * @type {number}
     * @memberof GetRoleSubrolesResponse200AdditionalDataPagination
     */
    start?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof GetRoleSubrolesResponse200AdditionalDataPagination
     */
    limit?: number;
    /**
     * Whether there are more list items in the collection than displayed
     * @type {boolean}
     * @memberof GetRoleSubrolesResponse200AdditionalDataPagination
     */
    more_items_in_collection?: boolean;
}
/**
 * 
 * @export
 * @interface GetRolesResponse200
 */
export interface GetRolesResponse200 {
    /**
     * The array of roles
     * @type {Array<any>}
     * @memberof GetRolesResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetRoleSubrolesResponse200AdditionalData}
     * @memberof GetRolesResponse200
     */
    additional_data?: GetRoleSubrolesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetStageDealsResponse200
 */
export interface GetStageDealsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetStageDealsResponse200
     */
    success?: boolean;
    /**
     * The array of deals
     * @type {Array<any>}
     * @memberof GetStageDealsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetStageDealsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetStageResponse200
 */
export interface GetStageResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetStageResponse200
     */
    success?: boolean;
    /**
     * The stage object
     * @type {any}
     * @memberof GetStageResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface GetStagesResponse200
 */
export interface GetStagesResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof GetStagesResponse200
     */
    success?: boolean;
    /**
     * The array of stages
     * @type {Array<any>}
     * @memberof GetStagesResponse200
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface GetUserCallLogsResponse200
 */
export interface GetUserCallLogsResponse200 {
    /**
     * 
     * @type {Array<any>}
     * @memberof GetUserCallLogsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof GetUserCallLogsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetUserPermissionsResponse200
 */
export interface GetUserPermissionsResponse200 {
    /**
     * 
     * @type {GetUserPermissionsResponse200Data}
     * @memberof GetUserPermissionsResponse200
     */
    data?: GetUserPermissionsResponse200Data;
}
/**
 * 
 * @export
 * @interface GetUserPermissionsResponse200Data
 */
export interface GetUserPermissionsResponse200Data {
    /**
     * If the user can add custom fields
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_add_custom_fields?: boolean;
    /**
     * If the user can add products
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_add_products?: boolean;
    /**
     * If the user can add prospects as leads
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_add_prospects_as_leads?: boolean;
    /**
     * If the user can bulk edit items
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_bulk_edit_items?: boolean;
    /**
     * If the user can change visibility of items
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_change_visibility_of_items?: boolean;
    /**
     * If the user can convert deals to leads
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_convert_deals_to_leads?: boolean;
    /**
     * If the user can create workflows
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_create_own_workflow?: boolean;
    /**
     * If the user can delete activities
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_delete_activities?: boolean;
    /**
     * If the user can delete custom fields
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_delete_custom_fields?: boolean;
    /**
     * If the user can delete deals
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_delete_deals?: boolean;
    /**
     * If the user can edit custom fields
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_edit_custom_fields?: boolean;
    /**
     * If the user can edit deals' closed date
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_edit_deals_closed_date?: boolean;
    /**
     * If the user can edit products
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_edit_products?: boolean;
    /**
     * If the user can edit shared filters
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_edit_shared_filters?: boolean;
    /**
     * If the user can export data from item lists
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_export_data_from_lists?: boolean;
    /**
     * If the user can follow other users
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_follow_other_users?: boolean;
    /**
     * If the user can merge deals
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_merge_deals?: boolean;
    /**
     * If the user can merge organizations
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_merge_organizations?: boolean;
    /**
     * If the user can merge people
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_merge_people?: boolean;
    /**
     * If the user can modify labels
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_modify_labels?: boolean;
    /**
     * If the user can see company-wide statistics
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_see_company_wide_statistics?: boolean;
    /**
     * If the user can see the summary on the deals page
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_see_deals_list_summary?: boolean;
    /**
     * If the user can see the names of hidden items
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_see_hidden_items_names?: boolean;
    /**
     * If the user can see other users
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_see_other_users?: boolean;
    /**
     * If the user can see other users' statistics
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_see_other_users_statistics?: boolean;
    /**
     * If the user can see security dashboard
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_see_security_dashboard?: boolean;
    /**
     * If the user can share filters
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_share_filters?: boolean;
    /**
     * If the user can share insights
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_share_insights?: boolean;
    /**
     * If the user can use API
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_use_api?: boolean;
    /**
     * If the user can use email tracking
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_use_email_tracking?: boolean;
    /**
     * If the user can use import
     * @type {boolean}
     * @memberof GetUserPermissionsResponse200Data
     */
    can_use_import?: boolean;
}
/**
 * 
 * @export
 * @interface GetUserRoleAssignmentsResponse200
 */
export interface GetUserRoleAssignmentsResponse200 {
    /**
     * The role assignments
     * @type {Array<any>}
     * @memberof GetUserRoleAssignmentsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetRoleSubrolesResponse200AdditionalData}
     * @memberof GetUserRoleAssignmentsResponse200
     */
    additional_data?: GetRoleSubrolesResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface GetUserSettingsResponse200
 */
export interface GetUserSettingsResponse200 {
    /**
     * 
     * @type {GetUserSettingsResponse200Data}
     * @memberof GetUserSettingsResponse200
     */
    data?: GetUserSettingsResponse200Data;
}
/**
 * 
 * @export
 * @interface GetUserSettingsResponse200Data
 */
export interface GetUserSettingsResponse200Data {
    /**
     * If the vendors are allowed to install custom Marketplace apps with functionality and content in the Pipedrive UI or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200Data
     */
    marketplace_allow_custom_install_url?: boolean;
    /**
     * If the vendors are allowed to extend their Marketplace apps with functionality and content in the Pipedrive UI or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200Data
     */
    marketplace_app_extensions_vendor?: boolean;
    /**
     * If the vendors are allowed to be part of the Marketplace team or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200Data
     */
    marketplace_team?: boolean;
    /**
     * The number of results shown in list by default
     * @type {number}
     * @memberof GetUserSettingsResponse200Data
     */
    list_limit?: number;
    /**
     * Whether beta app is enabled
     * @type {boolean}
     * @memberof GetUserSettingsResponse200Data
     */
    beta_app?: boolean;
    /**
     * Prevent salesphone call to override
     * @type {boolean}
     * @memberof GetUserSettingsResponse200Data
     */
    prevent_salesphone_callto_override?: boolean;
    /**
     * The destination of file upload
     * @type {string}
     * @memberof GetUserSettingsResponse200Data
     */
    file_upload_destination?: string;
    /**
     * The call to link syntax
     * @type {string}
     * @memberof GetUserSettingsResponse200Data
     */
    callto_link_syntax?: string;
    /**
     * Whether the expected close date of the deal is filled automatically or not
     * @type {boolean}
     * @memberof GetUserSettingsResponse200Data
     */
    autofill_deal_expected_close_date?: boolean;
    /**
     * Allow the vendors to duplicate a person
     * @type {string}
     * @memberof GetUserSettingsResponse200Data
     */
    person_duplicate_condition?: string;
}
/**
 * 
 * @export
 * @interface GetWebhooksResponse200
 */
export interface GetWebhooksResponse200 {
    /**
     * The array of Webhooks
     * @type {Array<WebhookResponse200Data>}
     * @memberof GetWebhooksResponse200
     */
    data?: Array<WebhookResponse200Data>;
}
/**
 * 
 * @export
 * @interface GetproductResponse200
 */
export interface GetproductResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetproductResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof GetproductResponse200
     */
    data?: any;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjects}
     * @memberof GetproductResponse200
     */
    related_objects?: UpdateProductResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface GetproductResponse2001
 */
export interface GetproductResponse2001 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof GetproductResponse2001
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof GetproductResponse2001
     */
    data?: any;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjects}
     * @memberof GetproductResponse2001
     */
    related_objects?: UpdateProductResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {any}
     * @memberof InlineResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    success?: boolean;
    /**
     * 
     * @type {InlineResponse2001Data}
     * @memberof InlineResponse2001
     */
    data?: InlineResponse2001Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2001Data
 */
export interface InlineResponse2001Data {
    /**
     * The unique channel ID used internally in omnichannel-api and the frontend of the extension
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    id?: string;
    /**
     * The name of the channel
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    name?: string;
    /**
     * The URL for an icon that represents your channel
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    avatar_url?: string;
    /**
     * The channel ID you specified while creating the channel
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    provider_channel_id?: string;
    /**
     * The client_id of your app in Pipedrive marketplace
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    marketplace_client_id?: string;
    /**
     * The ID of the user's company in Pipedrive
     * @type {number}
     * @memberof InlineResponse2001Data
     */
    pd_company_id?: number;
    /**
     * The ID of the user in Pipedrive
     * @type {number}
     * @memberof InlineResponse2001Data
     */
    pd_user_id?: number;
    /**
     * The date and time when your channel was created in the API
     * @type {Date}
     * @memberof InlineResponse2001Data
     */
    created_at?: Date;
    /**
     * Value of the provider_type sent to this endpoint
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    provider_type?: InlineResponse2001Data.ProviderTypeEnum;
    /**
     * Value of the template_support sent to this endpoint
     * @type {boolean}
     * @memberof InlineResponse2001Data
     */
    template_support?: boolean;
}

/**
 * @export
 * @namespace InlineResponse2001Data
 */
export namespace InlineResponse2001Data {
    /**
     * @export
     * @enum {string}
     */
    export enum ProviderTypeEnum {
        Facebook = <any> 'facebook',
        Whatsapp = <any> 'whatsapp',
        Other = <any> 'other'
    }
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    success?: boolean;
    /**
     * 
     * @type {MessagesReceiveBody}
     * @memberof InlineResponse2003
     */
    data?: MessagesReceiveBody;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse400
     */
    success?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof InlineResponse400
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    error_info?: string;
    /**
     * 
     * @type {InlineResponse400AdditionalData}
     * @memberof InlineResponse400
     */
    additional_data?: InlineResponse400AdditionalData;
}
/**
 * 
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse4001
     */
    success?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof InlineResponse4001
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4001
     */
    error_info?: string;
    /**
     * 
     * @type {InlineResponse4001AdditionalData}
     * @memberof InlineResponse4001
     */
    additional_data?: InlineResponse4001AdditionalData;
}
/**
 * 
 * @export
 * @interface InlineResponse4001AdditionalData
 */
export interface InlineResponse4001AdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof InlineResponse4001AdditionalData
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse400AdditionalData
 */
export interface InlineResponse400AdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof InlineResponse400AdditionalData
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse403
     */
    success?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof InlineResponse403
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403
     */
    error_info?: string;
    /**
     * 
     * @type {InlineResponse403AdditionalData}
     * @memberof InlineResponse403
     */
    additional_data?: InlineResponse403AdditionalData;
}
/**
 * 
 * @export
 * @interface InlineResponse4031
 */
export interface InlineResponse4031 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse4031
     */
    success?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof InlineResponse4031
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4031
     */
    error_info?: string;
    /**
     * 
     * @type {InlineResponse4031AdditionalData}
     * @memberof InlineResponse4031
     */
    additional_data?: InlineResponse4031AdditionalData;
}
/**
 * 
 * @export
 * @interface InlineResponse4031AdditionalData
 */
export interface InlineResponse4031AdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof InlineResponse4031AdditionalData
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse4032
 */
export interface InlineResponse4032 {
    /**
     * The error message
     * @type {string}
     * @memberof InlineResponse4032
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse403AdditionalData
 */
export interface InlineResponse403AdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof InlineResponse403AdditionalData
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse404
     */
    success?: boolean;
    /**
     * The error description
     * @type {string}
     * @memberof InlineResponse404
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    error_info?: string;
    /**
     * 
     * @type {InlineResponse404AdditionalData}
     * @memberof InlineResponse404
     */
    additional_data?: InlineResponse404AdditionalData;
}
/**
 * 
 * @export
 * @interface InlineResponse404AdditionalData
 */
export interface InlineResponse404AdditionalData {
    /**
     * An error code sent by the API
     * @type {string}
     * @memberof InlineResponse404AdditionalData
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface LeadIdResponse200
 */
export interface LeadIdResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof LeadIdResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {LeadIdResponse200Data}
     * @memberof LeadIdResponse200
     */
    data?: LeadIdResponse200Data;
}
/**
 * 
 * @export
 * @interface LeadIdResponse200Data
 */
export interface LeadIdResponse200Data {
    /**
     * 
     * @type {string}
     * @memberof LeadIdResponse200Data
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface LeadResponse404
 */
export interface LeadResponse404 {
    /**
     * 
     * @type {boolean}
     * @memberof LeadResponse404
     */
    success?: boolean;
    /**
     * The description of the error
     * @type {string}
     * @memberof LeadResponse404
     */
    error?: string;
    /**
     * A message describing how to solve the problem
     * @type {string}
     * @memberof LeadResponse404
     */
    error_info?: string;
    /**
     * 
     * @type {any}
     * @memberof LeadResponse404
     */
    data?: any;
    /**
     * 
     * @type {any}
     * @memberof LeadResponse404
     */
    additional_data?: any;
}
/**
 * The potential value of the lead
 * @export
 * @interface LeadsValue
 */
export interface LeadsValue {
    /**
     * 
     * @type {number}
     * @memberof LeadsValue
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof LeadsValue
     */
    currency: string;
}
/**
 * The potential value of the lead
 * @export
 * @interface LeadsidValue
 */
export interface LeadsidValue {
    /**
     * 
     * @type {number}
     * @memberof LeadsidValue
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof LeadsidValue
     */
    currency: string;
}
/**
 * 
 * @export
 * @interface LinkFileToItemRequest
 */
export interface LinkFileToItemRequest {
    /**
     * The item type
     * @type {string}
     * @memberof LinkFileToItemRequest
     */
    item_type: LinkFileToItemRequest.ItemTypeEnum;
    /**
     * The ID of the item to associate the file with
     * @type {number}
     * @memberof LinkFileToItemRequest
     */
    item_id: number;
    /**
     * The remote item ID
     * @type {string}
     * @memberof LinkFileToItemRequest
     */
    remote_id: string;
    /**
     * The location type to send the file to. Only `googledrive` is supported at the moment.
     * @type {string}
     * @memberof LinkFileToItemRequest
     */
    remote_location: LinkFileToItemRequest.RemoteLocationEnum;
}

/**
 * @export
 * @namespace LinkFileToItemRequest
 */
export namespace LinkFileToItemRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ItemTypeEnum {
        Deal = <any> 'deal',
        Organization = <any> 'organization',
        Person = <any> 'person'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RemoteLocationEnum {
        Googledrive = <any> 'googledrive'
    }
}
/**
 * 
 * @export
 * @interface LinkFileToItemResponse200
 */
export interface LinkFileToItemResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof LinkFileToItemResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {LinkFileToItemResponse200Data}
     * @memberof LinkFileToItemResponse200
     */
    data?: LinkFileToItemResponse200Data;
}
/**
 * The file data
 * @export
 * @interface LinkFileToItemResponse200Data
 */
export interface LinkFileToItemResponse200Data {
    /**
     * The ID of the file
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    id?: number;
    /**
     * The ID of the user to associate the file with
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the deal to associate the file with
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    deal_id?: number;
    /**
     * The ID of the person to associate the file with
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    person_id?: number;
    /**
     * The ID of the organization to associate the file with
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    org_id?: number;
    /**
     * The ID of the product to associate the file with
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    product_id?: number;
    /**
     * The ID of the activity to associate the file with
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    activity_id?: number;
    /**
     * The date and time when the file was added/created. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    add_time?: string;
    /**
     * The last updated date and time of the file. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    update_time?: string;
    /**
     * The original name of the file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    file_name?: string;
    /**
     * The size of the file
     * @type {number}
     * @memberof LinkFileToItemResponse200Data
     */
    file_size?: number;
    /**
     * Whether the user is active or not. false = Not activated, true = Activated
     * @type {boolean}
     * @memberof LinkFileToItemResponse200Data
     */
    active_flag?: boolean;
    /**
     * Whether the file was uploaded as inline or not
     * @type {boolean}
     * @memberof LinkFileToItemResponse200Data
     */
    inline_flag?: boolean;
    /**
     * The location type to send the file to. Only googledrive is supported at the moment.
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    remote_location?: string;
    /**
     * The ID of the remote item
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    remote_id?: string;
    /**
     * The ID of the inline attachment
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    cid?: string;
    /**
     * The location of the cloud storage
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    s3_bucket?: string;
    /**
     * The ID of the mail message to associate the file with
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    mail_message_id?: string;
    /**
     * The ID of the mail template to associate the file with
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    mail_template_id?: string;
    /**
     * The name of the deal associated with the file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    deal_name?: string;
    /**
     * The name of the person associated with the file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    person_name?: string;
    /**
     * The name of the organization associated with the file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    org_name?: string;
    /**
     * The name of the product associated with the file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    product_name?: string;
    /**
     * The URL of the download file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    url?: string;
    /**
     * The visible name of the file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    name?: string;
    /**
     * The description of the file
     * @type {string}
     * @memberof LinkFileToItemResponse200Data
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ListPermittedUsersResponse200
 */
export interface ListPermittedUsersResponse200 {
    /**
     * 
     * @type {ListPermittedUsersResponse200Data}
     * @memberof ListPermittedUsersResponse200
     */
    data?: ListPermittedUsersResponse200Data;
}
/**
 * 
 * @export
 * @interface ListPermittedUsersResponse2001
 */
export interface ListPermittedUsersResponse2001 {
    /**
     * The list of permitted user IDs
     * @type {Array<number>}
     * @memberof ListPermittedUsersResponse2001
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface ListPermittedUsersResponse200Data
 */
export interface ListPermittedUsersResponse200Data {
    /**
     * The list of permitted users IDs
     * @type {Array<number>}
     * @memberof ListPermittedUsersResponse200Data
     */
    id?: Array<number>;
}
/**
 * 
 * @export
 * @interface ListPersonsResponse200
 */
export interface ListPersonsResponse200 {
    /**
     * The array of persons
     * @type {Array<any>}
     * @memberof ListPersonsResponse200
     */
    data?: Array<any>;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200AdditionalData}
     * @memberof ListPersonsResponse200
     */
    additional_data?: GetAssociatedUpdatesResponse200AdditionalData;
    /**
     * 
     * @type {ListPersonsResponse200RelatedObjects}
     * @memberof ListPersonsResponse200
     */
    related_objects?: ListPersonsResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface ListPersonsResponse200RelatedObjects
 */
export interface ListPersonsResponse200RelatedObjects {
    /**
     * 
     * @type {ListPersonsResponse200RelatedObjectsOrganization}
     * @memberof ListPersonsResponse200RelatedObjects
     */
    organization?: ListPersonsResponse200RelatedObjectsOrganization;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof ListPersonsResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
}
/**
 * 
 * @export
 * @interface ListPersonsResponse200RelatedObjectsOrganization
 */
export interface ListPersonsResponse200RelatedObjectsOrganization {
    /**
     * The ID of the organization associated with the item
     * @type {any}
     * @memberof ListPersonsResponse200RelatedObjectsOrganization
     */
    ORGANIZATION_ID?: any;
}
/**
 * 
 * @export
 * @interface ListProductsResponse200
 */
export interface ListProductsResponse200 {
    /**
     * 
     * @type {ListProductsResponse200Data}
     * @memberof ListProductsResponse200
     */
    data?: ListProductsResponse200Data;
    /**
     * 
     * @type {any}
     * @memberof ListProductsResponse200
     */
    additional_data?: any;
    /**
     * 
     * @type {AddPersonResponse200RelatedObjects}
     * @memberof ListProductsResponse200
     */
    related_objects?: AddPersonResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface ListProductsResponse200Data
 */
export interface ListProductsResponse200Data {
    /**
     * The array of products
     * @type {Array<ListProductsResponse200DataItems>}
     * @memberof ListProductsResponse200Data
     */
    items?: Array<ListProductsResponse200DataItems>;
}
/**
 * 
 * @export
 * @interface ListProductsResponse200DataItems
 */
export interface ListProductsResponse200DataItems {
    /**
     * The ID of the deal-product (the ID of the product attached to the deal)
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    id?: number;
    /**
     * The ID of the deal
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    deal_id?: number;
    /**
     * The order number of the product
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    order_nr?: number;
    /**
     * The ID of the product
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    product_id?: number;
    /**
     * The ID of the product variation
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    product_variation_id?: number;
    /**
     * The price value of the product
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    item_price?: number;
    /**
     * The discount percentage of the product
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    discount_percentage?: number;
    /**
     * The duration of the product
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    duration?: number;
    /**
     * The type of the duration. (For example hourly, daily, etc.)
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    duration_unit?: string;
    /**
     * The product sum without the discount
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    sum_no_discount?: number;
    /**
     * The sum of all the products attached to the deal
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    sum?: number;
    /**
     * The currency associated with the deal product
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    currency?: string;
    /**
     * Whether the product is enabled or not
     * @type {boolean}
     * @memberof ListProductsResponse200DataItems
     */
    enabled_flag?: boolean;
    /**
     * The date and time when the product was added to the deal
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    add_time?: string;
    /**
     * The date and time when the deal product was last edited
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    last_edit?: string;
    /**
     * The comments of the product
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    comments?: string;
    /**
     * Whether the product is active or not
     * @type {boolean}
     * @memberof ListProductsResponse200DataItems
     */
    active_flag?: boolean;
    /**
     * The product tax
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    tax?: number;
    /**
     * The product name
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    name?: string;
    /**
     * The formatted sum of the product
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    sum_formatted?: string;
    /**
     * The formatted quantity of the product
     * @type {string}
     * @memberof ListProductsResponse200DataItems
     */
    quantity_formatted?: string;
    /**
     * The quantity of the product
     * @type {number}
     * @memberof ListProductsResponse200DataItems
     */
    quantity?: number;
    /**
     * 
     * @type {any}
     * @memberof ListProductsResponse200DataItems
     */
    product?: any;
}
/**
 * 
 * @export
 * @interface MailMessageResponse200
 */
export interface MailMessageResponse200 {
    /**
     * 
     * @type {MailMessageResponse200Data}
     * @memberof MailMessageResponse200
     */
    data?: MailMessageResponse200Data;
}
/**
 * 
 * @export
 * @interface MailMessageResponse200Data
 */
export interface MailMessageResponse200Data {
    /**
     * ID of the mail message.
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    id?: number;
    /**
     * The array of mail message sender (object)
     * @type {Array<MailMessageResponse200DataFrom>}
     * @memberof MailMessageResponse200Data
     */
    from?: Array<MailMessageResponse200DataFrom>;
    /**
     * The array of mail message receiver (object)
     * @type {Array<MailMessageResponse200DataFrom>}
     * @memberof MailMessageResponse200Data
     */
    to?: Array<MailMessageResponse200DataFrom>;
    /**
     * The array of mail message copies (object)
     * @type {Array<MailMessageResponse200DataFrom>}
     * @memberof MailMessageResponse200Data
     */
    cc?: Array<MailMessageResponse200DataFrom>;
    /**
     * The array of mail message blind copies (object)
     * @type {Array<MailMessageResponse200DataFrom>}
     * @memberof MailMessageResponse200Data
     */
    bcc?: Array<MailMessageResponse200DataFrom>;
    /**
     * The mail message body URL
     * @type {string}
     * @memberof MailMessageResponse200Data
     */
    body_url?: string;
    /**
     * The connection account ID
     * @type {string}
     * @memberof MailMessageResponse200Data
     */
    account_id?: string;
    /**
     * ID of the user whom mail message will be assigned to
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    user_id?: number;
    /**
     * ID of the mail message thread
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    mail_thread_id?: number;
    /**
     * The subject of mail message
     * @type {string}
     * @memberof MailMessageResponse200Data
     */
    subject?: string;
    /**
     * The snippet of mail message. Snippet length is up to 225 characters.
     * @type {string}
     * @memberof MailMessageResponse200Data
     */
    snippet?: string;
    /**
     * The status of tracking mail message. Value is `null` if tracking is not enabled.
     * @type {string}
     * @memberof MailMessageResponse200Data
     */
    mail_tracking_status?: MailMessageResponse200Data.MailTrackingStatusEnum;
    /**
     * Whether the link tracking in mail message body is enabled.
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    mail_link_tracking_enabled_flag?: number;
    /**
     * Whether the mail message is read or not by the user
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    read_flag?: number;
    /**
     * If the mail message has a draft status then the value is the mail message object as JSON formatted string, otherwise `null`.
     * @type {string}
     * @memberof MailMessageResponse200Data
     */
    draft?: string;
    /**
     * Whether the mail message is a draft or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    draft_flag?: number;
    /**
     * Whether the mail message is synced with the provider or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    synced_flag?: number;
    /**
     * Whether the mail message is deleted or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    deleted_flag?: number;
    /**
     * Whether the mail message has a body or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    has_body_flag?: number;
    /**
     * Whether the mail message has been sent or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    sent_flag?: number;
    /**
     * Whether the mail message has been sent from Pipedrive app or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    sent_from_pipedrive_flag?: number;
    /**
     * Whether the mail message has been created by Smart Email BCC feature or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    smart_bcc_flag?: number;
    /**
     * Creation or receival time of the mail message
     * @type {Date}
     * @memberof MailMessageResponse200Data
     */
    message_time?: Date;
    /**
     * The insertion into the database time of the mail message
     * @type {Date}
     * @memberof MailMessageResponse200Data
     */
    add_time?: Date;
    /**
     * The updating time in the database of the mail message
     * @type {Date}
     * @memberof MailMessageResponse200Data
     */
    update_time?: Date;
    /**
     * Whether the mail message has an attachment or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    has_attachments_flag?: number;
    /**
     * Whether the mail message has an inline attachment or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    has_inline_attachments_flag?: number;
    /**
     * Whether the mail message has an attachment (which is not inline) or not
     * @type {number}
     * @memberof MailMessageResponse200Data
     */
    has_real_attachments_flag?: number;
}

/**
 * @export
 * @namespace MailMessageResponse200Data
 */
export namespace MailMessageResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum MailTrackingStatusEnum {
        Opened = <any> 'opened',
        NotOpened = <any> 'not opened'
    }
}
/**
 * 
 * @export
 * @interface MailMessageResponse200DataFrom
 */
export interface MailMessageResponse200DataFrom {
    /**
     * ID of the mail participant
     * @type {number}
     * @memberof MailMessageResponse200DataFrom
     */
    id?: number;
    /**
     * Mail address of the mail participant
     * @type {string}
     * @memberof MailMessageResponse200DataFrom
     */
    email_address?: string;
    /**
     * Name of the mail participant
     * @type {string}
     * @memberof MailMessageResponse200DataFrom
     */
    name?: string;
    /**
     * ID of the linked person to the mail message
     * @type {number}
     * @memberof MailMessageResponse200DataFrom
     */
    linked_person_id?: number;
    /**
     * Name of the linked person to the mail message
     * @type {string}
     * @memberof MailMessageResponse200DataFrom
     */
    linked_person_name?: string;
    /**
     * ID of the mail message participant
     * @type {number}
     * @memberof MailMessageResponse200DataFrom
     */
    mail_message_party_id?: number;
}
/**
 * 
 * @export
 * @interface MergeDealsRequest
 */
export interface MergeDealsRequest {
    /**
     * The ID of the deal that the deal will be merged with
     * @type {number}
     * @memberof MergeDealsRequest
     */
    merge_with_id: number;
}
/**
 * 
 * @export
 * @interface MergeDealsResponse200
 */
export interface MergeDealsResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof MergeDealsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof MergeDealsResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface MergeOrganizationsRequest
 */
export interface MergeOrganizationsRequest {
    /**
     * The ID of the organization that the organization will be merged with
     * @type {number}
     * @memberof MergeOrganizationsRequest
     */
    merge_with_id: number;
}
/**
 * 
 * @export
 * @interface MergeOrganizationsResponse200
 */
export interface MergeOrganizationsResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof MergeOrganizationsResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {MergeOrganizationsResponse200Data}
     * @memberof MergeOrganizationsResponse200
     */
    data?: MergeOrganizationsResponse200Data;
}
/**
 * 
 * @export
 * @interface MergeOrganizationsResponse200Data
 */
export interface MergeOrganizationsResponse200Data {
    /**
     * The ID of the merged organization
     * @type {number}
     * @memberof MergeOrganizationsResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface MergePersonsRequest
 */
export interface MergePersonsRequest {
    /**
     * The ID of the person that will not be overwritten. This persons data will be prioritized in case of conflict with the other person.
     * @type {number}
     * @memberof MergePersonsRequest
     */
    merge_with_id: number;
}
/**
 * 
 * @export
 * @interface MergePersonsResponse200
 */
export interface MergePersonsResponse200 {
    /**
     * 
     * @type {any}
     * @memberof MergePersonsResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface MessagesReceiveBody
 */
export interface MessagesReceiveBody {
    /**
     * The ID of the message
     * @type {string}
     * @memberof MessagesReceiveBody
     */
    id: string;
    /**
     * The channel ID as in the provider
     * @type {string}
     * @memberof MessagesReceiveBody
     */
    channel_id: string;
    /**
     * The ID of the provider's user that sent the message
     * @type {string}
     * @memberof MessagesReceiveBody
     */
    sender_id: string;
    /**
     * The ID of the conversation
     * @type {string}
     * @memberof MessagesReceiveBody
     */
    conversation_id: string;
    /**
     * The body of the message
     * @type {string}
     * @memberof MessagesReceiveBody
     */
    message: string;
    /**
     * The status of the message
     * @type {string}
     * @memberof MessagesReceiveBody
     */
    status: MessagesReceiveBody.StatusEnum;
    /**
     * The date and time when the message was created in the provider, in UTC. Format: YYYY-MM-DD HH:MM
     * @type {Date}
     * @memberof MessagesReceiveBody
     */
    created_at: Date;
    /**
     * The date and time when the message can no longer receive a reply, in UTC. Format: YYYY-MM-DD HH:MM
     * @type {Date}
     * @memberof MessagesReceiveBody
     */
    reply_by?: Date;
    /**
     * A URL that can open the conversation in the provider's side
     * @type {string}
     * @memberof MessagesReceiveBody
     */
    conversation_link?: string;
    /**
     * The list of attachments available in the message
     * @type {Array<ChannelsmessagesreceiveAttachments>}
     * @memberof MessagesReceiveBody
     */
    attachments?: Array<ChannelsmessagesreceiveAttachments>;
}

/**
 * @export
 * @namespace MessagesReceiveBody
 */
export namespace MessagesReceiveBody {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Sent = <any> 'sent',
        Delivered = <any> 'delivered',
        Read = <any> 'read',
        Failed = <any> 'failed'
    }
}
/**
 * 
 * @export
 * @interface NewFollowerResponse200
 */
export interface NewFollowerResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof NewFollowerResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {NewFollowerResponse200Data}
     * @memberof NewFollowerResponse200
     */
    data?: NewFollowerResponse200Data;
}
/**
 * 
 * @export
 * @interface NewFollowerResponse200Data
 */
export interface NewFollowerResponse200Data {
    /**
     * The ID of the user that was added as follower
     * @type {number}
     * @memberof NewFollowerResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the follower
     * @type {number}
     * @memberof NewFollowerResponse200Data
     */
    id?: number;
    /**
     * The ID of the product
     * @type {number}
     * @memberof NewFollowerResponse200Data
     */
    product_id?: number;
    /**
     * The follower creation time. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof NewFollowerResponse200Data
     */
    add_time?: string;
}
/**
 * 
 * @export
 * @interface NoteRequest
 */
export interface NoteRequest {
    /**
     * The ID of the lead the note will be attached to
     * @type {string}
     * @memberof NoteRequest
     */
    lead_id?: string;
    /**
     * The ID of the deal the note will be attached to
     * @type {number}
     * @memberof NoteRequest
     */
    deal_id?: number;
    /**
     * The ID of the person the note will be attached to
     * @type {number}
     * @memberof NoteRequest
     */
    person_id?: number;
    /**
     * The ID of the organization the note will be attached to
     * @type {number}
     * @memberof NoteRequest
     */
    org_id?: number;
    /**
     * The ID of the user who will be marked as the author of the note. Only an admin can change the author.
     * @type {number}
     * @memberof NoteRequest
     */
    user_id?: number;
    /**
     * The optional creation date & time of the note in UTC. Can be set in the past or in the future. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof NoteRequest
     */
    add_time?: string;
    /**
     * If set, the results are filtered by note to lead pinning state (`lead_id` is also required)
     * @type {number}
     * @memberof NoteRequest
     */
    pinned_to_lead_flag?: number;
    /**
     * If set, the results are filtered by note to deal pinning state (`deal_id` is also required)
     * @type {number}
     * @memberof NoteRequest
     */
    pinned_to_deal_flag?: number;
    /**
     * If set, the results are filtered by note to organization pinning state (`org_id` is also required)
     * @type {number}
     * @memberof NoteRequest
     */
    pinned_to_organization_flag?: number;
    /**
     * If set, the results are filtered by note to person pinning state (`person_id` is also required)
     * @type {number}
     * @memberof NoteRequest
     */
    pinned_to_person_flag?: number;
}
/**
 * 
 * @export
 * @interface NotesBody
 */
export interface NotesBody {
    /**
     * The ID of the user who will be marked as the author of the note. Only an admin can change the author.
     * @type {number}
     * @memberof NotesBody
     */
    user_id?: number;
    /**
     * The optional creation date & time of the note in UTC. Can be set in the past or in the future. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof NotesBody
     */
    add_time?: string;
    /**
     * If set, the results are filtered by note to lead pinning state (`lead_id` is also required)
     * @type {number}
     * @memberof NotesBody
     */
    pinned_to_lead_flag?: number;
    /**
     * If set, the results are filtered by note to deal pinning state (`deal_id` is also required)
     * @type {number}
     * @memberof NotesBody
     */
    pinned_to_deal_flag?: number;
    /**
     * If set, the results are filtered by note to organization pinning state (`org_id` is also required)
     * @type {number}
     * @memberof NotesBody
     */
    pinned_to_organization_flag?: number;
    /**
     * If set, the results are filtered by note to person pinning state (`person_id` is also required)
     * @type {number}
     * @memberof NotesBody
     */
    pinned_to_person_flag?: number;
}
/**
 * 
 * @export
 * @interface OneCommentResponse200
 */
export interface OneCommentResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof OneCommentResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {GetCommentsResponse200Data}
     * @memberof OneCommentResponse200
     */
    data?: GetCommentsResponse200Data;
}
/**
 * 
 * @export
 * @interface OneLeadResponse200
 */
export interface OneLeadResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof OneLeadResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {OneLeadResponse200Data}
     * @memberof OneLeadResponse200
     */
    data?: OneLeadResponse200Data;
}
/**
 * 
 * @export
 * @interface OneLeadResponse200Data
 */
export interface OneLeadResponse200Data {
    /**
     * The unique ID of the lead in the UUID format
     * @type {string}
     * @memberof OneLeadResponse200Data
     */
    id?: string;
    /**
     * The title of the lead
     * @type {string}
     * @memberof OneLeadResponse200Data
     */
    title?: string;
    /**
     * The ID of the user who owns the lead
     * @type {number}
     * @memberof OneLeadResponse200Data
     */
    owner_id?: number;
    /**
     * The ID of the user who created the lead
     * @type {number}
     * @memberof OneLeadResponse200Data
     */
    creator_id?: number;
    /**
     * The IDs of the lead labels which are associated with the lead
     * @type {Array<string>}
     * @memberof OneLeadResponse200Data
     */
    label_ids?: Array<string>;
    /**
     * The ID of a person which this lead is linked to
     * @type {number}
     * @memberof OneLeadResponse200Data
     */
    person_id?: number;
    /**
     * The ID of an organization which this lead is linked to
     * @type {number}
     * @memberof OneLeadResponse200Data
     */
    organization_id?: number;
    /**
     * Defines where the lead comes from. Will be `API` if the lead was created through the Public API and will be `Manually created` if the lead was created manually through the UI. 
     * @type {string}
     * @memberof OneLeadResponse200Data
     */
    source_name?: string;
    /**
     * A flag indicating whether the lead is archived or not
     * @type {boolean}
     * @memberof OneLeadResponse200Data
     */
    is_archived?: boolean;
    /**
     * A flag indicating whether the lead was seen by someone in the Pipedrive UI
     * @type {boolean}
     * @memberof OneLeadResponse200Data
     */
    was_seen?: boolean;
    /**
     * 
     * @type {LeadsValue}
     * @memberof OneLeadResponse200Data
     */
    value?: LeadsValue;
    /**
     * The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof OneLeadResponse200Data
     */
    expected_close_date?: string;
    /**
     * The ID of the next activity associated with the lead
     * @type {number}
     * @memberof OneLeadResponse200Data
     */
    next_activity_id?: number;
    /**
     * The date and time of when the lead was created. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {Date}
     * @memberof OneLeadResponse200Data
     */
    add_time?: Date;
    /**
     * The date and time of when the lead was last updated. In ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
     * @type {Date}
     * @memberof OneLeadResponse200Data
     */
    update_time?: Date;
    /**
     * The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers (private)</td></tr><tr><td>`3`</td><td>Entire company (shared)</td></tr></table>
     * @type {string}
     * @memberof OneLeadResponse200Data
     */
    visible_to?: string;
    /**
     * The BCC email of the lead
     * @type {string}
     * @memberof OneLeadResponse200Data
     */
    cc_email?: string;
}
/**
 * 
 * @export
 * @interface OneNoteResponse200
 */
export interface OneNoteResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof OneNoteResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {GetNotesResponse200Data}
     * @memberof OneNoteResponse200
     */
    data?: GetNotesResponse200Data;
}
/**
 * 
 * @export
 * @interface OrganizationRelationship
 */
export interface OrganizationRelationship {
    /**
     * The ID of the base organization for the returned calculated values
     * @type {number}
     * @memberof OrganizationRelationship
     */
    org_id?: number;
    /**
     * The type of organization relationship
     * @type {string}
     * @memberof OrganizationRelationship
     */
    type?: OrganizationRelationship.TypeEnum;
    /**
     * The owner of this relationship. If type is `parent`, then the owner is the parent and the linked organization is the daughter.
     * @type {number}
     * @memberof OrganizationRelationship
     */
    rel_owner_org_id?: number;
    /**
     * The linked organization in this relationship. If type is `parent`, then the linked organization is the daughter.
     * @type {number}
     * @memberof OrganizationRelationship
     */
    rel_linked_org_id?: number;
}

/**
 * @export
 * @namespace OrganizationRelationship
 */
export namespace OrganizationRelationship {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Parent = <any> 'parent',
        Related = <any> 'related'
    }
}
/**
 * 
 * @export
 * @interface PaymentResponse200
 */
export interface PaymentResponse200 {
    /**
     * 
     * @type {Array<PaymentResponse200Data>}
     * @memberof PaymentResponse200
     */
    data?: Array<PaymentResponse200Data>;
}
/**
 * 
 * @export
 * @interface PaymentResponse200Data
 */
export interface PaymentResponse200Data {
    /**
     * The ID of the payment
     * @type {number}
     * @memberof PaymentResponse200Data
     */
    id?: number;
    /**
     * The ID of the subscription this payment is associated with
     * @type {number}
     * @memberof PaymentResponse200Data
     */
    subscription_id?: number;
    /**
     * The ID of the deal this payment is associated with
     * @type {number}
     * @memberof PaymentResponse200Data
     */
    deal_id?: number;
    /**
     * The payment status
     * @type {boolean}
     * @memberof PaymentResponse200Data
     */
    is_active?: boolean;
    /**
     * The payment amount
     * @type {number}
     * @memberof PaymentResponse200Data
     */
    amount?: number;
    /**
     * The currency of the payment
     * @type {string}
     * @memberof PaymentResponse200Data
     */
    currency?: string;
    /**
     * The difference between the amount of the current payment and the previous payment. The value can be either positive or negative.
     * @type {number}
     * @memberof PaymentResponse200Data
     */
    change_amount?: number;
    /**
     * The date when payment occurs
     * @type {string}
     * @memberof PaymentResponse200Data
     */
    due_at?: string;
    /**
     * Represents the movement of revenue in comparison with the previous payment. Possible values are: `New` - first payment of the subscription. `Recurring` - no movement. `Expansion` - current payment amount > previous payment amount. `Contraction` - current payment amount < previous payment amount. `Churn` - last payment of the subscription.
     * @type {string}
     * @memberof PaymentResponse200Data
     */
    revenue_movement_type?: PaymentResponse200Data.RevenueMovementTypeEnum;
    /**
     * The type of the payment. Possible values are: `Recurring` - payments occur over fixed intervals of time, `Additional` - extra payment not the recurring payment of the recurring subscription, `Installment` - payment of the installment subscription.
     * @type {string}
     * @memberof PaymentResponse200Data
     */
    payment_type?: PaymentResponse200Data.PaymentTypeEnum;
    /**
     * The description of the payment
     * @type {string}
     * @memberof PaymentResponse200Data
     */
    description?: string;
    /**
     * The creation time of the payment
     * @type {string}
     * @memberof PaymentResponse200Data
     */
    add_time?: string;
    /**
     * The update time of the payment
     * @type {string}
     * @memberof PaymentResponse200Data
     */
    update_time?: string;
}

/**
 * @export
 * @namespace PaymentResponse200Data
 */
export namespace PaymentResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum RevenueMovementTypeEnum {
        New = <any> 'new',
        Recurring = <any> 'recurring',
        Expansion = <any> 'expansion',
        Contraction = <any> 'contraction',
        None = <any> 'none',
        Churn = <any> 'churn'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentTypeEnum {
        Recurring = <any> 'recurring',
        Additional = <any> 'additional',
        Installment = <any> 'installment'
    }
}
/**
 * 
 * @export
 * @interface PersonsEmail
 */
export interface PersonsEmail {
    /**
     * The email
     * @type {string}
     * @memberof PersonsEmail
     */
    value?: string;
    /**
     * Boolean that indicates if email is primary for the person or not
     * @type {boolean}
     * @memberof PersonsEmail
     */
    primary?: boolean;
    /**
     * The label that indicates the type of the email. (Possible values - work, home or other)
     * @type {string}
     * @memberof PersonsEmail
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface PersonsPhone
 */
export interface PersonsPhone {
    /**
     * The phone number
     * @type {string}
     * @memberof PersonsPhone
     */
    value?: string;
    /**
     * Boolean that indicates if phone number is primary for the person or not
     * @type {boolean}
     * @memberof PersonsPhone
     */
    primary?: boolean;
    /**
     * The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)
     * @type {string}
     * @memberof PersonsPhone
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface PipelineRequest
 */
export interface PipelineRequest {
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof PipelineRequest
     */
    name: string;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {number}
     * @memberof PipelineRequest
     */
    deal_probability?: number;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof PipelineRequest
     */
    order_nr?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {number}
     * @memberof PipelineRequest
     */
    active?: number;
}
/**
 * 
 * @export
 * @interface PipelineRequest1
 */
export interface PipelineRequest1 {
    /**
     * The name of the pipeline
     * @type {string}
     * @memberof PipelineRequest1
     */
    name?: string;
    /**
     * Whether deal probability is disabled or enabled for this pipeline
     * @type {number}
     * @memberof PipelineRequest1
     */
    deal_probability?: number;
    /**
     * Defines the order of pipelines. First order (`order_nr=0`) is the default pipeline.
     * @type {number}
     * @memberof PipelineRequest1
     */
    order_nr?: number;
    /**
     * Whether this pipeline will be made inactive (hidden) or active
     * @type {number}
     * @memberof PipelineRequest1
     */
    active?: number;
}
/**
 * 
 * @export
 * @interface PostFilterResponse200
 */
export interface PostFilterResponse200 {
    /**
     * 
     * @type {PostFilterResponse200Data}
     * @memberof PostFilterResponse200
     */
    data?: PostFilterResponse200Data;
}
/**
 * 
 * @export
 * @interface PostFilterResponse200Data
 */
export interface PostFilterResponse200Data {
    /**
     * The ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200Data
     */
    id?: number;
    /**
     * The name of the created filter
     * @type {string}
     * @memberof PostFilterResponse200Data
     */
    name?: string;
    /**
     * The activity flag of the created filter
     * @type {boolean}
     * @memberof PostFilterResponse200Data
     */
    active_flag?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostFilterResponse200Data
     */
    type?: PostFilterResponse200Data.TypeEnum;
    /**
     * If the created filter is temporary or not
     * @type {boolean}
     * @memberof PostFilterResponse200Data
     */
    temporary_flag?: boolean;
    /**
     * The user ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200Data
     */
    user_id?: number;
    /**
     * The add time of the created filter
     * @type {string}
     * @memberof PostFilterResponse200Data
     */
    add_time?: string;
    /**
     * The update time of the created filter
     * @type {string}
     * @memberof PostFilterResponse200Data
     */
    update_time?: string;
    /**
     * The visibility group ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200Data
     */
    visible_to?: number;
    /**
     * The custom view ID of the created filter
     * @type {number}
     * @memberof PostFilterResponse200Data
     */
    custom_view_id?: number;
    /**
     * The created filter conditions object
     * @type {any}
     * @memberof PostFilterResponse200Data
     */
    conditions?: any;
}

/**
 * @export
 * @namespace PostFilterResponse200Data
 */
export namespace PostFilterResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Deals = <any> 'deals',
        Leads = <any> 'leads',
        Org = <any> 'org',
        People = <any> 'people',
        Products = <any> 'products',
        Activity = <any> 'activity'
    }
}
/**
 * 
 * @export
 * @interface ProductFieldsBody
 */
export interface ProductFieldsBody {
    /**
     * The name of the field
     * @type {string}
     * @memberof ProductFieldsBody
     */
    name: string;
    /**
     * When `field_type` is either `set` or `enum`, possible options must be supplied as a JSON-encoded sequential array, for example:</br>`[{\"label\":\"red\"}, {\"label\":\"blue\"}, {\"label\":\"lilac\"}]`
     * @type {Array<any>}
     * @memberof ProductFieldsBody
     */
    options?: Array<any>;
    /**
     * The type of the field<table><tr><th>Value</th><th>Description</th></tr><tr><td>`varchar`</td><td>Text (up to 255 characters)</td><tr><td>`varchar_auto`</td><td>Autocomplete text (up to 255 characters)</td><tr><td>`text`</td><td>Long text (up to 65k characters)</td><tr><td>`double`</td><td>Numeric value</td><tr><td>`monetary`</td><td>Monetary field (has a numeric value and a currency value)</td><tr><td>`date`</td><td>Date (format YYYY-MM-DD)</td><tr><td>`set`</td><td>Options field with a possibility of having multiple chosen options</td><tr><td>`enum`</td><td>Options field with a single possible chosen option</td><tr><td>`user`</td><td>User field (contains a user ID of another Pipedrive user)</td><tr><td>`org`</td><td>Organization field (contains an organization ID which is stored on the same account)</td><tr><td>`people`</td><td>Person field (contains a product ID which is stored on the same account)</td><tr><td>`phone`</td><td>Phone field (up to 255 numbers and/or characters)</td><tr><td>`time`</td><td>Time field (format HH:MM:SS)</td><tr><td>`timerange`</td><td>Time-range field (has a start time and end time value, both HH:MM:SS)</td><tr><td>`daterange`</td><td>Date-range field (has a start date and end date value, both YYYY-MM-DD)</td><tr><td>`address`</td><td>Address field (autocompleted by Google Maps)</dd></table>
     * @type {string}
     * @memberof ProductFieldsBody
     */
    field_type: ProductFieldsBody.FieldTypeEnum;
}

/**
 * @export
 * @namespace ProductFieldsBody
 */
export namespace ProductFieldsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldTypeEnum {
        Varchar = <any> 'varchar',
        VarcharAuto = <any> 'varchar_auto',
        Text = <any> 'text',
        Double = <any> 'double',
        Monetary = <any> 'monetary',
        Date = <any> 'date',
        Set = <any> 'set',
        Enum = <any> 'enum',
        User = <any> 'user',
        Org = <any> 'org',
        People = <any> 'people',
        Phone = <any> 'phone',
        Time = <any> 'time',
        Timerange = <any> 'timerange',
        Daterange = <any> 'daterange',
        Address = <any> 'address'
    }
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200
 */
export interface SearchDealsResponse200 {
    /**
     * 
     * @type {SearchDealsResponse200Data}
     * @memberof SearchDealsResponse200
     */
    data?: SearchDealsResponse200Data;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof SearchDealsResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200Data
 */
export interface SearchDealsResponse200Data {
    /**
     * The array of deals
     * @type {Array<SearchDealsResponse200DataItems>}
     * @memberof SearchDealsResponse200Data
     */
    items?: Array<SearchDealsResponse200DataItems>;
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200DataItem
 */
export interface SearchDealsResponse200DataItem {
    /**
     * The ID of the deal
     * @type {number}
     * @memberof SearchDealsResponse200DataItem
     */
    id?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchDealsResponse200DataItem
     */
    type?: string;
    /**
     * The title of the deal
     * @type {string}
     * @memberof SearchDealsResponse200DataItem
     */
    title?: string;
    /**
     * The value of the deal
     * @type {number}
     * @memberof SearchDealsResponse200DataItem
     */
    value?: number;
    /**
     * The currency of the deal
     * @type {string}
     * @memberof SearchDealsResponse200DataItem
     */
    currency?: string;
    /**
     * The status of the deal
     * @type {string}
     * @memberof SearchDealsResponse200DataItem
     */
    status?: string;
    /**
     * The visibility of the deal
     * @type {number}
     * @memberof SearchDealsResponse200DataItem
     */
    visible_to?: number;
    /**
     * 
     * @type {SearchDealsResponse200DataItemOwner}
     * @memberof SearchDealsResponse200DataItem
     */
    owner?: SearchDealsResponse200DataItemOwner;
    /**
     * 
     * @type {SearchDealsResponse200DataItemStage}
     * @memberof SearchDealsResponse200DataItem
     */
    stage?: SearchDealsResponse200DataItemStage;
    /**
     * 
     * @type {SearchDealsResponse200DataItemPerson}
     * @memberof SearchDealsResponse200DataItem
     */
    person?: SearchDealsResponse200DataItemPerson;
    /**
     * 
     * @type {SearchDealsResponse200DataItemOrganization}
     * @memberof SearchDealsResponse200DataItem
     */
    organization?: SearchDealsResponse200DataItemOrganization;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchDealsResponse200DataItem
     */
    custom_fields?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchDealsResponse200DataItem
     */
    notes?: Array<string>;
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200DataItemOrganization
 */
export interface SearchDealsResponse200DataItemOrganization {
    /**
     * The ID of the organization the deal is associated with
     * @type {number}
     * @memberof SearchDealsResponse200DataItemOrganization
     */
    id?: number;
    /**
     * The name of the organization the deal is associated with
     * @type {string}
     * @memberof SearchDealsResponse200DataItemOrganization
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200DataItemOwner
 */
export interface SearchDealsResponse200DataItemOwner {
    /**
     * The ID of the owner of the deal
     * @type {number}
     * @memberof SearchDealsResponse200DataItemOwner
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200DataItemPerson
 */
export interface SearchDealsResponse200DataItemPerson {
    /**
     * The ID of the person the deal is associated with
     * @type {number}
     * @memberof SearchDealsResponse200DataItemPerson
     */
    id?: number;
    /**
     * The name of the person the deal is associated with
     * @type {string}
     * @memberof SearchDealsResponse200DataItemPerson
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200DataItemStage
 */
export interface SearchDealsResponse200DataItemStage {
    /**
     * The ID of the stage of the deal
     * @type {number}
     * @memberof SearchDealsResponse200DataItemStage
     */
    id?: number;
    /**
     * The name of the stage of the deal
     * @type {string}
     * @memberof SearchDealsResponse200DataItemStage
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SearchDealsResponse200DataItems
 */
export interface SearchDealsResponse200DataItems {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchDealsResponse200DataItems
     */
    result_score?: number;
    /**
     * 
     * @type {SearchDealsResponse200DataItem}
     * @memberof SearchDealsResponse200DataItems
     */
    item?: SearchDealsResponse200DataItem;
}
/**
 * 
 * @export
 * @interface SearchItemByFieldResponse200
 */
export interface SearchItemByFieldResponse200 {
    /**
     * The array of results
     * @type {Array<SearchItemByFieldResponse200Data>}
     * @memberof SearchItemByFieldResponse200
     */
    data?: Array<SearchItemByFieldResponse200Data>;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof SearchItemByFieldResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface SearchItemByFieldResponse200Data
 */
export interface SearchItemByFieldResponse200Data {
    /**
     * The ID of the item
     * @type {number}
     * @memberof SearchItemByFieldResponse200Data
     */
    id?: number;
    /**
     * The value of the searched `field_key`
     * @type {any}
     * @memberof SearchItemByFieldResponse200Data
     */
    field_key?: any;
}
/**
 * 
 * @export
 * @interface SearchItemResponse200
 */
export interface SearchItemResponse200 {
    /**
     * 
     * @type {SearchItemResponse200Data}
     * @memberof SearchItemResponse200
     */
    data?: SearchItemResponse200Data;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof SearchItemResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface SearchItemResponse200Data
 */
export interface SearchItemResponse200Data {
    /**
     * The array of found items
     * @type {Array<SearchItemResponse200DataItems>}
     * @memberof SearchItemResponse200Data
     */
    items?: Array<SearchItemResponse200DataItems>;
    /**
     * The array of related items if `search_for_related_items` was enabled
     * @type {Array<SearchItemResponse200DataItems>}
     * @memberof SearchItemResponse200Data
     */
    related_items?: Array<SearchItemResponse200DataItems>;
}
/**
 * 
 * @export
 * @interface SearchItemResponse200DataItems
 */
export interface SearchItemResponse200DataItems {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchItemResponse200DataItems
     */
    result_score?: number;
    /**
     * Item
     * @type {any}
     * @memberof SearchItemResponse200DataItems
     */
    item?: any;
}
/**
 * 
 * @export
 * @interface SearchLeadsResponse200
 */
export interface SearchLeadsResponse200 {
    /**
     * 
     * @type {SearchLeadsResponse200Data}
     * @memberof SearchLeadsResponse200
     */
    data?: SearchLeadsResponse200Data;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof SearchLeadsResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface SearchLeadsResponse200Data
 */
export interface SearchLeadsResponse200Data {
    /**
     * The array of leads
     * @type {Array<SearchLeadsResponse200DataItems>}
     * @memberof SearchLeadsResponse200Data
     */
    items?: Array<SearchLeadsResponse200DataItems>;
}
/**
 * 
 * @export
 * @interface SearchLeadsResponse200DataItem
 */
export interface SearchLeadsResponse200DataItem {
    /**
     * The ID of the lead
     * @type {string}
     * @memberof SearchLeadsResponse200DataItem
     */
    id?: string;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchLeadsResponse200DataItem
     */
    type?: string;
    /**
     * The title of the lead
     * @type {string}
     * @memberof SearchLeadsResponse200DataItem
     */
    title?: string;
    /**
     * 
     * @type {SearchLeadsResponse200DataItemOwner}
     * @memberof SearchLeadsResponse200DataItem
     */
    owner?: SearchLeadsResponse200DataItemOwner;
    /**
     * 
     * @type {SearchLeadsResponse200DataItemPerson}
     * @memberof SearchLeadsResponse200DataItem
     */
    person?: SearchLeadsResponse200DataItemPerson;
    /**
     * 
     * @type {SearchLeadsResponse200DataItemOrganization}
     * @memberof SearchLeadsResponse200DataItem
     */
    organization?: SearchLeadsResponse200DataItemOrganization;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200DataItem
     */
    phones?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200DataItem
     */
    emails?: Array<string>;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200DataItem
     */
    custom_fields?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchLeadsResponse200DataItem
     */
    notes?: Array<string>;
    /**
     * The value of the lead
     * @type {number}
     * @memberof SearchLeadsResponse200DataItem
     */
    value?: number;
    /**
     * The currency of the lead
     * @type {string}
     * @memberof SearchLeadsResponse200DataItem
     */
    currency?: string;
    /**
     * The visibility of the lead
     * @type {number}
     * @memberof SearchLeadsResponse200DataItem
     */
    visible_to?: number;
    /**
     * A flag indicating whether the lead is archived or not
     * @type {boolean}
     * @memberof SearchLeadsResponse200DataItem
     */
    is_archived?: boolean;
}
/**
 * 
 * @export
 * @interface SearchLeadsResponse200DataItemOrganization
 */
export interface SearchLeadsResponse200DataItemOrganization {
    /**
     * The ID of the organization the lead is associated with
     * @type {number}
     * @memberof SearchLeadsResponse200DataItemOrganization
     */
    id?: number;
    /**
     * The name of the organization the lead is associated with
     * @type {string}
     * @memberof SearchLeadsResponse200DataItemOrganization
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SearchLeadsResponse200DataItemOwner
 */
export interface SearchLeadsResponse200DataItemOwner {
    /**
     * The ID of the owner of the lead
     * @type {number}
     * @memberof SearchLeadsResponse200DataItemOwner
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface SearchLeadsResponse200DataItemPerson
 */
export interface SearchLeadsResponse200DataItemPerson {
    /**
     * The ID of the person the lead is associated with
     * @type {number}
     * @memberof SearchLeadsResponse200DataItemPerson
     */
    id?: number;
    /**
     * The name of the person the lead is associated with
     * @type {string}
     * @memberof SearchLeadsResponse200DataItemPerson
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SearchLeadsResponse200DataItems
 */
export interface SearchLeadsResponse200DataItems {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchLeadsResponse200DataItems
     */
    result_score?: number;
    /**
     * 
     * @type {SearchLeadsResponse200DataItem}
     * @memberof SearchLeadsResponse200DataItems
     */
    item?: SearchLeadsResponse200DataItem;
}
/**
 * 
 * @export
 * @interface SearchOrganizationResponse200
 */
export interface SearchOrganizationResponse200 {
    /**
     * 
     * @type {SearchOrganizationResponse200Data}
     * @memberof SearchOrganizationResponse200
     */
    data?: SearchOrganizationResponse200Data;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof SearchOrganizationResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface SearchOrganizationResponse200Data
 */
export interface SearchOrganizationResponse200Data {
    /**
     * The array of found items
     * @type {Array<SearchOrganizationResponse200DataItems>}
     * @memberof SearchOrganizationResponse200Data
     */
    items?: Array<SearchOrganizationResponse200DataItems>;
}
/**
 * 
 * @export
 * @interface SearchOrganizationResponse200DataItem
 */
export interface SearchOrganizationResponse200DataItem {
    /**
     * The ID of the organization
     * @type {number}
     * @memberof SearchOrganizationResponse200DataItem
     */
    id?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchOrganizationResponse200DataItem
     */
    type?: string;
    /**
     * The name of the organization
     * @type {string}
     * @memberof SearchOrganizationResponse200DataItem
     */
    name?: string;
    /**
     * The address of the organization
     * @type {string}
     * @memberof SearchOrganizationResponse200DataItem
     */
    address?: string;
    /**
     * The visibility of the organization
     * @type {number}
     * @memberof SearchOrganizationResponse200DataItem
     */
    visible_to?: number;
    /**
     * 
     * @type {SearchDealsResponse200DataItemOwner}
     * @memberof SearchOrganizationResponse200DataItem
     */
    owner?: SearchDealsResponse200DataItemOwner;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchOrganizationResponse200DataItem
     */
    custom_fields?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchOrganizationResponse200DataItem
     */
    notes?: Array<string>;
}
/**
 * 
 * @export
 * @interface SearchOrganizationResponse200DataItems
 */
export interface SearchOrganizationResponse200DataItems {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchOrganizationResponse200DataItems
     */
    result_score?: number;
    /**
     * 
     * @type {SearchOrganizationResponse200DataItem}
     * @memberof SearchOrganizationResponse200DataItems
     */
    item?: SearchOrganizationResponse200DataItem;
}
/**
 * 
 * @export
 * @interface SearchPersonsResponse200
 */
export interface SearchPersonsResponse200 {
    /**
     * 
     * @type {SearchPersonsResponse200Data}
     * @memberof SearchPersonsResponse200
     */
    data?: SearchPersonsResponse200Data;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof SearchPersonsResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface SearchPersonsResponse200AdditionalData
 */
export interface SearchPersonsResponse200AdditionalData {
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalDataPagination}
     * @memberof SearchPersonsResponse200AdditionalData
     */
    pagination?: SearchPersonsResponse200AdditionalDataPagination;
}
/**
 * Pagination details of the list
 * @export
 * @interface SearchPersonsResponse200AdditionalDataPagination
 */
export interface SearchPersonsResponse200AdditionalDataPagination {
    /**
     * Pagination start
     * @type {number}
     * @memberof SearchPersonsResponse200AdditionalDataPagination
     */
    start?: number;
    /**
     * Items shown per page
     * @type {number}
     * @memberof SearchPersonsResponse200AdditionalDataPagination
     */
    limit?: number;
    /**
     * Whether there are more list items in the collection than displayed
     * @type {boolean}
     * @memberof SearchPersonsResponse200AdditionalDataPagination
     */
    more_items_in_collection?: boolean;
    /**
     * Next pagination start
     * @type {number}
     * @memberof SearchPersonsResponse200AdditionalDataPagination
     */
    next_start?: number;
}
/**
 * 
 * @export
 * @interface SearchPersonsResponse200Data
 */
export interface SearchPersonsResponse200Data {
    /**
     * The array of found items
     * @type {Array<SearchPersonsResponse200DataItems>}
     * @memberof SearchPersonsResponse200Data
     */
    items?: Array<SearchPersonsResponse200DataItems>;
}
/**
 * 
 * @export
 * @interface SearchPersonsResponse200DataItem
 */
export interface SearchPersonsResponse200DataItem {
    /**
     * The ID of the person
     * @type {number}
     * @memberof SearchPersonsResponse200DataItem
     */
    id?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchPersonsResponse200DataItem
     */
    type?: string;
    /**
     * The name of the person
     * @type {string}
     * @memberof SearchPersonsResponse200DataItem
     */
    name?: string;
    /**
     * An array of phone numbers
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200DataItem
     */
    phones?: Array<string>;
    /**
     * An array of email addresses
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200DataItem
     */
    emails?: Array<string>;
    /**
     * The visibility of the person
     * @type {number}
     * @memberof SearchPersonsResponse200DataItem
     */
    visible_to?: number;
    /**
     * 
     * @type {SearchPersonsResponse200DataItemOwner}
     * @memberof SearchPersonsResponse200DataItem
     */
    owner?: SearchPersonsResponse200DataItemOwner;
    /**
     * 
     * @type {SearchPersonsResponse200DataItemOrganization}
     * @memberof SearchPersonsResponse200DataItem
     */
    organization?: SearchPersonsResponse200DataItemOrganization;
    /**
     * Custom fields
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200DataItem
     */
    custom_fields?: Array<string>;
    /**
     * An array of notes
     * @type {Array<string>}
     * @memberof SearchPersonsResponse200DataItem
     */
    notes?: Array<string>;
}
/**
 * 
 * @export
 * @interface SearchPersonsResponse200DataItemOrganization
 */
export interface SearchPersonsResponse200DataItemOrganization {
    /**
     * The ID of the organization the person is associated with
     * @type {number}
     * @memberof SearchPersonsResponse200DataItemOrganization
     */
    id?: number;
    /**
     * The name of the organization the person is associated with
     * @type {string}
     * @memberof SearchPersonsResponse200DataItemOrganization
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SearchPersonsResponse200DataItemOwner
 */
export interface SearchPersonsResponse200DataItemOwner {
    /**
     * The ID of the owner of the person
     * @type {number}
     * @memberof SearchPersonsResponse200DataItemOwner
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface SearchPersonsResponse200DataItems
 */
export interface SearchPersonsResponse200DataItems {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchPersonsResponse200DataItems
     */
    result_score?: number;
    /**
     * 
     * @type {SearchPersonsResponse200DataItem}
     * @memberof SearchPersonsResponse200DataItems
     */
    item?: SearchPersonsResponse200DataItem;
}
/**
 * 
 * @export
 * @interface SearchProductsResponse200
 */
export interface SearchProductsResponse200 {
    /**
     * 
     * @type {SearchProductsResponse200Data}
     * @memberof SearchProductsResponse200
     */
    data?: SearchProductsResponse200Data;
    /**
     * 
     * @type {SearchPersonsResponse200AdditionalData}
     * @memberof SearchProductsResponse200
     */
    additional_data?: SearchPersonsResponse200AdditionalData;
}
/**
 * 
 * @export
 * @interface SearchProductsResponse200Data
 */
export interface SearchProductsResponse200Data {
    /**
     * The array of found items
     * @type {Array<SearchProductsResponse200DataItems>}
     * @memberof SearchProductsResponse200Data
     */
    items?: Array<SearchProductsResponse200DataItems>;
}
/**
 * 
 * @export
 * @interface SearchProductsResponse200DataItem
 */
export interface SearchProductsResponse200DataItem {
    /**
     * The ID of the product
     * @type {number}
     * @memberof SearchProductsResponse200DataItem
     */
    id?: number;
    /**
     * The type of the item
     * @type {string}
     * @memberof SearchProductsResponse200DataItem
     */
    type?: string;
    /**
     * The name of the product
     * @type {string}
     * @memberof SearchProductsResponse200DataItem
     */
    name?: string;
    /**
     * The code of the product
     * @type {number}
     * @memberof SearchProductsResponse200DataItem
     */
    code?: number;
    /**
     * The visibility of the product
     * @type {number}
     * @memberof SearchProductsResponse200DataItem
     */
    visible_to?: number;
    /**
     * 
     * @type {SearchProductsResponse200DataItemOwner}
     * @memberof SearchProductsResponse200DataItem
     */
    owner?: SearchProductsResponse200DataItemOwner;
    /**
     * The custom fields
     * @type {Array<string>}
     * @memberof SearchProductsResponse200DataItem
     */
    custom_fields?: Array<string>;
}
/**
 * 
 * @export
 * @interface SearchProductsResponse200DataItemOwner
 */
export interface SearchProductsResponse200DataItemOwner {
    /**
     * The ID of the owner of the product
     * @type {number}
     * @memberof SearchProductsResponse200DataItemOwner
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface SearchProductsResponse200DataItems
 */
export interface SearchProductsResponse200DataItems {
    /**
     * Search result relevancy
     * @type {number}
     * @memberof SearchProductsResponse200DataItems
     */
    result_score?: number;
    /**
     * 
     * @type {SearchProductsResponse200DataItem}
     * @memberof SearchProductsResponse200DataItems
     */
    item?: SearchProductsResponse200DataItem;
}
/**
 * 
 * @export
 * @interface SinglePermissionSetResponse200
 */
export interface SinglePermissionSetResponse200 {
    /**
     * A permission assigned to this permission set
     * @type {Array<string>}
     * @memberof SinglePermissionSetResponse200
     */
    contents?: Array<string>;
}
/**
 * 
 * @export
 * @interface StageResponse200
 */
export interface StageResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof StageResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {StageResponse200Data}
     * @memberof StageResponse200
     */
    data?: StageResponse200Data;
}
/**
 * Updated stage object
 * @export
 * @interface StageResponse200Data
 */
export interface StageResponse200Data {
    /**
     * The ID of the stage
     * @type {number}
     * @memberof StageResponse200Data
     */
    id?: number;
    /**
     * Defines the order of the stage
     * @type {number}
     * @memberof StageResponse200Data
     */
    order_nr?: number;
    /**
     * The name of the stage
     * @type {string}
     * @memberof StageResponse200Data
     */
    name?: string;
    /**
     * Whether the stage is active or deleted
     * @type {boolean}
     * @memberof StageResponse200Data
     */
    active_flag?: boolean;
    /**
     * The success probability percentage of the deal. Used/shown when the deal weighted values are used.
     * @type {number}
     * @memberof StageResponse200Data
     */
    deal_probability?: number;
    /**
     * The ID of the pipeline to add the stage to
     * @type {number}
     * @memberof StageResponse200Data
     */
    pipeline_id?: number;
    /**
     * Whether deals in this stage can become rotten
     * @type {boolean}
     * @memberof StageResponse200Data
     */
    rotten_flag?: boolean;
    /**
     * The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set.
     * @type {number}
     * @memberof StageResponse200Data
     */
    rotten_days?: number;
    /**
     * The stage creation time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof StageResponse200Data
     */
    add_time?: string;
    /**
     * The stage update time. Format: YYYY-MM-DD HH:MM:SS.
     * @type {string}
     * @memberof StageResponse200Data
     */
    update_time?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionAddonsResponse200
 */
export interface SubscriptionAddonsResponse200 {
    /**
     * An array of add-ons that the company has.
     * @type {Array<any>}
     * @memberof SubscriptionAddonsResponse200
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface SubscriptionsIdResponse200
 */
export interface SubscriptionsIdResponse200 {
    /**
     * 
     * @type {SubscriptionsIdResponse200Data}
     * @memberof SubscriptionsIdResponse200
     */
    data?: SubscriptionsIdResponse200Data;
}
/**
 * 
 * @export
 * @interface SubscriptionsIdResponse200Data
 */
export interface SubscriptionsIdResponse200Data {
    /**
     * The ID of the subscription
     * @type {number}
     * @memberof SubscriptionsIdResponse200Data
     */
    id?: number;
    /**
     * The ID of the user who created the subscription
     * @type {number}
     * @memberof SubscriptionsIdResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the deal this subscription is associated with
     * @type {number}
     * @memberof SubscriptionsIdResponse200Data
     */
    deal_id?: number;
    /**
     * The description of the recurring subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    description?: string;
    /**
     * The subscription status
     * @type {boolean}
     * @memberof SubscriptionsIdResponse200Data
     */
    is_active?: boolean;
    /**
     * Shows how many payments a recurring subscription has
     * @type {number}
     * @memberof SubscriptionsIdResponse200Data
     */
    cycles_count?: number;
    /**
     * The amount of each payment
     * @type {number}
     * @memberof SubscriptionsIdResponse200Data
     */
    cycle_amount?: number;
    /**
     * Indicates that the recurring subscription will last until it is manually canceled or deleted
     * @type {boolean}
     * @memberof SubscriptionsIdResponse200Data
     */
    infinite?: boolean;
    /**
     * The currency of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    currency?: string;
    /**
     * The interval between payments
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    cadence_type?: string;
    /**
     * The start date of the recurring subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    start_date?: string;
    /**
     * The end date of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    end_date?: string;
    /**
     * The total value of all payments
     * @type {number}
     * @memberof SubscriptionsIdResponse200Data
     */
    lifetime_value?: number;
    /**
     * The final status of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    final_status?: string;
    /**
     * The creation time of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    add_time?: string;
    /**
     * The update time of the subscription
     * @type {string}
     * @memberof SubscriptionsIdResponse200Data
     */
    update_time?: string;
}
/**
 * 
 * @export
 * @interface TeamResponse200
 */
export interface TeamResponse200 {
    /**
     * 
     * @type {any}
     * @memberof TeamResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface TeamsResponse200
 */
export interface TeamsResponse200 {
    /**
     * 
     * @type {Array<any>}
     * @memberof TeamsResponse200
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface UnathorizedResponse
 */
export interface UnathorizedResponse {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UnathorizedResponse
     */
    success?: boolean;
    /**
     * The error message
     * @type {string}
     * @memberof UnathorizedResponse
     */
    error?: string;
    /**
     * The response error code
     * @type {number}
     * @memberof UnathorizedResponse
     */
    errorCode?: number;
}
/**
 * 
 * @export
 * @interface UpdateActivityRequest
 */
export interface UpdateActivityRequest {
    /**
     * The subject of the activity
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    subject?: string;
    /**
     * The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.
     * @type {string}
     * @memberof UpdateActivityRequest
     */
    type?: string;
    /**
     * The ID of the user whom the activity is assigned to
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    user_id?: number;
    /**
     * List of multiple persons (participants) this activity is associated with. It requires a structure as follows: `[{\"person_id\":1,\"primary_flag\":true}]`
     * @type {Array<any>}
     * @memberof UpdateActivityRequest
     */
    participants?: Array<any>;
    /**
     * Set the activity as 'Busy' or 'Free'. If the flag is set to `true`, your customers will not be able to book that time slot through any Scheduler links. The flag can also be unset by never setting it or overriding it with `null`. When the value of the flag is unset (`null`), the flag defaults to 'Busy' if it has a time set, and 'Free' if it is an all-day event without specified time.
     * @type {boolean}
     * @memberof UpdateActivityRequest
     */
    busy_flag?: boolean;
    /**
     * The attendees of the activity. This can be either your existing Pipedrive contacts or an external email address. It requires a structure as follows: `[{\"email_address\":\"mail@example.org\"}]` or `[{\"person_id\":1, \"email_address\":\"mail@example.org\"}]`
     * @type {Array<any>}
     * @memberof UpdateActivityRequest
     */
    attendees?: Array<any>;
    /**
     * Whether the activity is done or not. 0 = Not done, 1 = Done
     * @type {number}
     * @memberof UpdateActivityRequest
     */
    done?: number;
}
/**
 * 
 * @export
 * @interface UpdateActivityResponse200
 */
export interface UpdateActivityResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateActivityResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof UpdateActivityResponse200
     */
    data?: any;
    /**
     * 
     * @type {UpdateActivityResponse200RelatedObjects}
     * @memberof UpdateActivityResponse200
     */
    related_objects?: UpdateActivityResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface UpdateActivityResponse200RelatedObjects
 */
export interface UpdateActivityResponse200RelatedObjects {
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof UpdateActivityResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjectsDeal}
     * @memberof UpdateActivityResponse200RelatedObjects
     */
    deal?: UpdateProductResponse200RelatedObjectsDeal;
    /**
     * 
     * @type {GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson}
     * @memberof UpdateActivityResponse200RelatedObjects
     */
    person?: GetAssociatedPersonUpdatesResponse200RelatedObjectsPerson;
    /**
     * 
     * @type {ListPersonsResponse200RelatedObjectsOrganization}
     * @memberof UpdateActivityResponse200RelatedObjects
     */
    organization?: ListPersonsResponse200RelatedObjectsOrganization;
}
/**
 * 
 * @export
 * @interface UpdateActivityTypeRequest
 */
export interface UpdateActivityTypeRequest {
    /**
     * The name of the activity type
     * @type {string}
     * @memberof UpdateActivityTypeRequest
     */
    name?: string;
    /**
     * Icon graphic to use for representing this activity type
     * @type {string}
     * @memberof UpdateActivityTypeRequest
     */
    icon_key?: UpdateActivityTypeRequest.IconKeyEnum;
    /**
     * A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)
     * @type {string}
     * @memberof UpdateActivityTypeRequest
     */
    color?: string;
    /**
     * An order number for this activity type. Order numbers should be used to order the types in the activity type selections.
     * @type {number}
     * @memberof UpdateActivityTypeRequest
     */
    order_nr?: number;
}

/**
 * @export
 * @namespace UpdateActivityTypeRequest
 */
export namespace UpdateActivityTypeRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum IconKeyEnum {
        Task = <any> 'task',
        Email = <any> 'email',
        Meeting = <any> 'meeting',
        Deadline = <any> 'deadline',
        Call = <any> 'call',
        Lunch = <any> 'lunch',
        Calendar = <any> 'calendar',
        Downarrow = <any> 'downarrow',
        Document = <any> 'document',
        Smartphone = <any> 'smartphone',
        Camera = <any> 'camera',
        Scissors = <any> 'scissors',
        Cogs = <any> 'cogs',
        Bubble = <any> 'bubble',
        Uparrow = <any> 'uparrow',
        Checkbox = <any> 'checkbox',
        Signpost = <any> 'signpost',
        Shuffle = <any> 'shuffle',
        Addressbook = <any> 'addressbook',
        Linegraph = <any> 'linegraph',
        Picture = <any> 'picture',
        Car = <any> 'car',
        World = <any> 'world',
        Search = <any> 'search',
        Clip = <any> 'clip',
        Sound = <any> 'sound',
        Brush = <any> 'brush',
        Key = <any> 'key',
        Padlock = <any> 'padlock',
        Pricetag = <any> 'pricetag',
        Suitcase = <any> 'suitcase',
        Finish = <any> 'finish',
        Plane = <any> 'plane',
        Loop = <any> 'loop',
        Wifi = <any> 'wifi',
        Truck = <any> 'truck',
        Cart = <any> 'cart',
        Bulb = <any> 'bulb',
        Bell = <any> 'bell',
        Presentation = <any> 'presentation'
    }
}
/**
 * 
 * @export
 * @interface UpdateDealRequest
 */
export interface UpdateDealRequest {
    /**
     * The value of the deal. If omitted, value will be set to 0.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    value?: string;
    /**
     * The currency of the deal. Accepts a 3-character currency code. If omitted, currency will be set to the default currency of the authorized user.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    currency?: string;
    /**
     * The ID of the user which will be the owner of the created deal. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    user_id?: number;
    /**
     * The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first. This property is required unless `org_id` is specified.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    person_id?: number;
    /**
     * The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first. This property is required unless `person_id` is specified.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    org_id?: number;
    /**
     * The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    pipeline_id?: number;
    /**
     * The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`. If omitted, the deal will be placed in the first stage of the default pipeline.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    stage_id?: number;
    /**
     * open = Open, won = Won, lost = Lost, deleted = Deleted. If omitted, status will be set to open.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    status?: UpdateDealRequest.StatusEnum;
    /**
     * The expected close date of the deal. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateDealRequest
     */
    expected_close_date?: string;
    /**
     * The success probability percentage of the deal. Used/shown only when `deal_probability` for the pipeline of the deal is enabled.
     * @type {number}
     * @memberof UpdateDealRequest
     */
    probability?: number;
    /**
     * The optional message about why the deal was lost (to be used when status = lost)
     * @type {string}
     * @memberof UpdateDealRequest
     */
    lost_reason?: string;
    /**
     * The visibility of the deal. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof UpdateDealRequest
     */
    visible_to?: string;
}

/**
 * @export
 * @namespace UpdateDealRequest
 */
export namespace UpdateDealRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Open = <any> 'open',
        Won = <any> 'won',
        Lost = <any> 'lost',
        Deleted = <any> 'deleted'
    }
}
/**
 * 
 * @export
 * @interface UpdateFieldRequest
 */
export interface UpdateFieldRequest {
    /**
     * The name of the field
     * @type {string}
     * @memberof UpdateFieldRequest
     */
    name?: string;
    /**
     * When `field_type` is either set or enum, possible options must be supplied as a JSON-encoded sequential array of objects. All active items must be supplied and already existing items must have their ID supplied. New items only require a label. Example: `[{\"id\":123,\"label\":\"Existing Item\"},{\"label\":\"New Item\"}]`
     * @type {string}
     * @memberof UpdateFieldRequest
     */
    options?: string;
    /**
     * Whether the field is available in 'add new' modal or not (both in web and mobile app)
     * @type {boolean}
     * @memberof UpdateFieldRequest
     */
    add_visible_flag?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateFieldRequest1
 */
export interface UpdateFieldRequest1 {
    /**
     * The name of the field
     * @type {string}
     * @memberof UpdateFieldRequest1
     */
    name?: string;
    /**
     * When `field_type` is either set or enum, possible options must be supplied as a JSON-encoded sequential array of objects. All active items must be supplied and already existing items must have their ID supplied. New items only require a label. Example: `[{\"id\":123,\"label\":\"Existing Item\"},{\"label\":\"New Item\"}]`
     * @type {string}
     * @memberof UpdateFieldRequest1
     */
    options?: string;
    /**
     * Whether the field is available in 'add new' modal or not (both in web and mobile app)
     * @type {boolean}
     * @memberof UpdateFieldRequest1
     */
    add_visible_flag?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateFieldRequest2
 */
export interface UpdateFieldRequest2 {
    /**
     * The name of the field
     * @type {string}
     * @memberof UpdateFieldRequest2
     */
    name?: string;
    /**
     * When `field_type` is either set or enum, possible options must be supplied as a JSON-encoded sequential array of objects. All active items must be supplied and already existing items must have their ID supplied. New items only require a label. Example: `[{\"id\":123,\"label\":\"Existing Item\"},{\"label\":\"New Item\"}]`
     * @type {string}
     * @memberof UpdateFieldRequest2
     */
    options?: string;
    /**
     * Whether the field is available in 'add new' modal or not (both in web and mobile app)
     * @type {boolean}
     * @memberof UpdateFieldRequest2
     */
    add_visible_flag?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateFileRequest
 */
export interface UpdateFileRequest {
    /**
     * The visible name of the file
     * @type {string}
     * @memberof UpdateFileRequest
     */
    name?: string;
    /**
     * The description of the file
     * @type {string}
     * @memberof UpdateFileRequest
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface UpdateFileResponse200
 */
export interface UpdateFileResponse200 {
    /**
     * If the request was successful or not
     * @type {boolean}
     * @memberof UpdateFileResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {LinkFileToItemResponse200Data}
     * @memberof UpdateFileResponse200
     */
    data?: LinkFileToItemResponse200Data;
}
/**
 * 
 * @export
 * @interface UpdateFilterRequest
 */
export interface UpdateFilterRequest {
    /**
     * The name of the filter
     * @type {string}
     * @memberof UpdateFilterRequest
     */
    name?: string;
    /**
     * The conditions of the filter as a JSON object. It requires a minimum structure as follows: `{\"glue\":\"and\",\"conditions\":[{\"glue\":\"and\",\"conditions\": [CONDITION_OBJECTS]},{\"glue\":\"or\",\"conditions\":[CONDITION_OBJECTS]}]}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: `{\"object\":\"\",\"field_id\":\"\", \"operator\":\"\",\"value\":\"\", \"extra_value\":\"\"}` or leave the array empty. Depending on the object type you should use another API endpoint to get `field_id`. There are five types of objects you can choose from: `\"person\"`, `\"deal\"`, `\"organization\"`, `\"product\"`, `\"activity\"` and you can use these types of operators depending on what type of a field you have: `\"IS NOT NULL\"`, `\"IS NULL\"`, `\"<=\"`, `\">=\"`, `\"<\"`, `\">\"`, `\"!=\"`, `\"=\"`, `\"LIKE '$%'\"`, `\"LIKE '%$%'\"`, `\"NOT LIKE '$%'\"`. To get a better understanding of how filters work try creating them directly from the Pipedrive application.
     * @type {any}
     * @memberof UpdateFilterRequest
     */
    conditions: any;
}
/**
 * 
 * @export
 * @interface UpdateLeadLabelRequest
 */
export interface UpdateLeadLabelRequest {
    /**
     * The name of the lead label
     * @type {string}
     * @memberof UpdateLeadLabelRequest
     */
    name?: string;
    /**
     * The color of the label. Only a subset of colors can be used.
     * @type {string}
     * @memberof UpdateLeadLabelRequest
     */
    color?: UpdateLeadLabelRequest.ColorEnum;
}

/**
 * @export
 * @namespace UpdateLeadLabelRequest
 */
export namespace UpdateLeadLabelRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ColorEnum {
        Green = <any> 'green',
        Blue = <any> 'blue',
        Red = <any> 'red',
        Yellow = <any> 'yellow',
        Purple = <any> 'purple',
        Gray = <any> 'gray'
    }
}
/**
 * 
 * @export
 * @interface UpdateLeadRequest
 */
export interface UpdateLeadRequest {
    /**
     * The name of the lead
     * @type {string}
     * @memberof UpdateLeadRequest
     */
    title?: string;
    /**
     * The ID of the user which will be the owner of the created lead. If not provided, the user making the request will be used.
     * @type {number}
     * @memberof UpdateLeadRequest
     */
    owner_id?: number;
    /**
     * The IDs of the lead labels which will be associated with the lead
     * @type {Array<string>}
     * @memberof UpdateLeadRequest
     */
    label_ids?: Array<string>;
    /**
     * The ID of a person which this lead will be linked to. If the person does not exist yet, it needs to be created first. A lead always has to be linked to a person or organization or both. 
     * @type {number}
     * @memberof UpdateLeadRequest
     */
    person_id?: number;
    /**
     * The ID of an organization which this lead will be linked to. If the organization does not exist yet, it needs to be created first. A lead always has to be linked to a person or organization or both.
     * @type {number}
     * @memberof UpdateLeadRequest
     */
    organization_id?: number;
    /**
     * A flag indicating whether the lead is archived or not
     * @type {boolean}
     * @memberof UpdateLeadRequest
     */
    is_archived?: boolean;
    /**
     * 
     * @type {LeadsidValue}
     * @memberof UpdateLeadRequest
     */
    value?: LeadsidValue;
    /**
     * The date of when the deal which will be created from the lead is expected to be closed. In ISO 8601 format: YYYY-MM-DD.
     * @type {string}
     * @memberof UpdateLeadRequest
     */
    expected_close_date?: string;
    /**
     * The visibility of the lead. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width: 40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof UpdateLeadRequest
     */
    visible_to?: string;
    /**
     * A flag indicating whether the lead was seen by someone in the Pipedrive UI
     * @type {boolean}
     * @memberof UpdateLeadRequest
     */
    was_seen?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateMailThreadDetailsRequest
 */
export interface UpdateMailThreadDetailsRequest {
    /**
     * The ID of the deal this thread is associated with
     * @type {number}
     * @memberof UpdateMailThreadDetailsRequest
     */
    deal_id?: number;
    /**
     * The ID of the lead this thread is associated with
     * @type {string}
     * @memberof UpdateMailThreadDetailsRequest
     */
    lead_id?: string;
    /**
     * Whether this thread is shared with other users in your company
     * @type {number}
     * @memberof UpdateMailThreadDetailsRequest
     */
    shared_flag?: number;
    /**
     * Whether this thread is read or unread
     * @type {number}
     * @memberof UpdateMailThreadDetailsRequest
     */
    read_flag?: number;
    /**
     * Whether this thread is archived or not. You can only archive threads that belong to Inbox folder. Archived threads will disappear from Inbox.
     * @type {number}
     * @memberof UpdateMailThreadDetailsRequest
     */
    archived_flag?: number;
}
/**
 * 
 * @export
 * @interface UpdateMailThreadDetailsResponse200
 */
export interface UpdateMailThreadDetailsResponse200 {
    /**
     * The mail thread object
     * @type {any}
     * @memberof UpdateMailThreadDetailsResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationRelationshipResponse200
 */
export interface UpdateOrganizationRelationshipResponse200 {
    /**
     * 
     * @type {AddOrganizationRelationshipResponse200Data}
     * @memberof UpdateOrganizationRelationshipResponse200
     */
    data?: AddOrganizationRelationshipResponse200Data;
    /**
     * 
     * @type {GetOrganizationRelationshipsResponse200RelatedObjects}
     * @memberof UpdateOrganizationRelationshipResponse200
     */
    related_objects?: GetOrganizationRelationshipsResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * The ID of the user who will be marked as the owner of this organization. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof UpdateOrganizationRequest
     */
    owner_id?: number;
    /**
     * The visibility of the organization. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    visible_to?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationResponse200
 */
export interface UpdateOrganizationResponse200 {
    /**
     * 
     * @type {any}
     * @memberof UpdateOrganizationResponse200
     */
    data?: any;
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjects}
     * @memberof UpdateOrganizationResponse200
     */
    related_objects?: UpdateOrganizationResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationResponse200RelatedObjects
 */
export interface UpdateOrganizationResponse200RelatedObjects {
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsOrganization}
     * @memberof UpdateOrganizationResponse200RelatedObjects
     */
    organization?: GetAssociatedUpdatesResponse200RelatedObjectsOrganization;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof UpdateOrganizationResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
    /**
     * 
     * @type {UpdateOrganizationResponse200RelatedObjectsPicture}
     * @memberof UpdateOrganizationResponse200RelatedObjects
     */
    picture?: UpdateOrganizationResponse200RelatedObjectsPicture;
}
/**
 * The picture that is associated with the item
 * @export
 * @interface UpdateOrganizationResponse200RelatedObjectsPicture
 */
export interface UpdateOrganizationResponse200RelatedObjectsPicture {
    /**
     * The ID of the picture
     * @type {any}
     * @memberof UpdateOrganizationResponse200RelatedObjectsPicture
     */
    PICTURE_ID?: any;
}
/**
 * 
 * @export
 * @interface UpdatePersonRequest
 */
export interface UpdatePersonRequest {
    /**
     * The ID of the user who will be marked as the owner of this person. When omitted, the authorized user ID will be used.
     * @type {number}
     * @memberof UpdatePersonRequest
     */
    owner_id?: number;
    /**
     * The ID of the organization this person will belong to
     * @type {number}
     * @memberof UpdatePersonRequest
     */
    org_id?: number;
    /**
     * List of email data related to the person
     * @type {Array<PersonsEmail>}
     * @memberof UpdatePersonRequest
     */
    email?: Array<PersonsEmail>;
    /**
     * The primary email of the person
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    primary_email?: string;
    /**
     * List of phone data related to the person
     * @type {Array<PersonsPhone>}
     * @memberof UpdatePersonRequest
     */
    phone?: Array<PersonsPhone>;
    /**
     * The visibility of the person. If omitted, the visibility will be set to the default visibility setting of this item type for the authorized user. Read more about visibility groups <a href=\"https://support.pipedrive.com/en/article/visibility-groups\" target=\"_blank\" rel=\"noopener noreferrer\">here</a>.<h4>Essential / Advanced plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner &amp; followers</td><tr><td>`3`</td><td>Entire company</td></tr></table><h4>Professional / Enterprise plan</h4><table><tr><th style=\"width:40px\">Value</th><th>Description</th></tr><tr><td>`1`</td><td>Owner only</td><tr><td>`3`</td><td>Owner's visibility group</td></tr><tr><td>`5`</td><td>Owner's visibility group and sub-groups</td></tr><tr><td>`7`</td><td>Entire company</td></tr></table>
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    visible_to?: string;
    /**
     * If the person does not have a valid email address, then the marketing status is **not set** and `no_consent` is returned for the `marketing_status` value when the new person is created. If the change is forbidden, the status will remain unchanged for every call that tries to modify the marketing status. Please be aware that it is only allowed **once** to change the marketing status from an old status to a new one.<table><tr><th>Value</th><th>Description</th></tr><tr><td>`no_consent`</td><td>The customer has not given consent to receive any marketing communications</td></tr><tr><td>`unsubscribed`</td><td>The customers have unsubscribed from ALL marketing communications</td></tr><tr><td>`subscribed`</td><td>The customers are subscribed and are counted towards marketing caps</td></tr><tr><td>`archived`</td><td>The customers with `subscribed` status can be moved to `archived` to save consent, but they are not paid for</td></tr></table>
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    marketing_status?: string;
    /**
     * The optional creation date & time of the person in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof UpdatePersonRequest
     */
    add_time?: string;
}
/**
 * 
 * @export
 * @interface UpdatePersonResponse200
 */
export interface UpdatePersonResponse200 {
    /**
     * 
     * @type {any}
     * @memberof UpdatePersonResponse200
     */
    data?: any;
    /**
     * 
     * @type {AddPersonResponse200RelatedObjects}
     * @memberof UpdatePersonResponse200
     */
    related_objects?: AddPersonResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface UpdatePipelineResponse200
 */
export interface UpdatePipelineResponse200 {
    /**
     * The pipeline object
     * @type {any}
     * @memberof UpdatePipelineResponse200
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface UpdateProductFieldResponse200
 */
export interface UpdateProductFieldResponse200 {
    /**
     * The name of the field
     * @type {string}
     * @memberof UpdateProductFieldResponse200
     */
    name?: string;
    /**
     * When `field_type` is either set or enum, possible options on update must be supplied as an array of objects each containing id and label, for example: [{\"id\":1, \"label\":\"red\"},{\"id\":2, \"label\":\"blue\"},{\"id\":3, \"label\":\"lilac\"}]
     * @type {Array<any>}
     * @memberof UpdateProductFieldResponse200
     */
    options?: Array<any>;
}
/**
 * 
 * @export
 * @interface UpdateProductResponse200
 */
export interface UpdateProductResponse200 {
    /**
     * If the response is successful or not
     * @type {boolean}
     * @memberof UpdateProductResponse200
     */
    success?: boolean;
    /**
     * 
     * @type {any}
     * @memberof UpdateProductResponse200
     */
    data?: any;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjects}
     * @memberof UpdateProductResponse200
     */
    related_objects?: UpdateProductResponse200RelatedObjects;
}
/**
 * 
 * @export
 * @interface UpdateProductResponse200RelatedObjects
 */
export interface UpdateProductResponse200RelatedObjects {
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsUser}
     * @memberof UpdateProductResponse200RelatedObjects
     */
    user?: GetAssociatedUpdatesResponse200RelatedObjectsUser;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjectsDeal}
     * @memberof UpdateProductResponse200RelatedObjects
     */
    deal?: UpdateProductResponse200RelatedObjectsDeal;
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjectsPerson}
     * @memberof UpdateProductResponse200RelatedObjects
     */
    person?: UpdateProductResponse200RelatedObjectsPerson;
    /**
     * 
     * @type {GetAssociatedUpdatesResponse200RelatedObjectsOrganization}
     * @memberof UpdateProductResponse200RelatedObjects
     */
    organization?: GetAssociatedUpdatesResponse200RelatedObjectsOrganization;
}
/**
 * 
 * @export
 * @interface UpdateProductResponse200RelatedObjectsDeal
 */
export interface UpdateProductResponse200RelatedObjectsDeal {
    /**
     * 
     * @type {UpdateProductResponse200RelatedObjectsDealDEALID}
     * @memberof UpdateProductResponse200RelatedObjectsDeal
     */
    DEAL_ID?: UpdateProductResponse200RelatedObjectsDealDEALID;
}
/**
 * The ID of the deal which is associated with the item
 * @export
 * @interface UpdateProductResponse200RelatedObjectsDealDEALID
 */
export interface UpdateProductResponse200RelatedObjectsDealDEALID {
    /**
     * The ID of the deal associated with the item
     * @type {number}
     * @memberof UpdateProductResponse200RelatedObjectsDealDEALID
     */
    id?: number;
    /**
     * The title of the deal associated with the item
     * @type {string}
     * @memberof UpdateProductResponse200RelatedObjectsDealDEALID
     */
    title?: string;
    /**
     * The status of the deal associated with the item
     * @type {string}
     * @memberof UpdateProductResponse200RelatedObjectsDealDEALID
     */
    status?: string;
    /**
     * The value of the deal that is associated with the item
     * @type {number}
     * @memberof UpdateProductResponse200RelatedObjectsDealDEALID
     */
    value?: number;
    /**
     * The currency of the deal value
     * @type {string}
     * @memberof UpdateProductResponse200RelatedObjectsDealDEALID
     */
    currency?: string;
    /**
     * The ID of the stage the deal is currently at
     * @type {number}
     * @memberof UpdateProductResponse200RelatedObjectsDealDEALID
     */
    stage_id?: number;
    /**
     * The ID of the pipeline the deal is in
     * @type {number}
     * @memberof UpdateProductResponse200RelatedObjectsDealDEALID
     */
    pipeline_id?: number;
}
/**
 * 
 * @export
 * @interface UpdateProductResponse200RelatedObjectsPerson
 */
export interface UpdateProductResponse200RelatedObjectsPerson {
    /**
     * The ID of the person associated with the item
     * @type {any}
     * @memberof UpdateProductResponse200RelatedObjectsPerson
     */
    PERSON_ID?: any;
}
/**
 * 
 * @export
 * @interface UpdateRecurringSubscriptionRequest
 */
export interface UpdateRecurringSubscriptionRequest {
    /**
     * The description of the recurring subscription
     * @type {string}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    description?: string;
    /**
     * The amount of each payment
     * @type {number}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    cycle_amount?: number;
    /**
     * Array of additional payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with an explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<any>}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    payments?: Array<any>;
    /**
     * Indicates that the deal value must be set to recurring subscription's MRR value
     * @type {boolean}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    update_deal_value?: boolean;
    /**
     * All payments after that date will be affected. Format: YYYY-MM-DD
     * @type {string}
     * @memberof UpdateRecurringSubscriptionRequest
     */
    effective_date: string;
}
/**
 * 
 * @export
 * @interface UpdateRoleResponse200
 */
export interface UpdateRoleResponse200 {
    /**
     * 
     * @type {UpdateRoleResponse200Data}
     * @memberof UpdateRoleResponse200
     */
    data?: UpdateRoleResponse200Data;
}
/**
 * The response data
 * @export
 * @interface UpdateRoleResponse200Data
 */
export interface UpdateRoleResponse200Data {
    /**
     * The ID of the updated role
     * @type {number}
     * @memberof UpdateRoleResponse200Data
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface UpdateStageRequest
 */
export interface UpdateStageRequest {
    /**
     * An order number for this stage. Order numbers should be used to order the stages in the pipeline.
     * @type {number}
     * @memberof UpdateStageRequest
     */
    order_nr?: number;
}
/**
 * 
 * @export
 * @interface UpdateSubscriptionInstallmentRequest
 */
export interface UpdateSubscriptionInstallmentRequest {
    /**
     * Array of payments. It requires a minimum structure as follows: [{ amount:SUM, description:DESCRIPTION, due_at:PAYMENT_DATE }]. Replace SUM with a payment amount, DESCRIPTION with a explanation string, PAYMENT_DATE with a date (format YYYY-MM-DD).
     * @type {Array<any>}
     * @memberof UpdateSubscriptionInstallmentRequest
     */
    payments: Array<any>;
    /**
     * Indicates that the deal value must be set to installment subscription's total value
     * @type {boolean}
     * @memberof UpdateSubscriptionInstallmentRequest
     */
    update_deal_value?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateTeamRequest
 */
export interface UpdateTeamRequest {
    /**
     * Flag that indicates whether the team is active
     * @type {number}
     * @memberof UpdateTeamRequest
     */
    active_flag?: number;
    /**
     * Flag that indicates whether the team is deleted
     * @type {number}
     * @memberof UpdateTeamRequest
     */
    deleted_flag?: number;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * Whether the user is active or not. `false` = Not activated, `true` = Activated
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    active_flag: boolean;
}
/**
 * 
 * @export
 * @interface UserAssignmentsToPermissionSetResponse200
 */
export interface UserAssignmentsToPermissionSetResponse200 {
    /**
     * An array of the assignments of the user
     * @type {Array<UserAssignmentsToPermissionSetResponse200Data>}
     * @memberof UserAssignmentsToPermissionSetResponse200
     */
    data?: Array<UserAssignmentsToPermissionSetResponse200Data>;
}
/**
 * 
 * @export
 * @interface UserAssignmentsToPermissionSetResponse200Data
 */
export interface UserAssignmentsToPermissionSetResponse200Data {
    /**
     * The ID of the user in the permission set
     * @type {number}
     * @memberof UserAssignmentsToPermissionSetResponse200Data
     */
    user_id?: number;
    /**
     * The ID of the permission set
     * @type {string}
     * @memberof UserAssignmentsToPermissionSetResponse200Data
     */
    permission_set_id?: string;
    /**
     * The name of the permission set
     * @type {string}
     * @memberof UserAssignmentsToPermissionSetResponse200Data
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface UserConnectionsResponse200
 */
export interface UserConnectionsResponse200 {
    /**
     * 
     * @type {UserConnectionsResponse200Data}
     * @memberof UserConnectionsResponse200
     */
    data?: UserConnectionsResponse200Data;
}
/**
 * The object of UserConnections
 * @export
 * @interface UserConnectionsResponse200Data
 */
export interface UserConnectionsResponse200Data {
    /**
     * The third party ID or false in case the ID is not found
     * @type {string}
     * @memberof UserConnectionsResponse200Data
     */
    google?: string;
}
/**
 * 
 * @export
 * @interface UserIds
 */
export interface UserIds {
    /**
     * The list of user IDs
     * @type {Array<number>}
     * @memberof UserIds
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserResponse200
 */
export interface UserResponse200 {
    /**
     * 
     * @type {UsersResponse200Data}
     * @memberof UserResponse200
     */
    data?: UsersResponse200Data;
}
/**
 * 
 * @export
 * @interface UsersAccess
 */
export interface UsersAccess {
    /**
     * 
     * @type {string}
     * @memberof UsersAccess
     */
    app: UsersAccess.AppEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UsersAccess
     */
    admin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersAccess
     */
    permission_set_id?: string;
}

/**
 * @export
 * @namespace UsersAccess
 */
export namespace UsersAccess {
    /**
     * @export
     * @enum {string}
     */
    export enum AppEnum {
        Sales = <any> 'sales',
        Projects = <any> 'projects',
        Campaigns = <any> 'campaigns',
        Global = <any> 'global',
        AccountSettings = <any> 'account_settings'
    }
}
/**
 * 
 * @export
 * @interface UsersResponse200
 */
export interface UsersResponse200 {
    /**
     * 
     * @type {Array<UsersResponse200Data>}
     * @memberof UsersResponse200
     */
    data?: Array<UsersResponse200Data>;
}
/**
 * 
 * @export
 * @interface UsersResponse200Access
 */
export interface UsersResponse200Access {
    /**
     * 
     * @type {string}
     * @memberof UsersResponse200Access
     */
    app?: UsersResponse200Access.AppEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UsersResponse200Access
     */
    admin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersResponse200Access
     */
    permission_set_id?: string;
}

/**
 * @export
 * @namespace UsersResponse200Access
 */
export namespace UsersResponse200Access {
    /**
     * @export
     * @enum {string}
     */
    export enum AppEnum {
        Sales = <any> 'sales',
        Projects = <any> 'projects',
        Campaigns = <any> 'campaigns',
        Global = <any> 'global',
        AccountSettings = <any> 'account_settings'
    }
}
/**
 * 
 * @export
 * @interface UsersResponse200Data
 */
export interface UsersResponse200Data {
    /**
     * The user ID
     * @type {number}
     * @memberof UsersResponse200Data
     */
    id?: number;
    /**
     * The user name
     * @type {string}
     * @memberof UsersResponse200Data
     */
    name?: string;
    /**
     * The user default currency
     * @type {string}
     * @memberof UsersResponse200Data
     */
    default_currency?: string;
    /**
     * The user locale
     * @type {string}
     * @memberof UsersResponse200Data
     */
    locale?: string;
    /**
     * The user language ID
     * @type {number}
     * @memberof UsersResponse200Data
     */
    lang?: number;
    /**
     * The user email
     * @type {string}
     * @memberof UsersResponse200Data
     */
    email?: string;
    /**
     * The user phone
     * @type {string}
     * @memberof UsersResponse200Data
     */
    phone?: string;
    /**
     * Boolean that indicates whether the user is activated
     * @type {boolean}
     * @memberof UsersResponse200Data
     */
    activated?: boolean;
    /**
     * The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof UsersResponse200Data
     */
    last_login?: string;
    /**
     * The creation date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof UsersResponse200Data
     */
    created?: string;
    /**
     * The last modification date and time of the user. Format: YYYY-MM-DD HH:MM:SS
     * @type {string}
     * @memberof UsersResponse200Data
     */
    modified?: string;
    /**
     * Boolean that indicates whether the user has created a company
     * @type {boolean}
     * @memberof UsersResponse200Data
     */
    has_created_company?: boolean;
    /**
     * 
     * @type {Array<UsersResponse200Access>}
     * @memberof UsersResponse200Data
     */
    access?: Array<UsersResponse200Access>;
    /**
     * Boolean that indicates whether the user is activated
     * @type {boolean}
     * @memberof UsersResponse200Data
     */
    active_flag?: boolean;
    /**
     * The user timezone name
     * @type {string}
     * @memberof UsersResponse200Data
     */
    timezone_name?: string;
    /**
     * The user timezone offset
     * @type {string}
     * @memberof UsersResponse200Data
     */
    timezone_offset?: string;
    /**
     * The ID of the user role
     * @type {number}
     * @memberof UsersResponse200Data
     */
    role_id?: number;
    /**
     * The user icon URL
     * @type {string}
     * @memberof UsersResponse200Data
     */
    icon_url?: string;
    /**
     * Boolean that indicates if the requested user is the same which is logged in (in this case, always true)
     * @type {boolean}
     * @memberof UsersResponse200Data
     */
    is_you?: boolean;
}
/**
 * 
 * @export
 * @interface WebhookResponse200
 */
export interface WebhookResponse200 {
    /**
     * 
     * @type {WebhookResponse200Data}
     * @memberof WebhookResponse200
     */
    data?: WebhookResponse200Data;
}
/**
 * 
 * @export
 * @interface WebhookResponse200Data
 */
export interface WebhookResponse200Data {
    /**
     * The ID of the Webhook
     * @type {number}
     * @memberof WebhookResponse200Data
     */
    id?: number;
    /**
     * The ID of the company related to the Webhook
     * @type {number}
     * @memberof WebhookResponse200Data
     */
    company_id?: number;
    /**
     * The ID of the user who owns the Webhook
     * @type {number}
     * @memberof WebhookResponse200Data
     */
    owner_id?: number;
    /**
     * The ID of the user related to the Webhook
     * @type {number}
     * @memberof WebhookResponse200Data
     */
    user_id?: number;
    /**
     * The Webhook action
     * @type {string}
     * @memberof WebhookResponse200Data
     */
    event_action?: string;
    /**
     * The Webhook object
     * @type {string}
     * @memberof WebhookResponse200Data
     */
    event_object?: string;
    /**
     * The subscription URL of the Webhook
     * @type {string}
     * @memberof WebhookResponse200Data
     */
    subscription_url?: string;
    /**
     * The Webhook's status
     * @type {number}
     * @memberof WebhookResponse200Data
     */
    is_active?: number;
    /**
     * The date when the Webhook was added
     * @type {Date}
     * @memberof WebhookResponse200Data
     */
    add_time?: Date;
    /**
     * The date when the Webhook was removed (if removed)
     * @type {Date}
     * @memberof WebhookResponse200Data
     */
    remove_time?: Date;
    /**
     * The type of the Webhook
     * @type {string}
     * @memberof WebhookResponse200Data
     */
    type?: WebhookResponse200Data.TypeEnum;
    /**
     * The username of the `subscription_url` of the Webhook
     * @type {string}
     * @memberof WebhookResponse200Data
     */
    http_auth_user?: string;
    /**
     * The password of the `subscription_url` of the Webhook
     * @type {string}
     * @memberof WebhookResponse200Data
     */
    http_auth_password?: string;
    /**
     * Any additional data related to the Webhook
     * @type {any}
     * @memberof WebhookResponse200Data
     */
    additional_data?: any;
    /**
     * The removal reason of the Webhook (if removed)
     * @type {string}
     * @memberof WebhookResponse200Data
     */
    remove_reason?: string;
    /**
     * The last delivery time of the Webhook
     * @type {Date}
     * @memberof WebhookResponse200Data
     */
    last_delivery_time?: Date;
    /**
     * The last delivery HTTP status of the Webhook
     * @type {number}
     * @memberof WebhookResponse200Data
     */
    last_http_status?: number;
    /**
     * The ID of the admin of the Webhook
     * @type {number}
     * @memberof WebhookResponse200Data
     */
    admin_id?: number;
}

/**
 * @export
 * @namespace WebhookResponse200Data
 */
export namespace WebhookResponse200Data {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        General = <any> 'general',
        App = <any> 'app'
    }
}
/**
 * 
 * @export
 * @interface WebhooksBadRequestResponse
 */
export interface WebhooksBadRequestResponse {
    /**
     * List of errors
     * @type {any}
     * @memberof WebhooksBadRequestResponse
     */
    errors?: any;
}
/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
export const ActivitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
         * @summary Add an activity
         * @param {AddActivityRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addActivity(body?: AddActivityRequest, options: any = {}): FetchArgs {
            const localVarPath = `/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddActivityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple activities as deleted.
         * @summary Delete multiple activities in bulk
         * @param {string} ids The comma-separated IDs of activities that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivities(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteActivities.');
            }
            const localVarPath = `/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an activity as deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteActivity.');
            }
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all activities assigned to a particular user.
         * @summary Get all activities assigned to a particular user
         * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
         * @param {number} [filter_id] The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
         * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [start_date] Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {string} [end_date] Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(user_id?: number, filter_id?: number, type?: string, limit?: number, start?: number, start_date?: string, end_date?: string, done?: number, options: any = {}): FetchArgs {
            const localVarPath = `/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any).toISOString();
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any).toISOString();
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivity.');
            }
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {UpdateActivityRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity(id: number, body?: UpdateActivityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateActivity.');
            }
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateActivityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
         * @summary Add an activity
         * @param {AddActivityRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addActivity(body?: AddActivityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddActivityResponse200> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).addActivity(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple activities as deleted.
         * @summary Delete multiple activities in bulk
         * @param {string} ids The comma-separated IDs of activities that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivities(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteActivitiesResponse200> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).deleteActivities(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks an activity as deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteActivityResponse200> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).deleteActivity(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all activities assigned to a particular user.
         * @summary Get all activities assigned to a particular user
         * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
         * @param {number} [filter_id] The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
         * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [start_date] Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {string} [end_date] Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(user_id?: number, filter_id?: number, type?: string, limit?: number, start?: number, start_date?: string, end_date?: string, done?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetActivitiesResponse200> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getActivities(user_id, filter_id, type, limit, start, start_date, end_date, done, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetActivityResponse200> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getActivity(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {UpdateActivityRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity(id: number, body?: UpdateActivityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateActivityResponse200> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).updateActivity(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
         * @summary Add an activity
         * @param {AddActivityRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addActivity(body?: AddActivityRequest, options?: any) {
            return ActivitiesApiFp(configuration).addActivity(body, options)(fetch, basePath);
        },
        /**
         * Marks multiple activities as deleted.
         * @summary Delete multiple activities in bulk
         * @param {string} ids The comma-separated IDs of activities that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivities(ids: string, options?: any) {
            return ActivitiesApiFp(configuration).deleteActivities(ids, options)(fetch, basePath);
        },
        /**
         * Marks an activity as deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity(id: number, options?: any) {
            return ActivitiesApiFp(configuration).deleteActivity(id, options)(fetch, basePath);
        },
        /**
         * Returns all activities assigned to a particular user.
         * @summary Get all activities assigned to a particular user
         * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
         * @param {number} [filter_id] The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
         * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [start_date] Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {string} [end_date] Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(user_id?: number, filter_id?: number, type?: string, limit?: number, start?: number, start_date?: string, end_date?: string, done?: number, options?: any) {
            return ActivitiesApiFp(configuration).getActivities(user_id, filter_id, type, limit, start, start_date, end_date, done, options)(fetch, basePath);
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(id: number, options?: any) {
            return ActivitiesApiFp(configuration).getActivity(id, options)(fetch, basePath);
        },
        /**
         * Updates an activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {UpdateActivityRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity(id: number, body?: UpdateActivityRequest, options?: any) {
            return ActivitiesApiFp(configuration).updateActivity(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ActivitiesApi - interface
 * @export
 * @interface ActivitiesApi
 */
export interface ActivitiesApiInterface {
    /**
     * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
     * @summary Add an activity
     * @param {AddActivityRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    addActivity(body?: AddActivityRequest, options?: any): Promise<AddActivityResponse200>;

    /**
     * Marks multiple activities as deleted.
     * @summary Delete multiple activities in bulk
     * @param {string} ids The comma-separated IDs of activities that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    deleteActivities(ids: string, options?: any): Promise<DeleteActivitiesResponse200>;

    /**
     * Marks an activity as deleted.
     * @summary Delete an activity
     * @param {number} id The ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    deleteActivity(id: number, options?: any): Promise<DeleteActivityResponse200>;

    /**
     * Returns all activities assigned to a particular user.
     * @summary Get all activities assigned to a particular user
     * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
     * @param {number} [filter_id] The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
     * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
     * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
     * @param {number} [start] For pagination, the position that represents the first result for the page
     * @param {string} [start_date] Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
     * @param {string} [end_date] Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    getActivities(user_id?: number, filter_id?: number, type?: string, limit?: number, start?: number, start_date?: string, end_date?: string, done?: number, options?: any): Promise<GetActivitiesResponse200>;

    /**
     * Returns the details of a specific activity.
     * @summary Get details of an activity
     * @param {number} id The ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    getActivity(id: number, options?: any): Promise<GetActivityResponse200>;

    /**
     * Updates an activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
     * @summary Update an activity
     * @param {number} id The ID of the activity
     * @param {UpdateActivityRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    updateActivity(id: number, body?: UpdateActivityRequest, options?: any): Promise<UpdateActivityResponse200>;

}

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI implements ActivitiesApiInterface {
    /**
     * Adds a new activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-activity\" target=\"_blank\" rel=\"noopener noreferrer\">adding an activity</a>.
     * @summary Add an activity
     * @param {AddActivityRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public addActivity(body?: AddActivityRequest, options?: any) {
        return ActivitiesApiFp(this.configuration).addActivity(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple activities as deleted.
     * @summary Delete multiple activities in bulk
     * @param {string} ids The comma-separated IDs of activities that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public deleteActivities(ids: string, options?: any) {
        return ActivitiesApiFp(this.configuration).deleteActivities(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Marks an activity as deleted.
     * @summary Delete an activity
     * @param {number} id The ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public deleteActivity(id: number, options?: any) {
        return ActivitiesApiFp(this.configuration).deleteActivity(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all activities assigned to a particular user.
     * @summary Get all activities assigned to a particular user
     * @param {number} [user_id] The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets.
     * @param {number} [filter_id] The ID of the filter to use (will narrow down results if used together with &#x60;user_id&#x60; parameter)
     * @param {string} [type] The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the &#x60;key_string&#x60; parameter of ActivityTypes.
     * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
     * @param {number} [start] For pagination, the position that represents the first result for the page
     * @param {string} [start_date] Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format.
     * @param {string} [end_date] Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format.
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both done and not done activities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivities(user_id?: number, filter_id?: number, type?: string, limit?: number, start?: number, start_date?: string, end_date?: string, done?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getActivities(user_id, filter_id, type, limit, start, start_date, end_date, done, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the details of a specific activity.
     * @summary Get details of an activity
     * @param {number} id The ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivity(id: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getActivity(id, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an activity. Includes `more_activities_scheduled_in_context` property in response's `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).
     * @summary Update an activity
     * @param {number} id The ID of the activity
     * @param {UpdateActivityRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public updateActivity(id: number, body?: UpdateActivityRequest, options?: any) {
        return ActivitiesApiFp(this.configuration).updateActivity(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ActivityFieldsApi - fetch parameter creator
 * @export
 */
export const ActivityFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all activity fields.
         * @summary Get all activity fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityFields(options: any = {}): FetchArgs {
            const localVarPath = `/activityFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityFieldsApi - functional programming interface
 * @export
 */
export const ActivityFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns all activity fields.
         * @summary Get all activity fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityFields(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldsResponse200> {
            const localVarFetchArgs = ActivityFieldsApiFetchParamCreator(configuration).getActivityFields(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivityFieldsApi - factory interface
 * @export
 */
export const ActivityFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns all activity fields.
         * @summary Get all activity fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityFields(options?: any) {
            return ActivityFieldsApiFp(configuration).getActivityFields(options)(fetch, basePath);
        },
    };
};

/**
 * ActivityFieldsApi - interface
 * @export
 * @interface ActivityFieldsApi
 */
export interface ActivityFieldsApiInterface {
    /**
     * Returns all activity fields.
     * @summary Get all activity fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityFieldsApiInterface
     */
    getActivityFields(options?: any): Promise<FieldsResponse200>;

}

/**
 * ActivityFieldsApi - object-oriented interface
 * @export
 * @class ActivityFieldsApi
 * @extends {BaseAPI}
 */
export class ActivityFieldsApi extends BaseAPI implements ActivityFieldsApiInterface {
    /**
     * Returns all activity fields.
     * @summary Get all activity fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityFieldsApi
     */
    public getActivityFields(options?: any) {
        return ActivityFieldsApiFp(this.configuration).getActivityFields(options)(this.fetch, this.basePath);
    }

}
/**
 * ActivityTypesApi - fetch parameter creator
 * @export
 */
export const ActivityTypesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new activity type.
         * @summary Add new activity type
         * @param {string} [name] 
         * @param {string} [icon_key] 
         * @param {string} [color] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addActivityType(name?: string, icon_key?: string, color?: string, options: any = {}): FetchArgs {
            const localVarPath = `/activityTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (icon_key !== undefined) {
                localVarFormParams.set('icon_key', icon_key as any);
            }

            if (color !== undefined) {
                localVarFormParams.set('color', color as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an activity type as deleted.
         * @summary Delete an activity type
         * @param {number} id The ID of the activity type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivityType(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteActivityType.');
            }
            const localVarPath = `/activityTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple activity types as deleted.
         * @summary Delete multiple activity types in bulk
         * @param {string} ids The comma-separated activity type IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivityTypes(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteActivityTypes.');
            }
            const localVarPath = `/activityTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all activity types.
         * @summary Get all activity types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityTypes(options: any = {}): FetchArgs {
            const localVarPath = `/activityTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an activity type.
         * @summary Update an activity type
         * @param {number} id The ID of the activity type
         * @param {string} [name] 
         * @param {string} [icon_key] 
         * @param {string} [color] 
         * @param {number} [order_nr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityType(id: number, name?: string, icon_key?: string, color?: string, order_nr?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateActivityType.');
            }
            const localVarPath = `/activityTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (icon_key !== undefined) {
                localVarFormParams.set('icon_key', icon_key as any);
            }

            if (color !== undefined) {
                localVarFormParams.set('color', color as any);
            }

            if (order_nr !== undefined) {
                localVarFormParams.set('order_nr', order_nr as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityTypesApi - functional programming interface
 * @export
 */
export const ActivityTypesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new activity type.
         * @summary Add new activity type
         * @param {string} [name] 
         * @param {string} [icon_key] 
         * @param {string} [color] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addActivityType(name?: string, icon_key?: string, color?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUpdateDeleteActivityTypeResponse200> {
            const localVarFetchArgs = ActivityTypesApiFetchParamCreator(configuration).addActivityType(name, icon_key, color, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks an activity type as deleted.
         * @summary Delete an activity type
         * @param {number} id The ID of the activity type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivityType(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUpdateDeleteActivityTypeResponse200> {
            const localVarFetchArgs = ActivityTypesApiFetchParamCreator(configuration).deleteActivityType(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple activity types as deleted.
         * @summary Delete multiple activity types in bulk
         * @param {string} ids The comma-separated activity type IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivityTypes(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteActivityTypesResponse200> {
            const localVarFetchArgs = ActivityTypesApiFetchParamCreator(configuration).deleteActivityTypes(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all activity types.
         * @summary Get all activity types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetActivityTypesResponse200> {
            const localVarFetchArgs = ActivityTypesApiFetchParamCreator(configuration).getActivityTypes(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an activity type.
         * @summary Update an activity type
         * @param {number} id The ID of the activity type
         * @param {string} [name] 
         * @param {string} [icon_key] 
         * @param {string} [color] 
         * @param {number} [order_nr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityType(id: number, name?: string, icon_key?: string, color?: string, order_nr?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUpdateDeleteActivityTypeResponse200> {
            const localVarFetchArgs = ActivityTypesApiFetchParamCreator(configuration).updateActivityType(id, name, icon_key, color, order_nr, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivityTypesApi - factory interface
 * @export
 */
export const ActivityTypesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new activity type.
         * @summary Add new activity type
         * @param {string} [name] 
         * @param {string} [icon_key] 
         * @param {string} [color] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addActivityType(name?: string, icon_key?: string, color?: string, options?: any) {
            return ActivityTypesApiFp(configuration).addActivityType(name, icon_key, color, options)(fetch, basePath);
        },
        /**
         * Marks an activity type as deleted.
         * @summary Delete an activity type
         * @param {number} id The ID of the activity type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivityType(id: number, options?: any) {
            return ActivityTypesApiFp(configuration).deleteActivityType(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple activity types as deleted.
         * @summary Delete multiple activity types in bulk
         * @param {string} ids The comma-separated activity type IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivityTypes(ids: string, options?: any) {
            return ActivityTypesApiFp(configuration).deleteActivityTypes(ids, options)(fetch, basePath);
        },
        /**
         * Returns all activity types.
         * @summary Get all activity types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityTypes(options?: any) {
            return ActivityTypesApiFp(configuration).getActivityTypes(options)(fetch, basePath);
        },
        /**
         * Updates an activity type.
         * @summary Update an activity type
         * @param {number} id The ID of the activity type
         * @param {string} [name] 
         * @param {string} [icon_key] 
         * @param {string} [color] 
         * @param {number} [order_nr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityType(id: number, name?: string, icon_key?: string, color?: string, order_nr?: number, options?: any) {
            return ActivityTypesApiFp(configuration).updateActivityType(id, name, icon_key, color, order_nr, options)(fetch, basePath);
        },
    };
};

/**
 * ActivityTypesApi - interface
 * @export
 * @interface ActivityTypesApi
 */
export interface ActivityTypesApiInterface {
    /**
     * Adds a new activity type.
     * @summary Add new activity type
     * @param {string} [name] 
     * @param {string} [icon_key] 
     * @param {string} [color] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApiInterface
     */
    addActivityType(name?: string, icon_key?: string, color?: string, options?: any): Promise<CreateUpdateDeleteActivityTypeResponse200>;

    /**
     * Marks an activity type as deleted.
     * @summary Delete an activity type
     * @param {number} id The ID of the activity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApiInterface
     */
    deleteActivityType(id: number, options?: any): Promise<CreateUpdateDeleteActivityTypeResponse200>;

    /**
     * Marks multiple activity types as deleted.
     * @summary Delete multiple activity types in bulk
     * @param {string} ids The comma-separated activity type IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApiInterface
     */
    deleteActivityTypes(ids: string, options?: any): Promise<DeleteActivityTypesResponse200>;

    /**
     * Returns all activity types.
     * @summary Get all activity types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApiInterface
     */
    getActivityTypes(options?: any): Promise<GetActivityTypesResponse200>;

    /**
     * Updates an activity type.
     * @summary Update an activity type
     * @param {number} id The ID of the activity type
     * @param {string} [name] 
     * @param {string} [icon_key] 
     * @param {string} [color] 
     * @param {number} [order_nr] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApiInterface
     */
    updateActivityType(id: number, name?: string, icon_key?: string, color?: string, order_nr?: number, options?: any): Promise<CreateUpdateDeleteActivityTypeResponse200>;

}

/**
 * ActivityTypesApi - object-oriented interface
 * @export
 * @class ActivityTypesApi
 * @extends {BaseAPI}
 */
export class ActivityTypesApi extends BaseAPI implements ActivityTypesApiInterface {
    /**
     * Adds a new activity type.
     * @summary Add new activity type
     * @param {string} [name] 
     * @param {string} [icon_key] 
     * @param {string} [color] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public addActivityType(name?: string, icon_key?: string, color?: string, options?: any) {
        return ActivityTypesApiFp(this.configuration).addActivityType(name, icon_key, color, options)(this.fetch, this.basePath);
    }

    /**
     * Marks an activity type as deleted.
     * @summary Delete an activity type
     * @param {number} id The ID of the activity type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public deleteActivityType(id: number, options?: any) {
        return ActivityTypesApiFp(this.configuration).deleteActivityType(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple activity types as deleted.
     * @summary Delete multiple activity types in bulk
     * @param {string} ids The comma-separated activity type IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public deleteActivityTypes(ids: string, options?: any) {
        return ActivityTypesApiFp(this.configuration).deleteActivityTypes(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all activity types.
     * @summary Get all activity types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public getActivityTypes(options?: any) {
        return ActivityTypesApiFp(this.configuration).getActivityTypes(options)(this.fetch, this.basePath);
    }

    /**
     * Updates an activity type.
     * @summary Update an activity type
     * @param {number} id The ID of the activity type
     * @param {string} [name] 
     * @param {string} [icon_key] 
     * @param {string} [color] 
     * @param {number} [order_nr] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityTypesApi
     */
    public updateActivityType(id: number, name?: string, icon_key?: string, color?: string, order_nr?: number, options?: any) {
        return ActivityTypesApiFp(this.configuration).updateActivityType(id, name, icon_key, color, order_nr, options)(this.fetch, this.basePath);
    }

}
/**
 * BillingApi - fetch parameter creator
 * @export
 */
export const BillingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the add-ons for a single company.
         * @summary Get all add-ons for a single company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyAddons(options: any = {}): FetchArgs {
            const localVarPath = `/billing/subscriptions/addons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the add-ons for a single company.
         * @summary Get all add-ons for a single company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyAddons(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionAddonsResponse200> {
            const localVarFetchArgs = BillingApiFetchParamCreator(configuration).getCompanyAddons(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the add-ons for a single company.
         * @summary Get all add-ons for a single company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyAddons(options?: any) {
            return BillingApiFp(configuration).getCompanyAddons(options)(fetch, basePath);
        },
    };
};

/**
 * BillingApi - interface
 * @export
 * @interface BillingApi
 */
export interface BillingApiInterface {
    /**
     * Returns the add-ons for a single company.
     * @summary Get all add-ons for a single company
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getCompanyAddons(options?: any): Promise<SubscriptionAddonsResponse200>;

}

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI implements BillingApiInterface {
    /**
     * Returns the add-ons for a single company.
     * @summary Get all add-ons for a single company
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getCompanyAddons(options?: any) {
        return BillingApiFp(this.configuration).getCompanyAddons(options)(this.fetch, this.basePath);
    }

}
/**
 * CallLogsApi - fetch parameter creator
 * @export
 */
export const CallLogsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new call log.
         * @summary Add a call log
         * @param {AddCallLogRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCallLog(body?: AddCallLogRequest, options: any = {}): FetchArgs {
            const localVarPath = `/callLogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddCallLogRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
         * @summary Attach an audio file to the call log
         * @param {string} id The ID received when you create the call log
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCallLogAudioFile(id: string, file?: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addCallLogAudioFile.');
            }
            const localVarPath = `/callLogs/{id}/recordings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
         * @summary Delete a call log
         * @param {string} id The ID received when you create the call log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCallLog(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCallLog.');
            }
            const localVarPath = `/callLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific call log.
         * @summary Get details of a call log
         * @param {string} id The ID received when you create the call log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallLog(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCallLog.');
            }
            const localVarPath = `/callLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all call logs assigned to a particular user.
         * @summary Get all call logs assigned to a particular user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCallLogs(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/callLogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallLogsApi - functional programming interface
 * @export
 */
export const CallLogsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new call log.
         * @summary Add a call log
         * @param {AddCallLogRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCallLog(body?: AddCallLogRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddCallLogResponse200> {
            const localVarFetchArgs = CallLogsApiFetchParamCreator(configuration).addCallLog(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
         * @summary Attach an audio file to the call log
         * @param {string} id The ID received when you create the call log
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCallLogAudioFile(id: string, file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddCallLogAudioFileResponse200> {
            const localVarFetchArgs = CallLogsApiFetchParamCreator(configuration).addCallLogAudioFile(id, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
         * @summary Delete a call log
         * @param {string} id The ID received when you create the call log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCallLog(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCallLogResponse200> {
            const localVarFetchArgs = CallLogsApiFetchParamCreator(configuration).deleteCallLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a specific call log.
         * @summary Get details of a call log
         * @param {string} id The ID received when you create the call log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallLog(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = CallLogsApiFetchParamCreator(configuration).getCallLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all call logs assigned to a particular user.
         * @summary Get all call logs assigned to a particular user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCallLogs(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserCallLogsResponse200> {
            const localVarFetchArgs = CallLogsApiFetchParamCreator(configuration).getUserCallLogs(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallLogsApi - factory interface
 * @export
 */
export const CallLogsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new call log.
         * @summary Add a call log
         * @param {AddCallLogRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCallLog(body?: AddCallLogRequest, options?: any) {
            return CallLogsApiFp(configuration).addCallLog(body, options)(fetch, basePath);
        },
        /**
         * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
         * @summary Attach an audio file to the call log
         * @param {string} id The ID received when you create the call log
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCallLogAudioFile(id: string, file?: Blob, options?: any) {
            return CallLogsApiFp(configuration).addCallLogAudioFile(id, file, options)(fetch, basePath);
        },
        /**
         * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
         * @summary Delete a call log
         * @param {string} id The ID received when you create the call log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCallLog(id: string, options?: any) {
            return CallLogsApiFp(configuration).deleteCallLog(id, options)(fetch, basePath);
        },
        /**
         * Returns details of a specific call log.
         * @summary Get details of a call log
         * @param {string} id The ID received when you create the call log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallLog(id: string, options?: any) {
            return CallLogsApiFp(configuration).getCallLog(id, options)(fetch, basePath);
        },
        /**
         * Returns all call logs assigned to a particular user.
         * @summary Get all call logs assigned to a particular user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCallLogs(start?: number, limit?: number, options?: any) {
            return CallLogsApiFp(configuration).getUserCallLogs(start, limit, options)(fetch, basePath);
        },
    };
};

/**
 * CallLogsApi - interface
 * @export
 * @interface CallLogsApi
 */
export interface CallLogsApiInterface {
    /**
     * Adds a new call log.
     * @summary Add a call log
     * @param {AddCallLogRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApiInterface
     */
    addCallLog(body?: AddCallLogRequest, options?: any): Promise<AddCallLogResponse200>;

    /**
     * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
     * @summary Attach an audio file to the call log
     * @param {string} id The ID received when you create the call log
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApiInterface
     */
    addCallLogAudioFile(id: string, file?: Blob, options?: any): Promise<AddCallLogAudioFileResponse200>;

    /**
     * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
     * @summary Delete a call log
     * @param {string} id The ID received when you create the call log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApiInterface
     */
    deleteCallLog(id: string, options?: any): Promise<DeleteCallLogResponse200>;

    /**
     * Returns details of a specific call log.
     * @summary Get details of a call log
     * @param {string} id The ID received when you create the call log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApiInterface
     */
    getCallLog(id: string, options?: any): Promise<InlineResponse200>;

    /**
     * Returns all call logs assigned to a particular user.
     * @summary Get all call logs assigned to a particular user
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApiInterface
     */
    getUserCallLogs(start?: number, limit?: number, options?: any): Promise<GetUserCallLogsResponse200>;

}

/**
 * CallLogsApi - object-oriented interface
 * @export
 * @class CallLogsApi
 * @extends {BaseAPI}
 */
export class CallLogsApi extends BaseAPI implements CallLogsApiInterface {
    /**
     * Adds a new call log.
     * @summary Add a call log
     * @param {AddCallLogRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public addCallLog(body?: AddCallLogRequest, options?: any) {
        return CallLogsApiFp(this.configuration).addCallLog(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds an audio recording to the call log. That audio can be played by those who have access to the call log object.
     * @summary Attach an audio file to the call log
     * @param {string} id The ID received when you create the call log
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public addCallLogAudioFile(id: string, file?: Blob, options?: any) {
        return CallLogsApiFp(this.configuration).addCallLogAudioFile(id, file, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a call log. If there is an audio recording attached to it, it will also be deleted. The related activity will not be removed by this request. If you want to remove the related activities, please use the endpoint which is specific for activities.
     * @summary Delete a call log
     * @param {string} id The ID received when you create the call log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public deleteCallLog(id: string, options?: any) {
        return CallLogsApiFp(this.configuration).deleteCallLog(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a specific call log.
     * @summary Get details of a call log
     * @param {string} id The ID received when you create the call log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public getCallLog(id: string, options?: any) {
        return CallLogsApiFp(this.configuration).getCallLog(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all call logs assigned to a particular user.
     * @summary Get all call logs assigned to a particular user
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLogsApi
     */
    public getUserCallLogs(start?: number, limit?: number, options?: any) {
        return CallLogsApiFp(this.configuration).getUserCallLogs(start, limit, options)(this.fetch, this.basePath);
    }

}
/**
 * ChannelsApi - fetch parameter creator
 * @export
 */
export const ChannelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Add a channel
         * @param {ChannelsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannel(body?: ChannelsBody, options: any = {}): FetchArgs {
            const localVarPath = `/channels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChannelsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing messengers channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a channel
         * @param {string} id The ID of the channel provided by the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteChannel.');
            }
            const localVarPath = `/channels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a conversation
         * @param {string} channel_id The ID of the channel provided by the integration
         * @param {string} conversation_id The ID of the conversation provided by the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(channel_id: string, conversation_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'channel_id' is not null or undefined
            if (channel_id === null || channel_id === undefined) {
                throw new RequiredError('channel_id','Required parameter channel_id was null or undefined when calling deleteConversation.');
            }
            // verify required parameter 'conversation_id' is not null or undefined
            if (conversation_id === null || conversation_id === undefined) {
                throw new RequiredError('conversation_id','Required parameter conversation_id was null or undefined when calling deleteConversation.');
            }
            const localVarPath = `/channels/{channel-id}/conversations/{conversation-id}`
                .replace(`{${"channel-id"}}`, encodeURIComponent(String(channel_id)))
                .replace(`{${"conversation-id"}}`, encodeURIComponent(String(conversation_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Receives an incoming message
         * @param {MessagesReceiveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveMessage(body?: MessagesReceiveBody, options: any = {}): FetchArgs {
            const localVarPath = `/channels/messages/receive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MessagesReceiveBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Add a channel
         * @param {ChannelsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannel(body?: ChannelsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = ChannelsApiFetchParamCreator(configuration).addChannel(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an existing messengers channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a channel
         * @param {string} id The ID of the channel provided by the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ChannelsApiFetchParamCreator(configuration).deleteChannel(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a conversation
         * @param {string} channel_id The ID of the channel provided by the integration
         * @param {string} conversation_id The ID of the conversation provided by the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(channel_id: string, conversation_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ChannelsApiFetchParamCreator(configuration).deleteConversation(channel_id, conversation_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Receives an incoming message
         * @param {MessagesReceiveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveMessage(body?: MessagesReceiveBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = ChannelsApiFetchParamCreator(configuration).receiveMessage(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Add a channel
         * @param {ChannelsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addChannel(body?: ChannelsBody, options?: any) {
            return ChannelsApiFp(configuration).addChannel(body, options)(fetch, basePath);
        },
        /**
         * Deletes an existing messengers channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a channel
         * @param {string} id The ID of the channel provided by the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(id: string, options?: any) {
            return ChannelsApiFp(configuration).deleteChannel(id, options)(fetch, basePath);
        },
        /**
         * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Delete a conversation
         * @param {string} channel_id The ID of the channel provided by the integration
         * @param {string} conversation_id The ID of the conversation provided by the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(channel_id: string, conversation_id: string, options?: any) {
            return ChannelsApiFp(configuration).deleteConversation(channel_id, conversation_id, options)(fetch, basePath);
        },
        /**
         * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
         * @summary Receives an incoming message
         * @param {MessagesReceiveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveMessage(body?: MessagesReceiveBody, options?: any) {
            return ChannelsApiFp(configuration).receiveMessage(body, options)(fetch, basePath);
        },
    };
};

/**
 * ChannelsApi - interface
 * @export
 * @interface ChannelsApi
 */
export interface ChannelsApiInterface {
    /**
     * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Add a channel
     * @param {ChannelsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApiInterface
     */
    addChannel(body?: ChannelsBody, options?: any): Promise<InlineResponse2001>;

    /**
     * Deletes an existing messengers channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Delete a channel
     * @param {string} id The ID of the channel provided by the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApiInterface
     */
    deleteChannel(id: string, options?: any): Promise<InlineResponse2002>;

    /**
     * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Delete a conversation
     * @param {string} channel_id The ID of the channel provided by the integration
     * @param {string} conversation_id The ID of the conversation provided by the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApiInterface
     */
    deleteConversation(channel_id: string, conversation_id: string, options?: any): Promise<InlineResponse2002>;

    /**
     * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Receives an incoming message
     * @param {MessagesReceiveBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApiInterface
     */
    receiveMessage(body?: MessagesReceiveBody, options?: any): Promise<InlineResponse2003>;

}

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI implements ChannelsApiInterface {
    /**
     * Adds a new messaging channel, only admins are able to register new channels. It will use the getConversations endpoint to fetch conversations, participants and messages afterward. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Add a channel
     * @param {ChannelsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public addChannel(body?: ChannelsBody, options?: any) {
        return ChannelsApiFp(this.configuration).addChannel(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an existing messengers channel and all related entities (conversations and messages). To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Delete a channel
     * @param {string} id The ID of the channel provided by the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public deleteChannel(id: string, options?: any) {
        return ChannelsApiFp(this.configuration).deleteChannel(id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an existing conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Delete a conversation
     * @param {string} channel_id The ID of the channel provided by the integration
     * @param {string} conversation_id The ID of the conversation provided by the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public deleteConversation(channel_id: string, conversation_id: string, options?: any) {
        return ChannelsApiFp(this.configuration).deleteConversation(channel_id, conversation_id, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a message to a conversation. To use the endpoint, you need to have **Messengers integration** OAuth scope enabled and the Messaging manifest ready for the [Messaging app extension](https://pipedrive.readme.io/docs/messaging-app-extension).
     * @summary Receives an incoming message
     * @param {MessagesReceiveBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public receiveMessage(body?: MessagesReceiveBody, options?: any) {
        return ChannelsApiFp(this.configuration).receiveMessage(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CurrenciesApi - fetch parameter creator
 * @export
 */
export const CurrenciesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
         * @summary Get all supported currencies
         * @param {string} [term] Optional search term that is searched for from currency&#x27;s name and/or code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(term?: string, options: any = {}): FetchArgs {
            const localVarPath = `/currencies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
         * @summary Get all supported currencies
         * @param {string} [term] Optional search term that is searched for from currency&#x27;s name and/or code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(term?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCurrenciesResponse200> {
            const localVarFetchArgs = CurrenciesApiFetchParamCreator(configuration).getCurrencies(term, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
         * @summary Get all supported currencies
         * @param {string} [term] Optional search term that is searched for from currency&#x27;s name and/or code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(term?: string, options?: any) {
            return CurrenciesApiFp(configuration).getCurrencies(term, options)(fetch, basePath);
        },
    };
};

/**
 * CurrenciesApi - interface
 * @export
 * @interface CurrenciesApi
 */
export interface CurrenciesApiInterface {
    /**
     * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
     * @summary Get all supported currencies
     * @param {string} [term] Optional search term that is searched for from currency&#x27;s name and/or code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApiInterface
     */
    getCurrencies(term?: string, options?: any): Promise<GetCurrenciesResponse200>;

}

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI implements CurrenciesApiInterface {
    /**
     * Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.
     * @summary Get all supported currencies
     * @param {string} [term] Optional search term that is searched for from currency&#x27;s name and/or code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCurrencies(term?: string, options?: any) {
        return CurrenciesApiFp(this.configuration).getCurrencies(term, options)(this.fetch, this.basePath);
    }

}
/**
 * DealFieldsApi - fetch parameter creator
 * @export
 */
export const DealFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new deal field
         * @param {CreateFieldRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealField(body?: CreateFieldRequest, options: any = {}): FetchArgs {
            const localVarPath = `/dealFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateFieldRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a deal field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDealField.');
            }
            const localVarPath = `/dealFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple deal fields as deleted.
         * @summary Delete multiple deal fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealFields(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteDealFields.');
            }
            const localVarPath = `/dealFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific deal field.
         * @summary Get one deal field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealField.');
            }
            const localVarPath = `/dealFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all deal fields.
         * @summary Get all deal fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFields(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/dealFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a deal field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDealField(id: number, body?: UpdateFieldRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDealField.');
            }
            const localVarPath = `/dealFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateFieldRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DealFieldsApi - functional programming interface
 * @export
 */
export const DealFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new deal field
         * @param {CreateFieldRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealField(body?: CreateFieldRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = DealFieldsApiFetchParamCreator(configuration).addDealField(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a deal field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFieldResponse200> {
            const localVarFetchArgs = DealFieldsApiFetchParamCreator(configuration).deleteDealField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple deal fields as deleted.
         * @summary Delete multiple deal fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealFields(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFieldsResponse200> {
            const localVarFetchArgs = DealFieldsApiFetchParamCreator(configuration).deleteDealFields(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific deal field.
         * @summary Get one deal field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = DealFieldsApiFetchParamCreator(configuration).getDealField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all deal fields.
         * @summary Get all deal fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFields(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldsResponse200> {
            const localVarFetchArgs = DealFieldsApiFetchParamCreator(configuration).getDealFields(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a deal field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDealField(id: number, body?: UpdateFieldRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = DealFieldsApiFetchParamCreator(configuration).updateDealField(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DealFieldsApi - factory interface
 * @export
 */
export const DealFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new deal field
         * @param {CreateFieldRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealField(body?: CreateFieldRequest, options?: any) {
            return DealFieldsApiFp(configuration).addDealField(body, options)(fetch, basePath);
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a deal field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealField(id: number, options?: any) {
            return DealFieldsApiFp(configuration).deleteDealField(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple deal fields as deleted.
         * @summary Delete multiple deal fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealFields(ids: string, options?: any) {
            return DealFieldsApiFp(configuration).deleteDealFields(ids, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific deal field.
         * @summary Get one deal field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealField(id: number, options?: any) {
            return DealFieldsApiFp(configuration).getDealField(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all deal fields.
         * @summary Get all deal fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFields(start?: number, limit?: number, options?: any) {
            return DealFieldsApiFp(configuration).getDealFields(start, limit, options)(fetch, basePath);
        },
        /**
         * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a deal field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDealField(id: number, body?: UpdateFieldRequest, options?: any) {
            return DealFieldsApiFp(configuration).updateDealField(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * DealFieldsApi - interface
 * @export
 * @interface DealFieldsApi
 */
export interface DealFieldsApiInterface {
    /**
     * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new deal field
     * @param {CreateFieldRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApiInterface
     */
    addDealField(body?: CreateFieldRequest, options?: any): Promise<FieldResponse200>;

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a deal field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApiInterface
     */
    deleteDealField(id: number, options?: any): Promise<DeleteFieldResponse200>;

    /**
     * Marks multiple deal fields as deleted.
     * @summary Delete multiple deal fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApiInterface
     */
    deleteDealFields(ids: string, options?: any): Promise<DeleteFieldsResponse200>;

    /**
     * Returns data about a specific deal field.
     * @summary Get one deal field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApiInterface
     */
    getDealField(id: number, options?: any): Promise<FieldResponse200>;

    /**
     * Returns data about all deal fields.
     * @summary Get all deal fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApiInterface
     */
    getDealFields(start?: number, limit?: number, options?: any): Promise<FieldsResponse200>;

    /**
     * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update a deal field
     * @param {number} id The ID of the field
     * @param {UpdateFieldRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApiInterface
     */
    updateDealField(id: number, body?: UpdateFieldRequest, options?: any): Promise<FieldResponse200>;

}

/**
 * DealFieldsApi - object-oriented interface
 * @export
 * @class DealFieldsApi
 * @extends {BaseAPI}
 */
export class DealFieldsApi extends BaseAPI implements DealFieldsApiInterface {
    /**
     * Adds a new deal field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new deal field
     * @param {CreateFieldRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public addDealField(body?: CreateFieldRequest, options?: any) {
        return DealFieldsApiFp(this.configuration).addDealField(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a deal field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public deleteDealField(id: number, options?: any) {
        return DealFieldsApiFp(this.configuration).deleteDealField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple deal fields as deleted.
     * @summary Delete multiple deal fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public deleteDealFields(ids: string, options?: any) {
        return DealFieldsApiFp(this.configuration).deleteDealFields(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific deal field.
     * @summary Get one deal field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public getDealField(id: number, options?: any) {
        return DealFieldsApiFp(this.configuration).getDealField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all deal fields.
     * @summary Get all deal fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public getDealFields(start?: number, limit?: number, options?: any) {
        return DealFieldsApiFp(this.configuration).getDealFields(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a deal field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update a deal field
     * @param {number} id The ID of the field
     * @param {UpdateFieldRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealFieldsApi
     */
    public updateDealField(id: number, body?: UpdateFieldRequest, options?: any) {
        return DealFieldsApiFp(this.configuration).updateDealField(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * DealsApi - fetch parameter creator
 * @export
 */
export const DealsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
         * @summary Add a deal
         * @param {AddDealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDeal(body?: AddDealRequest, options: any = {}): FetchArgs {
            const localVarPath = `/deals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddDealRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to a deal.
         * @summary Add a follower to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealFollower(id: number, body?: AddDealFollowerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addDealFollower.');
            }
            const localVarPath = `/deals/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddDealFollowerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a participant to a deal.
         * @summary Add a participant to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealParticipantRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealParticipant(id: number, body?: AddDealParticipantRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addDealParticipant.');
            }
            const localVarPath = `/deals/{id}/participants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddDealParticipantRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a product to the deal.
         * @summary Add a product to the deal, eventually creating a new item called a deal-product
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealProduct(id: number, body?: AddDealProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addDealProduct.');
            }
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddDealProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a deal as deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeal(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDeal.');
            }
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from a deal.
         * @summary Delete a follower from a deal
         * @param {number} id The ID of the deal
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealFollower(id: number, follower_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDealFollower.');
            }
            // verify required parameter 'follower_id' is not null or undefined
            if (follower_id === null || follower_id === undefined) {
                throw new RequiredError('follower_id','Required parameter follower_id was null or undefined when calling deleteDealFollower.');
            }
            const localVarPath = `/deals/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a participant from a deal.
         * @summary Delete a participant from a deal
         * @param {number} id The ID of the deal
         * @param {number} deal_participant_id The ID of the participant of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealParticipant(id: number, deal_participant_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDealParticipant.');
            }
            // verify required parameter 'deal_participant_id' is not null or undefined
            if (deal_participant_id === null || deal_participant_id === undefined) {
                throw new RequiredError('deal_participant_id','Required parameter deal_participant_id was null or undefined when calling deleteDealParticipant.');
            }
            const localVarPath = `/deals/{id}/participants/{deal_participant_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deal_participant_id"}}`, encodeURIComponent(String(deal_participant_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID. This is returned as &#x60;product_attachment_id&#x60; after attaching a product to a deal or as id when listing the products attached to a deal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealProduct(id: number, product_attachment_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDealProduct.');
            }
            // verify required parameter 'product_attachment_id' is not null or undefined
            if (product_attachment_id === null || product_attachment_id === undefined) {
                throw new RequiredError('product_attachment_id','Required parameter product_attachment_id was null or undefined when calling deleteDealProduct.');
            }
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple deals as deleted.
         * @summary Delete multiple deals in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeals(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteDeals.');
            }
            const localVarPath = `/deals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates a deal.
         * @summary Duplicate deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDeal(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling duplicateDeal.');
            }
            const localVarPath = `/deals/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals  such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeal(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeal.');
            }
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists activities associated with a deal.
         * @summary List activities associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealActivities.');
            }
            const localVarPath = `/deals/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with a deal.
         * @summary List files attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealFiles.');
            }
            const localVarPath = `/deals/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (include_deleted_files !== undefined) {
                localVarQueryParameter['include_deleted_files'] = include_deleted_files;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a deal.
         * @summary List followers of a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFollowers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealFollowers.');
            }
            const localVarPath = `/deals/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists mail messages associated with a deal.
         * @summary List mail messages associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealMailMessages(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealMailMessages.');
            }
            const localVarPath = `/deals/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List participants of a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealParticipants(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealParticipants.');
            }
            const localVarPath = `/deals/{id}/participants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.
         * @summary List all persons associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealPersons(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealPersons.');
            }
            const localVarPath = `/deals/{id}/persons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_product_data] Whether to fetch product data along with each attached product (1) or not (0, default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealProducts(id: number, start?: number, limit?: number, include_product_data?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealProducts.');
            }
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (include_product_data !== undefined) {
                localVarQueryParameter['include_product_data'] = include_product_data;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists updates about a deal.
         * @summary List updates about a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealUpdates.');
            }
            const localVarPath = `/deals/{id}/flow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (all_changes !== undefined) {
                localVarQueryParameter['all_changes'] = all_changes;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the users permitted to access a deal.
         * @summary List permitted users
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealUsers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDealUsers.');
            }
            const localVarPath = `/deals/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
         * @summary Get all deals
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {number} [owned_by_you] When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeals(user_id?: number, filter_id?: number, stage_id?: number, status?: string, start?: number, limit?: number, sort?: string, owned_by_you?: number, options: any = {}): FetchArgs {
            const localVarPath = `/deals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (owned_by_you !== undefined) {
                localVarQueryParameter['owned_by_you'] = owned_by_you;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a summary of all the deals.
         * @summary Get deals summary
         * @param {string} [status] Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
         * @param {number} [filter_id] &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
         * @param {number} [user_id] Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
         * @param {number} [stage_id] Only deals within the given stage will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealsSummary(status?: string, filter_id?: number, user_id?: number, stage_id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/deals/summary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups  January, February and March  based on the value of the given `field_key`.
         * @summary Get deals timeline
         * @param {string} start_date The date when the first interval starts. Format: YYYY-MM-DD
         * @param {string} interval The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
         * @param {number} amount The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
         * @param {string} field_key The date field key which deals will be retrieved from
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned
         * @param {number} [pipeline_id] If supplied, only deals matching the given pipeline will be returned
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [exclude_deals] Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user&#x27;s default currency is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealsTimeline(start_date: string, interval: string, amount: number, field_key: string, user_id?: number, pipeline_id?: number, filter_id?: number, exclude_deals?: number, totals_convert_currency?: string, options: any = {}): FetchArgs {
            // verify required parameter 'start_date' is not null or undefined
            if (start_date === null || start_date === undefined) {
                throw new RequiredError('start_date','Required parameter start_date was null or undefined when calling getDealsTimeline.');
            }
            // verify required parameter 'interval' is not null or undefined
            if (interval === null || interval === undefined) {
                throw new RequiredError('interval','Required parameter interval was null or undefined when calling getDealsTimeline.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling getDealsTimeline.');
            }
            // verify required parameter 'field_key' is not null or undefined
            if (field_key === null || field_key === undefined) {
                throw new RequiredError('field_key','Required parameter field_key was null or undefined when calling getDealsTimeline.');
            }
            const localVarPath = `/deals/timeline`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any).toISOString();
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (field_key !== undefined) {
                localVarQueryParameter['field_key'] = field_key;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (pipeline_id !== undefined) {
                localVarQueryParameter['pipeline_id'] = pipeline_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (exclude_deals !== undefined) {
                localVarQueryParameter['exclude_deals'] = exclude_deals;
            }

            if (totals_convert_currency !== undefined) {
                localVarQueryParameter['totals_convert_currency'] = totals_convert_currency;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
         * @summary Merge two deals
         * @param {number} id The ID of the deal
         * @param {MergeDealsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeDeals(id: number, body?: MergeDealsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling mergeDeals.');
            }
            const localVarPath = `/deals/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MergeDealsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {string} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDeals(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, status?: string, include_fields?: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling searchDeals.');
            }
            const localVarPath = `/deals/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeal(id: number, body?: UpdateDealRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDeal.');
            }
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateDealRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates product attachment details.
         * @summary Update product attachment details of the deal-product (a product already attached to a deal)
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {BasicDealProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDealProduct(id: number, product_attachment_id: number, body?: BasicDealProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDealProduct.');
            }
            // verify required parameter 'product_attachment_id' is not null or undefined
            if (product_attachment_id === null || product_attachment_id === undefined) {
                throw new RequiredError('product_attachment_id','Required parameter product_attachment_id was null or undefined when calling updateDealProduct.');
            }
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BasicDealProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DealsApi - functional programming interface
 * @export
 */
export const DealsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
         * @summary Add a deal
         * @param {AddDealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDeal(body?: AddDealRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DealResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).addDeal(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a follower to a deal.
         * @summary Add a follower to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealFollower(id: number, body?: AddDealFollowerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddDealFollowerResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).addDealFollower(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a participant to a deal.
         * @summary Add a participant to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealParticipantRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealParticipant(id: number, body?: AddDealParticipantRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddDealParticipantResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).addDealParticipant(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a product to the deal.
         * @summary Add a product to the deal, eventually creating a new item called a deal-product
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealProduct(id: number, body?: AddDealProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAddProductAttachementResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).addDealProduct(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a deal as deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeal(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDealResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).deleteDeal(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a follower from a deal.
         * @summary Delete a follower from a deal
         * @param {number} id The ID of the deal
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealFollower(id: number, follower_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDealFollowerResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).deleteDealFollower(id, follower_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a participant from a deal.
         * @summary Delete a participant from a deal
         * @param {number} id The ID of the deal
         * @param {number} deal_participant_id The ID of the participant of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealParticipant(id: number, deal_participant_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDealParticipantResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).deleteDealParticipant(id, deal_participant_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID. This is returned as &#x60;product_attachment_id&#x60; after attaching a product to a deal or as id when listing the products attached to a deal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealProduct(id: number, product_attachment_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDealProductResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).deleteDealProduct(id, product_attachment_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple deals as deleted.
         * @summary Delete multiple deals in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeals(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDealsResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).deleteDeals(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Duplicates a deal.
         * @summary Duplicate deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDeal(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DuplicateDealResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).duplicateDeal(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals  such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeal(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDealResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDeal(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists activities associated with a deal.
         * @summary List activities associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDealActivitiesResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealActivities(id, start, limit, done, exclude, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists files associated with a deal.
         * @summary List files attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedFilesResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealFiles(id, start, limit, include_deleted_files, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the followers of a deal.
         * @summary List followers of a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFollowers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedFollowersResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealFollowers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists mail messages associated with a deal.
         * @summary List mail messages associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealMailMessages(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedMailMessagesResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealMailMessages(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List participants of a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealParticipants(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDealParticipantsResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealParticipants(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.
         * @summary List all persons associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealPersons(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListPersonsResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealPersons(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_product_data] Whether to fetch product data along with each attached product (1) or not (0, default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealProducts(id: number, start?: number, limit?: number, include_product_data?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListProductsResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealProducts(id, start, limit, include_product_data, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists updates about a deal.
         * @summary List updates about a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDealUpdatesResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealUpdates(id, start, limit, all_changes, items, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the users permitted to access a deal.
         * @summary List permitted users
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealUsers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListPermittedUsersResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealUsers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
         * @summary Get all deals
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {number} [owned_by_you] When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeals(user_id?: number, filter_id?: number, stage_id?: number, status?: string, start?: number, limit?: number, sort?: string, owned_by_you?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDealsResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDeals(user_id, filter_id, stage_id, status, start, limit, sort, owned_by_you, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a summary of all the deals.
         * @summary Get deals summary
         * @param {string} [status] Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
         * @param {number} [filter_id] &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
         * @param {number} [user_id] Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
         * @param {number} [stage_id] Only deals within the given stage will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealsSummary(status?: string, filter_id?: number, user_id?: number, stage_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDealsSummaryResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealsSummary(status, filter_id, user_id, stage_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups  January, February and March  based on the value of the given `field_key`.
         * @summary Get deals timeline
         * @param {string} start_date The date when the first interval starts. Format: YYYY-MM-DD
         * @param {string} interval The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
         * @param {number} amount The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
         * @param {string} field_key The date field key which deals will be retrieved from
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned
         * @param {number} [pipeline_id] If supplied, only deals matching the given pipeline will be returned
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [exclude_deals] Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user&#x27;s default currency is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealsTimeline(start_date: string, interval: string, amount: number, field_key: string, user_id?: number, pipeline_id?: number, filter_id?: number, exclude_deals?: number, totals_convert_currency?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetDealsTimelineResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).getDealsTimeline(start_date, interval, amount, field_key, user_id, pipeline_id, filter_id, exclude_deals, totals_convert_currency, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
         * @summary Merge two deals
         * @param {number} id The ID of the deal
         * @param {MergeDealsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeDeals(id: number, body?: MergeDealsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MergeDealsResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).mergeDeals(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {string} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDeals(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, status?: string, include_fields?: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchDealsResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).searchDeals(term, fields, exact_match, person_id, organization_id, status, include_fields, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeal(id: number, body?: UpdateDealRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DealResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).updateDeal(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates product attachment details.
         * @summary Update product attachment details of the deal-product (a product already attached to a deal)
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {BasicDealProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDealProduct(id: number, product_attachment_id: number, body?: BasicDealProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetProductAttachementResponse200> {
            const localVarFetchArgs = DealsApiFetchParamCreator(configuration).updateDealProduct(id, product_attachment_id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DealsApi - factory interface
 * @export
 */
export const DealsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
         * @summary Add a deal
         * @param {AddDealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDeal(body?: AddDealRequest, options?: any) {
            return DealsApiFp(configuration).addDeal(body, options)(fetch, basePath);
        },
        /**
         * Adds a follower to a deal.
         * @summary Add a follower to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealFollower(id: number, body?: AddDealFollowerRequest, options?: any) {
            return DealsApiFp(configuration).addDealFollower(id, body, options)(fetch, basePath);
        },
        /**
         * Adds a participant to a deal.
         * @summary Add a participant to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealParticipantRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealParticipant(id: number, body?: AddDealParticipantRequest, options?: any) {
            return DealsApiFp(configuration).addDealParticipant(id, body, options)(fetch, basePath);
        },
        /**
         * Adds a product to the deal.
         * @summary Add a product to the deal, eventually creating a new item called a deal-product
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDealProduct(id: number, body?: AddDealProductRequest, options?: any) {
            return DealsApiFp(configuration).addDealProduct(id, body, options)(fetch, basePath);
        },
        /**
         * Marks a deal as deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeal(id: number, options?: any) {
            return DealsApiFp(configuration).deleteDeal(id, options)(fetch, basePath);
        },
        /**
         * Deletes a follower from a deal.
         * @summary Delete a follower from a deal
         * @param {number} id The ID of the deal
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealFollower(id: number, follower_id: number, options?: any) {
            return DealsApiFp(configuration).deleteDealFollower(id, follower_id, options)(fetch, basePath);
        },
        /**
         * Deletes a participant from a deal.
         * @summary Delete a participant from a deal
         * @param {number} id The ID of the deal
         * @param {number} deal_participant_id The ID of the participant of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealParticipant(id: number, deal_participant_id: number, options?: any) {
            return DealsApiFp(configuration).deleteDealParticipant(id, deal_participant_id, options)(fetch, basePath);
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID. This is returned as &#x60;product_attachment_id&#x60; after attaching a product to a deal or as id when listing the products attached to a deal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDealProduct(id: number, product_attachment_id: number, options?: any) {
            return DealsApiFp(configuration).deleteDealProduct(id, product_attachment_id, options)(fetch, basePath);
        },
        /**
         * Marks multiple deals as deleted.
         * @summary Delete multiple deals in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeals(ids: string, options?: any) {
            return DealsApiFp(configuration).deleteDeals(ids, options)(fetch, basePath);
        },
        /**
         * Duplicates a deal.
         * @summary Duplicate deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateDeal(id: number, options?: any) {
            return DealsApiFp(configuration).duplicateDeal(id, options)(fetch, basePath);
        },
        /**
         * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals  such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeal(id: number, options?: any) {
            return DealsApiFp(configuration).getDeal(id, options)(fetch, basePath);
        },
        /**
         * Lists activities associated with a deal.
         * @summary List activities associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any) {
            return DealsApiFp(configuration).getDealActivities(id, start, limit, done, exclude, options)(fetch, basePath);
        },
        /**
         * Lists files associated with a deal.
         * @summary List files attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
            return DealsApiFp(configuration).getDealFiles(id, start, limit, include_deleted_files, sort, options)(fetch, basePath);
        },
        /**
         * Lists the followers of a deal.
         * @summary List followers of a deal
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealFollowers(id: number, options?: any) {
            return DealsApiFp(configuration).getDealFollowers(id, options)(fetch, basePath);
        },
        /**
         * Lists mail messages associated with a deal.
         * @summary List mail messages associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealMailMessages(id: number, start?: number, limit?: number, options?: any) {
            return DealsApiFp(configuration).getDealMailMessages(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List participants of a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealParticipants(id: number, start?: number, limit?: number, options?: any) {
            return DealsApiFp(configuration).getDealParticipants(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.
         * @summary List all persons associated with a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealPersons(id: number, start?: number, limit?: number, options?: any) {
            return DealsApiFp(configuration).getDealPersons(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_product_data] Whether to fetch product data along with each attached product (1) or not (0, default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealProducts(id: number, start?: number, limit?: number, include_product_data?: number, options?: any) {
            return DealsApiFp(configuration).getDealProducts(id, start, limit, include_product_data, options)(fetch, basePath);
        },
        /**
         * Lists updates about a deal.
         * @summary List updates about a deal
         * @param {number} id The ID of the deal
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any) {
            return DealsApiFp(configuration).getDealUpdates(id, start, limit, all_changes, items, options)(fetch, basePath);
        },
        /**
         * Lists the users permitted to access a deal.
         * @summary List permitted users
         * @param {number} id The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealUsers(id: number, options?: any) {
            return DealsApiFp(configuration).getDealUsers(id, options)(fetch, basePath);
        },
        /**
         * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
         * @summary Get all deals
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {number} [owned_by_you] When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeals(user_id?: number, filter_id?: number, stage_id?: number, status?: string, start?: number, limit?: number, sort?: string, owned_by_you?: number, options?: any) {
            return DealsApiFp(configuration).getDeals(user_id, filter_id, stage_id, status, start, limit, sort, owned_by_you, options)(fetch, basePath);
        },
        /**
         * Returns a summary of all the deals.
         * @summary Get deals summary
         * @param {string} [status] Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
         * @param {number} [filter_id] &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
         * @param {number} [user_id] Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
         * @param {number} [stage_id] Only deals within the given stage will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealsSummary(status?: string, filter_id?: number, user_id?: number, stage_id?: number, options?: any) {
            return DealsApiFp(configuration).getDealsSummary(status, filter_id, user_id, stage_id, options)(fetch, basePath);
        },
        /**
         * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups  January, February and March  based on the value of the given `field_key`.
         * @summary Get deals timeline
         * @param {string} start_date The date when the first interval starts. Format: YYYY-MM-DD
         * @param {string} interval The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
         * @param {number} amount The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
         * @param {string} field_key The date field key which deals will be retrieved from
         * @param {number} [user_id] If supplied, only deals matching the given user will be returned
         * @param {number} [pipeline_id] If supplied, only deals matching the given pipeline will be returned
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [exclude_deals] Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user&#x27;s default currency is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDealsTimeline(start_date: string, interval: string, amount: number, field_key: string, user_id?: number, pipeline_id?: number, filter_id?: number, exclude_deals?: number, totals_convert_currency?: string, options?: any) {
            return DealsApiFp(configuration).getDealsTimeline(start_date, interval, amount, field_key, user_id, pipeline_id, filter_id, exclude_deals, totals_convert_currency, options)(fetch, basePath);
        },
        /**
         * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
         * @summary Merge two deals
         * @param {number} id The ID of the deal
         * @param {MergeDealsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeDeals(id: number, body?: MergeDealsRequest, options?: any) {
            return DealsApiFp(configuration).mergeDeals(id, body, options)(fetch, basePath);
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {string} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDeals(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, status?: string, include_fields?: string, start?: number, limit?: number, options?: any) {
            return DealsApiFp(configuration).searchDeals(term, fields, exact_match, person_id, organization_id, status, include_fields, start, limit, options)(fetch, basePath);
        },
        /**
         * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeal(id: number, body?: UpdateDealRequest, options?: any) {
            return DealsApiFp(configuration).updateDeal(id, body, options)(fetch, basePath);
        },
        /**
         * Updates product attachment details.
         * @summary Update product attachment details of the deal-product (a product already attached to a deal)
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {BasicDealProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDealProduct(id: number, product_attachment_id: number, body?: BasicDealProductRequest, options?: any) {
            return DealsApiFp(configuration).updateDealProduct(id, product_attachment_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * DealsApi - interface
 * @export
 * @interface DealsApi
 */
export interface DealsApiInterface {
    /**
     * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
     * @summary Add a deal
     * @param {AddDealRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    addDeal(body?: AddDealRequest, options?: any): Promise<DealResponse200>;

    /**
     * Adds a follower to a deal.
     * @summary Add a follower to a deal
     * @param {number} id The ID of the deal
     * @param {AddDealFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    addDealFollower(id: number, body?: AddDealFollowerRequest, options?: any): Promise<AddDealFollowerResponse200>;

    /**
     * Adds a participant to a deal.
     * @summary Add a participant to a deal
     * @param {number} id The ID of the deal
     * @param {AddDealParticipantRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    addDealParticipant(id: number, body?: AddDealParticipantRequest, options?: any): Promise<AddDealParticipantResponse200>;

    /**
     * Adds a product to the deal.
     * @summary Add a product to the deal, eventually creating a new item called a deal-product
     * @param {number} id The ID of the deal
     * @param {AddDealProductRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    addDealProduct(id: number, body?: AddDealProductRequest, options?: any): Promise<GetAddProductAttachementResponse200>;

    /**
     * Marks a deal as deleted.
     * @summary Delete a deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    deleteDeal(id: number, options?: any): Promise<DeleteDealResponse200>;

    /**
     * Deletes a follower from a deal.
     * @summary Delete a follower from a deal
     * @param {number} id The ID of the deal
     * @param {number} follower_id The ID of the follower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    deleteDealFollower(id: number, follower_id: number, options?: any): Promise<DeleteDealFollowerResponse200>;

    /**
     * Deletes a participant from a deal.
     * @summary Delete a participant from a deal
     * @param {number} id The ID of the deal
     * @param {number} deal_participant_id The ID of the participant of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    deleteDealParticipant(id: number, deal_participant_id: number, options?: any): Promise<DeleteDealParticipantResponse200>;

    /**
     * Deletes a product attachment from a deal, using the `product_attachment_id`.
     * @summary Delete an attached product from a deal
     * @param {number} id The ID of the deal
     * @param {number} product_attachment_id The product attachment ID. This is returned as &#x60;product_attachment_id&#x60; after attaching a product to a deal or as id when listing the products attached to a deal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    deleteDealProduct(id: number, product_attachment_id: number, options?: any): Promise<DeleteDealProductResponse200>;

    /**
     * Marks multiple deals as deleted.
     * @summary Delete multiple deals in bulk
     * @param {string} ids The comma-separated IDs that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    deleteDeals(ids: string, options?: any): Promise<DeleteDealsResponse200>;

    /**
     * Duplicates a deal.
     * @summary Duplicate deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    duplicateDeal(id: number, options?: any): Promise<DuplicateDealResponse200>;

    /**
     * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals  such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
     * @summary Get details of a deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDeal(id: number, options?: any): Promise<GetDealResponse200>;

    /**
     * Lists activities associated with a deal.
     * @summary List activities associated with a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
     * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any): Promise<GetDealActivitiesResponse200>;

    /**
     * Lists files associated with a deal.
     * @summary List files attached to a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): Promise<GetAssociatedFilesResponse200>;

    /**
     * Lists the followers of a deal.
     * @summary List followers of a deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealFollowers(id: number, options?: any): Promise<GetAssociatedFollowersResponse200>;

    /**
     * Lists mail messages associated with a deal.
     * @summary List mail messages associated with a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealMailMessages(id: number, start?: number, limit?: number, options?: any): Promise<GetAssociatedMailMessagesResponse200>;

    /**
     * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary List participants of a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealParticipants(id: number, start?: number, limit?: number, options?: any): Promise<GetDealParticipantsResponse200>;

    /**
     * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.
     * @summary List all persons associated with a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealPersons(id: number, start?: number, limit?: number, options?: any): Promise<ListPersonsResponse200>;

    /**
     * Lists products attached to a deal.
     * @summary List products attached to a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_product_data] Whether to fetch product data along with each attached product (1) or not (0, default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealProducts(id: number, start?: number, limit?: number, include_product_data?: number, options?: any): Promise<ListProductsResponse200>;

    /**
     * Lists updates about a deal.
     * @summary List updates about a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
     * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any): Promise<GetDealUpdatesResponse200>;

    /**
     * Lists the users permitted to access a deal.
     * @summary List permitted users
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealUsers(id: number, options?: any): Promise<ListPermittedUsersResponse200>;

    /**
     * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
     * @summary Get all deals
     * @param {number} [user_id] If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {number} [owned_by_you] When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDeals(user_id?: number, filter_id?: number, stage_id?: number, status?: string, start?: number, limit?: number, sort?: string, owned_by_you?: number, options?: any): Promise<GetDealsResponse200>;

    /**
     * Returns a summary of all the deals.
     * @summary Get deals summary
     * @param {string} [status] Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
     * @param {number} [filter_id] &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
     * @param {number} [user_id] Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
     * @param {number} [stage_id] Only deals within the given stage will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealsSummary(status?: string, filter_id?: number, user_id?: number, stage_id?: number, options?: any): Promise<GetDealsSummaryResponse200>;

    /**
     * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups  January, February and March  based on the value of the given `field_key`.
     * @summary Get deals timeline
     * @param {string} start_date The date when the first interval starts. Format: YYYY-MM-DD
     * @param {string} interval The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
     * @param {number} amount The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
     * @param {string} field_key The date field key which deals will be retrieved from
     * @param {number} [user_id] If supplied, only deals matching the given user will be returned
     * @param {number} [pipeline_id] If supplied, only deals matching the given pipeline will be returned
     * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
     * @param {number} [exclude_deals] Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
     * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user&#x27;s default currency is used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    getDealsTimeline(start_date: string, interval: string, amount: number, field_key: string, user_id?: number, pipeline_id?: number, filter_id?: number, exclude_deals?: number, totals_convert_currency?: string, options?: any): Promise<GetDealsTimelineResponse200>;

    /**
     * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
     * @summary Merge two deals
     * @param {number} id The ID of the deal
     * @param {MergeDealsRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    mergeDeals(id: number, body?: MergeDealsRequest, options?: any): Promise<MergeDealsResponse200>;

    /**
     * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
     * @summary Search deals
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
     * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
     * @param {string} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    searchDeals(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, status?: string, include_fields?: string, start?: number, limit?: number, options?: any): Promise<SearchDealsResponse200>;

    /**
     * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
     * @summary Update a deal
     * @param {number} id The ID of the deal
     * @param {UpdateDealRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    updateDeal(id: number, body?: UpdateDealRequest, options?: any): Promise<DealResponse200>;

    /**
     * Updates product attachment details.
     * @summary Update product attachment details of the deal-product (a product already attached to a deal)
     * @param {number} id The ID of the deal
     * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
     * @param {BasicDealProductRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApiInterface
     */
    updateDealProduct(id: number, product_attachment_id: number, body?: BasicDealProductRequest, options?: any): Promise<GetProductAttachementResponse200>;

}

/**
 * DealsApi - object-oriented interface
 * @export
 * @class DealsApi
 * @extends {BaseAPI}
 */
export class DealsApi extends BaseAPI implements DealsApiInterface {
    /**
     * Adds a new deal. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/creating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">adding a deal</a>.
     * @summary Add a deal
     * @param {AddDealRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDeal(body?: AddDealRequest, options?: any) {
        return DealsApiFp(this.configuration).addDeal(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a follower to a deal.
     * @summary Add a follower to a deal
     * @param {number} id The ID of the deal
     * @param {AddDealFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDealFollower(id: number, body?: AddDealFollowerRequest, options?: any) {
        return DealsApiFp(this.configuration).addDealFollower(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a participant to a deal.
     * @summary Add a participant to a deal
     * @param {number} id The ID of the deal
     * @param {AddDealParticipantRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDealParticipant(id: number, body?: AddDealParticipantRequest, options?: any) {
        return DealsApiFp(this.configuration).addDealParticipant(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a product to the deal.
     * @summary Add a product to the deal, eventually creating a new item called a deal-product
     * @param {number} id The ID of the deal
     * @param {AddDealProductRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public addDealProduct(id: number, body?: AddDealProductRequest, options?: any) {
        return DealsApiFp(this.configuration).addDealProduct(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a deal as deleted.
     * @summary Delete a deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDeal(id: number, options?: any) {
        return DealsApiFp(this.configuration).deleteDeal(id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a follower from a deal.
     * @summary Delete a follower from a deal
     * @param {number} id The ID of the deal
     * @param {number} follower_id The ID of the follower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDealFollower(id: number, follower_id: number, options?: any) {
        return DealsApiFp(this.configuration).deleteDealFollower(id, follower_id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a participant from a deal.
     * @summary Delete a participant from a deal
     * @param {number} id The ID of the deal
     * @param {number} deal_participant_id The ID of the participant of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDealParticipant(id: number, deal_participant_id: number, options?: any) {
        return DealsApiFp(this.configuration).deleteDealParticipant(id, deal_participant_id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a product attachment from a deal, using the `product_attachment_id`.
     * @summary Delete an attached product from a deal
     * @param {number} id The ID of the deal
     * @param {number} product_attachment_id The product attachment ID. This is returned as &#x60;product_attachment_id&#x60; after attaching a product to a deal or as id when listing the products attached to a deal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDealProduct(id: number, product_attachment_id: number, options?: any) {
        return DealsApiFp(this.configuration).deleteDealProduct(id, product_attachment_id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple deals as deleted.
     * @summary Delete multiple deals in bulk
     * @param {string} ids The comma-separated IDs that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public deleteDeals(ids: string, options?: any) {
        return DealsApiFp(this.configuration).deleteDeals(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Duplicates a deal.
     * @summary Duplicate deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public duplicateDeal(id: number, options?: any) {
        return DealsApiFp(this.configuration).duplicateDeal(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals  such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">getting details of a deal</a>.
     * @summary Get details of a deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDeal(id: number, options?: any) {
        return DealsApiFp(this.configuration).getDeal(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists activities associated with a deal.
     * @summary List activities associated with a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
     * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any) {
        return DealsApiFp(this.configuration).getDealActivities(id, start, limit, done, exclude, options)(this.fetch, this.basePath);
    }

    /**
     * Lists files associated with a deal.
     * @summary List files attached to a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
        return DealsApiFp(this.configuration).getDealFiles(id, start, limit, include_deleted_files, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the followers of a deal.
     * @summary List followers of a deal
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealFollowers(id: number, options?: any) {
        return DealsApiFp(this.configuration).getDealFollowers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists mail messages associated with a deal.
     * @summary List mail messages associated with a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealMailMessages(id: number, start?: number, limit?: number, options?: any) {
        return DealsApiFp(this.configuration).getDealMailMessages(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the participants associated with a deal.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary List participants of a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealParticipants(id: number, start?: number, limit?: number, options?: any) {
        return DealsApiFp(this.configuration).getDealParticipants(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.
     * @summary List all persons associated with a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealPersons(id: number, start?: number, limit?: number, options?: any) {
        return DealsApiFp(this.configuration).getDealPersons(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists products attached to a deal.
     * @summary List products attached to a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_product_data] Whether to fetch product data along with each attached product (1) or not (0, default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealProducts(id: number, start?: number, limit?: number, include_product_data?: number, options?: any) {
        return DealsApiFp(this.configuration).getDealProducts(id, start, limit, include_product_data, options)(this.fetch, this.basePath);
    }

    /**
     * Lists updates about a deal.
     * @summary List updates about a deal
     * @param {number} id The ID of the deal
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
     * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any) {
        return DealsApiFp(this.configuration).getDealUpdates(id, start, limit, all_changes, items, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the users permitted to access a deal.
     * @summary List permitted users
     * @param {number} id The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealUsers(id: number, options?: any) {
        return DealsApiFp(this.configuration).getDealUsers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all deals. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/getting-all-deals\" target=\"_blank\" rel=\"noopener noreferrer\">getting all deals</a>.
     * @summary Get all deals
     * @param {number} [user_id] If supplied, only deals matching the given user will be returned. However, &#x60;filter_id&#x60; and &#x60;owned_by_you&#x60; takes precedence over &#x60;user_id&#x60; when supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {number} [owned_by_you] When supplied, only deals owned by you are returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owned_by_you&#x60; when both are supplied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDeals(user_id?: number, filter_id?: number, stage_id?: number, status?: string, start?: number, limit?: number, sort?: string, owned_by_you?: number, options?: any) {
        return DealsApiFp(this.configuration).getDeals(user_id, filter_id, stage_id, status, start, limit, sort, owned_by_you, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a summary of all the deals.
     * @summary Get deals summary
     * @param {string} [status] Only fetch deals with a specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost
     * @param {number} [filter_id] &lt;code&gt;user_id&lt;/code&gt; will not be considered. Only deals matching the given filter will be returned.
     * @param {number} [user_id] Only deals matching the given user will be returned. &#x60;user_id&#x60; will not be considered if you use &#x60;filter_id&#x60;.
     * @param {number} [stage_id] Only deals within the given stage will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealsSummary(status?: string, filter_id?: number, user_id?: number, stage_id?: number, options?: any) {
        return DealsApiFp(this.configuration).getDealsSummary(status, filter_id, user_id, stage_id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  e.g. when month is the chosen interval, and 3 months are asked starting from January 1st, 2012, deals are returned grouped into 3 groups  January, February and March  based on the value of the given `field_key`.
     * @summary Get deals timeline
     * @param {string} start_date The date when the first interval starts. Format: YYYY-MM-DD
     * @param {string} interval The type of the interval&lt;table&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;day&#x60;&lt;/td&gt;&lt;td&gt;Day&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;week&#x60;&lt;/td&gt;&lt;td&gt;A full week (7 days) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;month&#x60;&lt;/td&gt;&lt;td&gt;A full month (depending on the number of days in given month) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x60;quarter&#x60;&lt;/td&gt;&lt;td&gt;A full quarter (3 months) starting from &#x60;start_date&#x60;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
     * @param {number} amount The number of given intervals, starting from &#x60;start_date&#x60;, to fetch. E.g. 3 (months).
     * @param {string} field_key The date field key which deals will be retrieved from
     * @param {number} [user_id] If supplied, only deals matching the given user will be returned
     * @param {number} [pipeline_id] If supplied, only deals matching the given pipeline will be returned
     * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
     * @param {number} [exclude_deals] Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned.
     * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;totals_converted&#x60; is returned per each interval which contains the currency-converted total amounts in the given currency. You may also set this parameter to &#x60;default_currency&#x60; in which case the user&#x27;s default currency is used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public getDealsTimeline(start_date: string, interval: string, amount: number, field_key: string, user_id?: number, pipeline_id?: number, filter_id?: number, exclude_deals?: number, totals_convert_currency?: string, options?: any) {
        return DealsApiFp(this.configuration).getDealsTimeline(start_date, interval, amount, field_key, user_id, pipeline_id, filter_id, exclude_deals, totals_convert_currency, options)(this.fetch, this.basePath);
    }

    /**
     * Merges a deal with another deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-deals\" target=\"_blank\" rel=\"noopener noreferrer\">merging two deals</a>.
     * @summary Merge two deals
     * @param {number} id The ID of the deal
     * @param {MergeDealsRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public mergeDeals(id: number, body?: MergeDealsRequest, options?: any) {
        return DealsApiFp(this.configuration).mergeDeals(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
     * @summary Search deals
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
     * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
     * @param {string} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public searchDeals(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, status?: string, include_fields?: string, start?: number, limit?: number, options?: any) {
        return DealsApiFp(this.configuration).searchDeals(term, fields, exact_match, person_id, organization_id, status, include_fields, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of a deal. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-deal\" target=\"_blank\" rel=\"noopener noreferrer\">updating a deal</a>.
     * @summary Update a deal
     * @param {number} id The ID of the deal
     * @param {UpdateDealRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public updateDeal(id: number, body?: UpdateDealRequest, options?: any) {
        return DealsApiFp(this.configuration).updateDeal(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates product attachment details.
     * @summary Update product attachment details of the deal-product (a product already attached to a deal)
     * @param {number} id The ID of the deal
     * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
     * @param {BasicDealProductRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DealsApi
     */
    public updateDealProduct(id: number, product_attachment_id: number, body?: BasicDealProductRequest, options?: any) {
        return DealsApiFp(this.configuration).updateDealProduct(id, product_attachment_id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * FilesApi - fetch parameter creator
 * @export
 */
export const FilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lets you upload a file and associate it with a deal, person, organization, activity or product. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
         * @summary Add file
         * @param {Blob} [file] 
         * @param {number} [deal_id] 
         * @param {number} [person_id] 
         * @param {number} [org_id] 
         * @param {number} [product_id] 
         * @param {number} [activity_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFile(file?: Blob, deal_id?: number, person_id?: number, org_id?: number, product_id?: number, activity_id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (deal_id !== undefined) {
                localVarFormParams.set('deal_id', deal_id as any);
            }

            if (person_id !== undefined) {
                localVarFormParams.set('person_id', person_id as any);
            }

            if (org_id !== undefined) {
                localVarFormParams.set('org_id', org_id as any);
            }

            if (product_id !== undefined) {
                localVarFormParams.set('product_id', product_id as any);
            }

            if (activity_id !== undefined) {
                localVarFormParams.set('activity_id', activity_id as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Create a remote file and link it to an item
         * @param {string} [file_type] 
         * @param {string} [title] 
         * @param {string} [item_type] 
         * @param {number} [item_id] 
         * @param {string} [remote_location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFileAndLinkIt(file_type?: string, title?: string, item_type?: string, item_id?: number, remote_location?: string, options: any = {}): FetchArgs {
            const localVarPath = `/files/remote`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file_type !== undefined) {
                localVarFormParams.set('file_type', file_type as any);
            }

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (item_type !== undefined) {
                localVarFormParams.set('item_type', item_type as any);
            }

            if (item_id !== undefined) {
                localVarFormParams.set('item_id', item_id as any);
            }

            if (remote_location !== undefined) {
                localVarFormParams.set('remote_location', remote_location as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a file as deleted.
         * @summary Delete a file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFile.');
            }
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initializes a file download.
         * @summary Download one file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/files/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific file.
         * @summary Get one file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFile.');
            }
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all files.
         * @summary Get all files
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(start?: number, limit?: number, include_deleted_files?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (include_deleted_files !== undefined) {
                localVarQueryParameter['include_deleted_files'] = include_deleted_files;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Link a remote file to an item
         * @param {string} [item_type] 
         * @param {number} [item_id] 
         * @param {string} [remote_id] 
         * @param {string} [remote_location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkFileToItem(item_type?: string, item_id?: number, remote_id?: string, remote_location?: string, options: any = {}): FetchArgs {
            const localVarPath = `/files/remoteLink`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (item_type !== undefined) {
                localVarFormParams.set('item_type', item_type as any);
            }

            if (item_id !== undefined) {
                localVarFormParams.set('item_id', item_id as any);
            }

            if (remote_id !== undefined) {
                localVarFormParams.set('remote_id', remote_id as any);
            }

            if (remote_location !== undefined) {
                localVarFormParams.set('remote_location', remote_location as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a file.
         * @summary Update file details
         * @param {number} id The ID of the file
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(id: number, name?: string, description?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFile.');
            }
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('description', description as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lets you upload a file and associate it with a deal, person, organization, activity or product. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
         * @summary Add file
         * @param {Blob} [file] 
         * @param {number} [deal_id] 
         * @param {number} [person_id] 
         * @param {number} [org_id] 
         * @param {number} [product_id] 
         * @param {number} [activity_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFile(file?: Blob, deal_id?: number, person_id?: number, org_id?: number, product_id?: number, activity_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddFileResponse200> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).addFile(file, deal_id, person_id, org_id, product_id, activity_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Create a remote file and link it to an item
         * @param {string} [file_type] 
         * @param {string} [title] 
         * @param {string} [item_type] 
         * @param {number} [item_id] 
         * @param {string} [remote_location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFileAndLinkIt(file_type?: string, title?: string, item_type?: string, item_id?: number, remote_location?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddFileAndLinkItResponse200> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).addFileAndLinkIt(file_type, title, item_type, item_id, remote_location, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a file as deleted.
         * @summary Delete a file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFileResponse200> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).deleteFile(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Initializes a file download.
         * @summary Download one file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).downloadFile(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific file.
         * @summary Get one file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFileResponse200> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).getFile(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all files.
         * @summary Get all files
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFilesResponse200> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).getFiles(start, limit, include_deleted_files, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Link a remote file to an item
         * @param {string} [item_type] 
         * @param {number} [item_id] 
         * @param {string} [remote_id] 
         * @param {string} [remote_location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkFileToItem(item_type?: string, item_id?: number, remote_id?: string, remote_location?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LinkFileToItemResponse200> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).linkFileToItem(item_type, item_id, remote_id, remote_location, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of a file.
         * @summary Update file details
         * @param {number} id The ID of the file
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(id: number, name?: string, description?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateFileResponse200> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).updateFile(id, name, description, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lets you upload a file and associate it with a deal, person, organization, activity or product. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
         * @summary Add file
         * @param {Blob} [file] 
         * @param {number} [deal_id] 
         * @param {number} [person_id] 
         * @param {number} [org_id] 
         * @param {number} [product_id] 
         * @param {number} [activity_id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFile(file?: Blob, deal_id?: number, person_id?: number, org_id?: number, product_id?: number, activity_id?: number, options?: any) {
            return FilesApiFp(configuration).addFile(file, deal_id, person_id, org_id, product_id, activity_id, options)(fetch, basePath);
        },
        /**
         * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Create a remote file and link it to an item
         * @param {string} [file_type] 
         * @param {string} [title] 
         * @param {string} [item_type] 
         * @param {number} [item_id] 
         * @param {string} [remote_location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFileAndLinkIt(file_type?: string, title?: string, item_type?: string, item_id?: number, remote_location?: string, options?: any) {
            return FilesApiFp(configuration).addFileAndLinkIt(file_type, title, item_type, item_id, remote_location, options)(fetch, basePath);
        },
        /**
         * Marks a file as deleted.
         * @summary Delete a file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id: number, options?: any) {
            return FilesApiFp(configuration).deleteFile(id, options)(fetch, basePath);
        },
        /**
         * Initializes a file download.
         * @summary Download one file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id: number, options?: any) {
            return FilesApiFp(configuration).downloadFile(id, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific file.
         * @summary Get one file
         * @param {number} id The ID of the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: number, options?: any) {
            return FilesApiFp(configuration).getFile(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all files.
         * @summary Get all files
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
            return FilesApiFp(configuration).getFiles(start, limit, include_deleted_files, sort, options)(fetch, basePath);
        },
        /**
         * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
         * @summary Link a remote file to an item
         * @param {string} [item_type] 
         * @param {number} [item_id] 
         * @param {string} [remote_id] 
         * @param {string} [remote_location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkFileToItem(item_type?: string, item_id?: number, remote_id?: string, remote_location?: string, options?: any) {
            return FilesApiFp(configuration).linkFileToItem(item_type, item_id, remote_id, remote_location, options)(fetch, basePath);
        },
        /**
         * Updates the properties of a file.
         * @summary Update file details
         * @param {number} id The ID of the file
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(id: number, name?: string, description?: string, options?: any) {
            return FilesApiFp(configuration).updateFile(id, name, description, options)(fetch, basePath);
        },
    };
};

/**
 * FilesApi - interface
 * @export
 * @interface FilesApi
 */
export interface FilesApiInterface {
    /**
     * Lets you upload a file and associate it with a deal, person, organization, activity or product. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
     * @summary Add file
     * @param {Blob} [file] 
     * @param {number} [deal_id] 
     * @param {number} [person_id] 
     * @param {number} [org_id] 
     * @param {number} [product_id] 
     * @param {number} [activity_id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    addFile(file?: Blob, deal_id?: number, person_id?: number, org_id?: number, product_id?: number, activity_id?: number, options?: any): Promise<AddFileResponse200>;

    /**
     * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
     * @summary Create a remote file and link it to an item
     * @param {string} [file_type] 
     * @param {string} [title] 
     * @param {string} [item_type] 
     * @param {number} [item_id] 
     * @param {string} [remote_location] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    addFileAndLinkIt(file_type?: string, title?: string, item_type?: string, item_id?: number, remote_location?: string, options?: any): Promise<AddFileAndLinkItResponse200>;

    /**
     * Marks a file as deleted.
     * @summary Delete a file
     * @param {number} id The ID of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    deleteFile(id: number, options?: any): Promise<DeleteFileResponse200>;

    /**
     * Initializes a file download.
     * @summary Download one file
     * @param {number} id The ID of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    downloadFile(id: number, options?: any): Promise<string>;

    /**
     * Returns data about a specific file.
     * @summary Get one file
     * @param {number} id The ID of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    getFile(id: number, options?: any): Promise<GetFileResponse200>;

    /**
     * Returns data about all files.
     * @summary Get all files
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    getFiles(start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): Promise<GetFilesResponse200>;

    /**
     * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
     * @summary Link a remote file to an item
     * @param {string} [item_type] 
     * @param {number} [item_id] 
     * @param {string} [remote_id] 
     * @param {string} [remote_location] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    linkFileToItem(item_type?: string, item_id?: number, remote_id?: string, remote_location?: string, options?: any): Promise<LinkFileToItemResponse200>;

    /**
     * Updates the properties of a file.
     * @summary Update file details
     * @param {number} id The ID of the file
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiInterface
     */
    updateFile(id: number, name?: string, description?: string, options?: any): Promise<UpdateFileResponse200>;

}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI implements FilesApiInterface {
    /**
     * Lets you upload a file and associate it with a deal, person, organization, activity or product. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a file</a>.
     * @summary Add file
     * @param {Blob} [file] 
     * @param {number} [deal_id] 
     * @param {number} [person_id] 
     * @param {number} [org_id] 
     * @param {number} [product_id] 
     * @param {number} [activity_id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public addFile(file?: Blob, deal_id?: number, person_id?: number, org_id?: number, product_id?: number, activity_id?: number, options?: any) {
        return FilesApiFp(this.configuration).addFile(file, deal_id, person_id, org_id, product_id, activity_id, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new empty file in the remote location (`googledrive`) that will be linked to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
     * @summary Create a remote file and link it to an item
     * @param {string} [file_type] 
     * @param {string} [title] 
     * @param {string} [item_type] 
     * @param {number} [item_id] 
     * @param {string} [remote_location] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public addFileAndLinkIt(file_type?: string, title?: string, item_type?: string, item_id?: number, remote_location?: string, options?: any) {
        return FilesApiFp(this.configuration).addFileAndLinkIt(file_type, title, item_type, item_id, remote_location, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a file as deleted.
     * @summary Delete a file
     * @param {number} id The ID of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(id: number, options?: any) {
        return FilesApiFp(this.configuration).deleteFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * Initializes a file download.
     * @summary Download one file
     * @param {number} id The ID of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public downloadFile(id: number, options?: any) {
        return FilesApiFp(this.configuration).downloadFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific file.
     * @summary Get one file
     * @param {number} id The ID of the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(id: number, options?: any) {
        return FilesApiFp(this.configuration).getFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all files.
     * @summary Get all files
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFiles(start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
        return FilesApiFp(this.configuration).getFiles(start, limit, include_deleted_files, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Links an existing remote file (`googledrive`) to the item you supply. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-remote-file\" target=\"_blank\" rel=\"noopener noreferrer\">adding a remote file</a>.
     * @summary Link a remote file to an item
     * @param {string} [item_type] 
     * @param {number} [item_id] 
     * @param {string} [remote_id] 
     * @param {string} [remote_location] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public linkFileToItem(item_type?: string, item_id?: number, remote_id?: string, remote_location?: string, options?: any) {
        return FilesApiFp(this.configuration).linkFileToItem(item_type, item_id, remote_id, remote_location, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of a file.
     * @summary Update file details
     * @param {number} id The ID of the file
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public updateFile(id: number, name?: string, description?: string, options?: any) {
        return FilesApiFp(this.configuration).updateFile(id, name, description, options)(this.fetch, this.basePath);
    }

}
/**
 * FiltersApi - fetch parameter creator
 * @export
 */
export const FiltersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Add a new filter
         * @param {AddFilterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilter(body?: AddFilterRequest, options: any = {}): FetchArgs {
            const localVarPath = `/filters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddFilterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a filter as deleted.
         * @summary Delete a filter
         * @param {number} id The ID of the filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilter(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFilter.');
            }
            const localVarPath = `/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple filters as deleted.
         * @summary Delete multiple filters in bulk
         * @param {string} ids The comma-separated filter IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilters(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteFilters.');
            }
            const localVarPath = `/filters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
         * @summary Get one filter
         * @param {number} id The ID of the filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFilter.');
            }
            const localVarPath = `/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. Additionally, an exact date must be inserted in YYYY-MM-DD format and an exact time in HH:MM. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Get all filter helpers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterHelpers(options: any = {}): FetchArgs {
            const localVarPath = `/filters/helpers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all filters.
         * @summary Get all filters
         * @param {string} [type] The types of filters to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(type?: string, options: any = {}): FetchArgs {
            const localVarPath = `/filters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing filter.
         * @summary Update filter
         * @param {number} id The ID of the filter
         * @param {UpdateFilterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFilter(id: number, body?: UpdateFilterRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFilter.');
            }
            const localVarPath = `/filters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateFilterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FiltersApi - functional programming interface
 * @export
 */
export const FiltersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Add a new filter
         * @param {AddFilterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilter(body?: AddFilterRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostFilterResponse200> {
            const localVarFetchArgs = FiltersApiFetchParamCreator(configuration).addFilter(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a filter as deleted.
         * @summary Delete a filter
         * @param {number} id The ID of the filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilter(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFilterResponse200> {
            const localVarFetchArgs = FiltersApiFetchParamCreator(configuration).deleteFilter(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple filters as deleted.
         * @summary Delete multiple filters in bulk
         * @param {string} ids The comma-separated filter IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilters(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFiltersResponse200> {
            const localVarFetchArgs = FiltersApiFetchParamCreator(configuration).deleteFilters(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
         * @summary Get one filter
         * @param {number} id The ID of the filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFilterResponse200> {
            const localVarFetchArgs = FiltersApiFetchParamCreator(configuration).getFilter(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. Additionally, an exact date must be inserted in YYYY-MM-DD format and an exact time in HH:MM. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Get all filter helpers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterHelpers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = FiltersApiFetchParamCreator(configuration).getFilterHelpers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all filters.
         * @summary Get all filters
         * @param {string} [type] The types of filters to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFiltersResponse200> {
            const localVarFetchArgs = FiltersApiFetchParamCreator(configuration).getFilters(type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an existing filter.
         * @summary Update filter
         * @param {number} id The ID of the filter
         * @param {UpdateFilterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFilter(id: number, body?: UpdateFilterRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostFilterResponse200> {
            const localVarFetchArgs = FiltersApiFetchParamCreator(configuration).updateFilter(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FiltersApi - factory interface
 * @export
 */
export const FiltersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Add a new filter
         * @param {AddFilterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFilter(body?: AddFilterRequest, options?: any) {
            return FiltersApiFp(configuration).addFilter(body, options)(fetch, basePath);
        },
        /**
         * Marks a filter as deleted.
         * @summary Delete a filter
         * @param {number} id The ID of the filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilter(id: number, options?: any) {
            return FiltersApiFp(configuration).deleteFilter(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple filters as deleted.
         * @summary Delete multiple filters in bulk
         * @param {string} ids The comma-separated filter IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilters(ids: string, options?: any) {
            return FiltersApiFp(configuration).deleteFilters(ids, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
         * @summary Get one filter
         * @param {number} id The ID of the filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilter(id: number, options?: any) {
            return FiltersApiFp(configuration).getFilter(id, options)(fetch, basePath);
        },
        /**
         * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. Additionally, an exact date must be inserted in YYYY-MM-DD format and an exact time in HH:MM. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
         * @summary Get all filter helpers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterHelpers(options?: any) {
            return FiltersApiFp(configuration).getFilterHelpers(options)(fetch, basePath);
        },
        /**
         * Returns data about all filters.
         * @summary Get all filters
         * @param {string} [type] The types of filters to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(type?: string, options?: any) {
            return FiltersApiFp(configuration).getFilters(type, options)(fetch, basePath);
        },
        /**
         * Updates an existing filter.
         * @summary Update filter
         * @param {number} id The ID of the filter
         * @param {UpdateFilterRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFilter(id: number, body?: UpdateFilterRequest, options?: any) {
            return FiltersApiFp(configuration).updateFilter(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * FiltersApi - interface
 * @export
 * @interface FiltersApi
 */
export interface FiltersApiInterface {
    /**
     * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @summary Add a new filter
     * @param {AddFilterRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    addFilter(body?: AddFilterRequest, options?: any): Promise<PostFilterResponse200>;

    /**
     * Marks a filter as deleted.
     * @summary Delete a filter
     * @param {number} id The ID of the filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    deleteFilter(id: number, options?: any): Promise<DeleteFilterResponse200>;

    /**
     * Marks multiple filters as deleted.
     * @summary Delete multiple filters in bulk
     * @param {string} ids The comma-separated filter IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    deleteFilters(ids: string, options?: any): Promise<DeleteFiltersResponse200>;

    /**
     * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
     * @summary Get one filter
     * @param {number} id The ID of the filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    getFilter(id: number, options?: any): Promise<GetFilterResponse200>;

    /**
     * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. Additionally, an exact date must be inserted in YYYY-MM-DD format and an exact time in HH:MM. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @summary Get all filter helpers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    getFilterHelpers(options?: any): Promise<any>;

    /**
     * Returns data about all filters.
     * @summary Get all filters
     * @param {string} [type] The types of filters to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    getFilters(type?: string, options?: any): Promise<GetFiltersResponse200>;

    /**
     * Updates an existing filter.
     * @summary Update filter
     * @param {number} id The ID of the filter
     * @param {UpdateFilterRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApiInterface
     */
    updateFilter(id: number, body?: UpdateFilterRequest, options?: any): Promise<PostFilterResponse200>;

}

/**
 * FiltersApi - object-oriented interface
 * @export
 * @class FiltersApi
 * @extends {BaseAPI}
 */
export class FiltersApi extends BaseAPI implements FiltersApiInterface {
    /**
     * Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with 'AND', and only two second level condition groups are supported of which one must be glued with 'AND' and the second with 'OR'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @summary Add a new filter
     * @param {AddFilterRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public addFilter(body?: AddFilterRequest, options?: any) {
        return FiltersApiFp(this.configuration).addFilter(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a filter as deleted.
     * @summary Delete a filter
     * @param {number} id The ID of the filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public deleteFilter(id: number, options?: any) {
        return FiltersApiFp(this.configuration).deleteFilter(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple filters as deleted.
     * @summary Delete multiple filters in bulk
     * @param {string} ids The comma-separated filter IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public deleteFilters(ids: string, options?: any) {
        return FiltersApiFp(this.configuration).deleteFilters(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific filter. Note that this also returns the condition lines of the filter.
     * @summary Get one filter
     * @param {number} id The ID of the filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilter(id: number, options?: any) {
        return FiltersApiFp(this.configuration).getFilter(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\"/docs/api/v1/Filters#addFilter\">add</a> or <a href=\"/docs/api/v1/Filters#updateFilter\">update</a> filters. Additionally, an exact date must be inserted in YYYY-MM-DD format and an exact time in HH:MM. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-filter\" target=\"_blank\" rel=\"noopener noreferrer\">adding a filter</a>.
     * @summary Get all filter helpers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilterHelpers(options?: any) {
        return FiltersApiFp(this.configuration).getFilterHelpers(options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all filters.
     * @summary Get all filters
     * @param {string} [type] The types of filters to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getFilters(type?: string, options?: any) {
        return FiltersApiFp(this.configuration).getFilters(type, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an existing filter.
     * @summary Update filter
     * @param {number} id The ID of the filter
     * @param {UpdateFilterRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public updateFilter(id: number, body?: UpdateFilterRequest, options?: any) {
        return FiltersApiFp(this.configuration).updateFilter(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * GoalsApi - fetch parameter creator
 * @export
 */
export const GoalsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
         * @summary Add a new goal
         * @param {AddGoalRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGoal(body?: AddGoalRequest, options: any = {}): FetchArgs {
            const localVarPath = `/goals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddGoalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a goal as deleted.
         * @summary Delete existing goal
         * @param {string} id The ID of the goal to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGoal.');
            }
            const localVarPath = `/goals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the progress of a goal for the specified period.
         * @summary Get result of a goal
         * @param {string} id The ID of the goal that the results are looked for
         * @param {string} period_start The start date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or after the goal duration start date.
         * @param {string} period_end The end date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or before the goal duration end date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalResult(id: string, period_start: string, period_end: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGoalResult.');
            }
            // verify required parameter 'period_start' is not null or undefined
            if (period_start === null || period_start === undefined) {
                throw new RequiredError('period_start','Required parameter period_start was null or undefined when calling getGoalResult.');
            }
            // verify required parameter 'period_end' is not null or undefined
            if (period_end === null || period_end === undefined) {
                throw new RequiredError('period_end','Required parameter period_end was null or undefined when calling getGoalResult.');
            }
            const localVarPath = `/goals/{id}/results`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (period_start !== undefined) {
                localVarQueryParameter['period.start'] = (period_start as any).toISOString();
            }

            if (period_end !== undefined) {
                localVarQueryParameter['period.end'] = (period_end as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
         * @summary Find goals
         * @param {string} [type_name] The type of the goal. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [title] The title of the goal
         * @param {boolean} [is_active] Whether the goal is active or not
         * @param {number} [assignee_id] The ID of the user who&#x27;s goal to fetch. When omitted, only your goals will be returned.
         * @param {string} [assignee_type] The type of the goal&#x27;s assignee. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [expected_outcome_target] The numeric value of the outcome. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [expected_outcome_tracking_metric] The tracking metric of the expected outcome of the goal. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [expected_outcome_currency_id] The numeric ID of the goal&#x27;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_pipeline_id] The ID of the pipeline or &#x60;null&#x60; for all pipelines. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_stage_id] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_activity_type_id] The ID of the activity type. Applicable to only &#x60;activities_completed&#x60; or &#x60;activities_added&#x60; types of goals. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [period_start] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
         * @param {string} [period_end] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(type_name?: string, title?: string, is_active?: boolean, assignee_id?: number, assignee_type?: string, expected_outcome_target?: number, expected_outcome_tracking_metric?: string, expected_outcome_currency_id?: number, type_params_pipeline_id?: number, type_params_stage_id?: number, type_params_activity_type_id?: number, period_start?: string, period_end?: string, options: any = {}): FetchArgs {
            const localVarPath = `/goals/find`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (type_name !== undefined) {
                localVarQueryParameter['type.name'] = type_name;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (is_active !== undefined) {
                localVarQueryParameter['is_active'] = is_active;
            }

            if (assignee_id !== undefined) {
                localVarQueryParameter['assignee.id'] = assignee_id;
            }

            if (assignee_type !== undefined) {
                localVarQueryParameter['assignee.type'] = assignee_type;
            }

            if (expected_outcome_target !== undefined) {
                localVarQueryParameter['expected_outcome.target'] = expected_outcome_target;
            }

            if (expected_outcome_tracking_metric !== undefined) {
                localVarQueryParameter['expected_outcome.tracking_metric'] = expected_outcome_tracking_metric;
            }

            if (expected_outcome_currency_id !== undefined) {
                localVarQueryParameter['expected_outcome.currency_id'] = expected_outcome_currency_id;
            }

            if (type_params_pipeline_id !== undefined) {
                localVarQueryParameter['type.params.pipeline_id'] = type_params_pipeline_id;
            }

            if (type_params_stage_id !== undefined) {
                localVarQueryParameter['type.params.stage_id'] = type_params_stage_id;
            }

            if (type_params_activity_type_id !== undefined) {
                localVarQueryParameter['type.params.activity_type_id'] = type_params_activity_type_id;
            }

            if (period_start !== undefined) {
                localVarQueryParameter['period.start'] = (period_start as any).toISOString();
            }

            if (period_end !== undefined) {
                localVarQueryParameter['period.end'] = (period_end as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing goal.
         * @summary Update existing goal
         * @param {string} id The ID of the goal to be updated
         * @param {BasicGoalRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(id: string, body?: BasicGoalRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGoal.');
            }
            const localVarPath = `/goals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BasicGoalRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
         * @summary Add a new goal
         * @param {AddGoalRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGoal(body?: AddGoalRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrUpdateGoalResponse200> {
            const localVarFetchArgs = GoalsApiFetchParamCreator(configuration).addGoal(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a goal as deleted.
         * @summary Delete existing goal
         * @param {string} id The ID of the goal to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteGoalResponse200> {
            const localVarFetchArgs = GoalsApiFetchParamCreator(configuration).deleteGoal(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the progress of a goal for the specified period.
         * @summary Get result of a goal
         * @param {string} id The ID of the goal that the results are looked for
         * @param {string} period_start The start date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or after the goal duration start date.
         * @param {string} period_end The end date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or before the goal duration end date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalResult(id: string, period_start: string, period_end: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetGoalResultResponse200> {
            const localVarFetchArgs = GoalsApiFetchParamCreator(configuration).getGoalResult(id, period_start, period_end, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
         * @summary Find goals
         * @param {string} [type_name] The type of the goal. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [title] The title of the goal
         * @param {boolean} [is_active] Whether the goal is active or not
         * @param {number} [assignee_id] The ID of the user who&#x27;s goal to fetch. When omitted, only your goals will be returned.
         * @param {string} [assignee_type] The type of the goal&#x27;s assignee. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [expected_outcome_target] The numeric value of the outcome. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [expected_outcome_tracking_metric] The tracking metric of the expected outcome of the goal. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [expected_outcome_currency_id] The numeric ID of the goal&#x27;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_pipeline_id] The ID of the pipeline or &#x60;null&#x60; for all pipelines. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_stage_id] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_activity_type_id] The ID of the activity type. Applicable to only &#x60;activities_completed&#x60; or &#x60;activities_added&#x60; types of goals. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [period_start] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
         * @param {string} [period_end] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(type_name?: string, title?: string, is_active?: boolean, assignee_id?: number, assignee_type?: string, expected_outcome_target?: number, expected_outcome_tracking_metric?: string, expected_outcome_currency_id?: number, type_params_pipeline_id?: number, type_params_stage_id?: number, type_params_activity_type_id?: number, period_start?: string, period_end?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetGoalsResponse200> {
            const localVarFetchArgs = GoalsApiFetchParamCreator(configuration).getGoals(type_name, title, is_active, assignee_id, assignee_type, expected_outcome_target, expected_outcome_tracking_metric, expected_outcome_currency_id, type_params_pipeline_id, type_params_stage_id, type_params_activity_type_id, period_start, period_end, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an existing goal.
         * @summary Update existing goal
         * @param {string} id The ID of the goal to be updated
         * @param {BasicGoalRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(id: string, body?: BasicGoalRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrUpdateGoalResponse200> {
            const localVarFetchArgs = GoalsApiFetchParamCreator(configuration).updateGoal(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
         * @summary Add a new goal
         * @param {AddGoalRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGoal(body?: AddGoalRequest, options?: any) {
            return GoalsApiFp(configuration).addGoal(body, options)(fetch, basePath);
        },
        /**
         * Marks a goal as deleted.
         * @summary Delete existing goal
         * @param {string} id The ID of the goal to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(id: string, options?: any) {
            return GoalsApiFp(configuration).deleteGoal(id, options)(fetch, basePath);
        },
        /**
         * Gets the progress of a goal for the specified period.
         * @summary Get result of a goal
         * @param {string} id The ID of the goal that the results are looked for
         * @param {string} period_start The start date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or after the goal duration start date.
         * @param {string} period_end The end date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or before the goal duration end date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalResult(id: string, period_start: string, period_end: string, options?: any) {
            return GoalsApiFp(configuration).getGoalResult(id, period_start, period_end, options)(fetch, basePath);
        },
        /**
         * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
         * @summary Find goals
         * @param {string} [type_name] The type of the goal. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [title] The title of the goal
         * @param {boolean} [is_active] Whether the goal is active or not
         * @param {number} [assignee_id] The ID of the user who&#x27;s goal to fetch. When omitted, only your goals will be returned.
         * @param {string} [assignee_type] The type of the goal&#x27;s assignee. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [expected_outcome_target] The numeric value of the outcome. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [expected_outcome_tracking_metric] The tracking metric of the expected outcome of the goal. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [expected_outcome_currency_id] The numeric ID of the goal&#x27;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_pipeline_id] The ID of the pipeline or &#x60;null&#x60; for all pipelines. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_stage_id] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone&#x27;s goals will be returned.
         * @param {number} [type_params_activity_type_id] The ID of the activity type. Applicable to only &#x60;activities_completed&#x60; or &#x60;activities_added&#x60; types of goals. If provided, everyone&#x27;s goals will be returned.
         * @param {string} [period_start] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
         * @param {string} [period_end] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(type_name?: string, title?: string, is_active?: boolean, assignee_id?: number, assignee_type?: string, expected_outcome_target?: number, expected_outcome_tracking_metric?: string, expected_outcome_currency_id?: number, type_params_pipeline_id?: number, type_params_stage_id?: number, type_params_activity_type_id?: number, period_start?: string, period_end?: string, options?: any) {
            return GoalsApiFp(configuration).getGoals(type_name, title, is_active, assignee_id, assignee_type, expected_outcome_target, expected_outcome_tracking_metric, expected_outcome_currency_id, type_params_pipeline_id, type_params_stage_id, type_params_activity_type_id, period_start, period_end, options)(fetch, basePath);
        },
        /**
         * Updates an existing goal.
         * @summary Update existing goal
         * @param {string} id The ID of the goal to be updated
         * @param {BasicGoalRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(id: string, body?: BasicGoalRequest, options?: any) {
            return GoalsApiFp(configuration).updateGoal(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * GoalsApi - interface
 * @export
 * @interface GoalsApi
 */
export interface GoalsApiInterface {
    /**
     * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     * @summary Add a new goal
     * @param {AddGoalRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    addGoal(body?: AddGoalRequest, options?: any): Promise<AddOrUpdateGoalResponse200>;

    /**
     * Marks a goal as deleted.
     * @summary Delete existing goal
     * @param {string} id The ID of the goal to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    deleteGoal(id: string, options?: any): Promise<DeleteGoalResponse200>;

    /**
     * Gets the progress of a goal for the specified period.
     * @summary Get result of a goal
     * @param {string} id The ID of the goal that the results are looked for
     * @param {string} period_start The start date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or after the goal duration start date.
     * @param {string} period_end The end date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or before the goal duration end date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    getGoalResult(id: string, period_start: string, period_end: string, options?: any): Promise<GetGoalResultResponse200>;

    /**
     * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     * @summary Find goals
     * @param {string} [type_name] The type of the goal. If provided, everyone&#x27;s goals will be returned.
     * @param {string} [title] The title of the goal
     * @param {boolean} [is_active] Whether the goal is active or not
     * @param {number} [assignee_id] The ID of the user who&#x27;s goal to fetch. When omitted, only your goals will be returned.
     * @param {string} [assignee_type] The type of the goal&#x27;s assignee. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [expected_outcome_target] The numeric value of the outcome. If provided, everyone&#x27;s goals will be returned.
     * @param {string} [expected_outcome_tracking_metric] The tracking metric of the expected outcome of the goal. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [expected_outcome_currency_id] The numeric ID of the goal&#x27;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [type_params_pipeline_id] The ID of the pipeline or &#x60;null&#x60; for all pipelines. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [type_params_stage_id] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [type_params_activity_type_id] The ID of the activity type. Applicable to only &#x60;activities_completed&#x60; or &#x60;activities_added&#x60; types of goals. If provided, everyone&#x27;s goals will be returned.
     * @param {string} [period_start] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
     * @param {string} [period_end] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    getGoals(type_name?: string, title?: string, is_active?: boolean, assignee_id?: number, assignee_type?: string, expected_outcome_target?: number, expected_outcome_tracking_metric?: string, expected_outcome_currency_id?: number, type_params_pipeline_id?: number, type_params_stage_id?: number, type_params_activity_type_id?: number, period_start?: string, period_end?: string, options?: any): Promise<GetGoalsResponse200>;

    /**
     * Updates an existing goal.
     * @summary Update existing goal
     * @param {string} id The ID of the goal to be updated
     * @param {BasicGoalRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApiInterface
     */
    updateGoal(id: string, body?: BasicGoalRequest, options?: any): Promise<AddOrUpdateGoalResponse200>;

}

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI implements GoalsApiInterface {
    /**
     * Adds a new goal. Along with adding a new goal, a report is created to track the progress of your goal.
     * @summary Add a new goal
     * @param {AddGoalRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public addGoal(body?: AddGoalRequest, options?: any) {
        return GoalsApiFp(this.configuration).addGoal(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a goal as deleted.
     * @summary Delete existing goal
     * @param {string} id The ID of the goal to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public deleteGoal(id: string, options?: any) {
        return GoalsApiFp(this.configuration).deleteGoal(id, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the progress of a goal for the specified period.
     * @summary Get result of a goal
     * @param {string} id The ID of the goal that the results are looked for
     * @param {string} period_start The start date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or after the goal duration start date.
     * @param {string} period_end The end date of the period for which to find progress of a goal. Date in format of YYYY-MM-DD. This date must be the same or before the goal duration end date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getGoalResult(id: string, period_start: string, period_end: string, options?: any) {
        return GoalsApiFp(this.configuration).getGoalResult(id, period_start, period_end, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about goals based on criteria. For searching, append `{searchField}={searchValue}` to the URL, where `searchField` can be any one of the lowest-level fields in dot-notation (e.g. `type.params.pipeline_id`; `title`). `searchValue` should be the value you are looking for on that field. Additionally, `is_active=<true|false>` can be provided to search for only active/inactive goals. When providing `period.start`, `period.end` must also be provided and vice versa.
     * @summary Find goals
     * @param {string} [type_name] The type of the goal. If provided, everyone&#x27;s goals will be returned.
     * @param {string} [title] The title of the goal
     * @param {boolean} [is_active] Whether the goal is active or not
     * @param {number} [assignee_id] The ID of the user who&#x27;s goal to fetch. When omitted, only your goals will be returned.
     * @param {string} [assignee_type] The type of the goal&#x27;s assignee. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [expected_outcome_target] The numeric value of the outcome. If provided, everyone&#x27;s goals will be returned.
     * @param {string} [expected_outcome_tracking_metric] The tracking metric of the expected outcome of the goal. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [expected_outcome_currency_id] The numeric ID of the goal&#x27;s currency. Only applicable to goals with &#x60;expected_outcome.tracking_metric&#x60; with value &#x60;sum&#x60;. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [type_params_pipeline_id] The ID of the pipeline or &#x60;null&#x60; for all pipelines. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [type_params_stage_id] The ID of the stage. Applicable to only &#x60;deals_progressed&#x60; type of goals. If provided, everyone&#x27;s goals will be returned.
     * @param {number} [type_params_activity_type_id] The ID of the activity type. Applicable to only &#x60;activities_completed&#x60; or &#x60;activities_added&#x60; types of goals. If provided, everyone&#x27;s goals will be returned.
     * @param {string} [period_start] The start date of the period for which to find goals. Date in format of YYYY-MM-DD. When &#x60;period.start&#x60; is provided, &#x60;period.end&#x60; must be provided too.
     * @param {string} [period_end] The end date of the period for which to find goals. Date in format of YYYY-MM-DD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getGoals(type_name?: string, title?: string, is_active?: boolean, assignee_id?: number, assignee_type?: string, expected_outcome_target?: number, expected_outcome_tracking_metric?: string, expected_outcome_currency_id?: number, type_params_pipeline_id?: number, type_params_stage_id?: number, type_params_activity_type_id?: number, period_start?: string, period_end?: string, options?: any) {
        return GoalsApiFp(this.configuration).getGoals(type_name, title, is_active, assignee_id, assignee_type, expected_outcome_target, expected_outcome_tracking_metric, expected_outcome_currency_id, type_params_pipeline_id, type_params_stage_id, type_params_activity_type_id, period_start, period_end, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an existing goal.
     * @summary Update existing goal
     * @param {string} id The ID of the goal to be updated
     * @param {BasicGoalRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public updateGoal(id: string, body?: BasicGoalRequest, options?: any) {
        return GoalsApiFp(this.configuration).updateGoal(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ItemSearchApi - fetch parameter creator
 * @export
 */
export const ItemSearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {string} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItem(term: string, item_types?: string, fields?: string, search_for_related_items?: boolean, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling searchItem.');
            }
            const localVarPath = `/itemSearch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (item_types !== undefined) {
                localVarQueryParameter['item_types'] = item_types;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (search_for_related_items !== undefined) {
                localVarQueryParameter['search_for_related_items'] = search_for_related_items;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} field_type The type of the field to perform the search from
         * @param {string} field_key The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields&#x27; API GET methods (dealFields, personFields, etc.).
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
         * @param {boolean} [return_item_ids] Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItemByField(term: string, field_type: string, field_key: string, exact_match?: boolean, return_item_ids?: boolean, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling searchItemByField.');
            }
            // verify required parameter 'field_type' is not null or undefined
            if (field_type === null || field_type === undefined) {
                throw new RequiredError('field_type','Required parameter field_type was null or undefined when calling searchItemByField.');
            }
            // verify required parameter 'field_key' is not null or undefined
            if (field_key === null || field_key === undefined) {
                throw new RequiredError('field_key','Required parameter field_key was null or undefined when calling searchItemByField.');
            }
            const localVarPath = `/itemSearch/field`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (field_type !== undefined) {
                localVarQueryParameter['field_type'] = field_type;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (field_key !== undefined) {
                localVarQueryParameter['field_key'] = field_key;
            }

            if (return_item_ids !== undefined) {
                localVarQueryParameter['return_item_ids'] = return_item_ids;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemSearchApi - functional programming interface
 * @export
 */
export const ItemSearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {string} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItem(term: string, item_types?: string, fields?: string, search_for_related_items?: boolean, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchItemResponse200> {
            const localVarFetchArgs = ItemSearchApiFetchParamCreator(configuration).searchItem(term, item_types, fields, search_for_related_items, exact_match, include_fields, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} field_type The type of the field to perform the search from
         * @param {string} field_key The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields&#x27; API GET methods (dealFields, personFields, etc.).
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
         * @param {boolean} [return_item_ids] Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItemByField(term: string, field_type: string, field_key: string, exact_match?: boolean, return_item_ids?: boolean, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchItemByFieldResponse200> {
            const localVarFetchArgs = ItemSearchApiFetchParamCreator(configuration).searchItemByField(term, field_type, field_key, exact_match, return_item_ids, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItemSearchApi - factory interface
 * @export
 */
export const ItemSearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {string} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItem(term: string, item_types?: string, fields?: string, search_for_related_items?: boolean, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any) {
            return ItemSearchApiFp(configuration).searchItem(term, item_types, fields, search_for_related_items, exact_match, include_fields, start, limit, options)(fetch, basePath);
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} field_type The type of the field to perform the search from
         * @param {string} field_key The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields&#x27; API GET methods (dealFields, personFields, etc.).
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
         * @param {boolean} [return_item_ids] Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItemByField(term: string, field_type: string, field_key: string, exact_match?: boolean, return_item_ids?: boolean, start?: number, limit?: number, options?: any) {
            return ItemSearchApiFp(configuration).searchItemByField(term, field_type, field_key, exact_match, return_item_ids, start, limit, options)(fetch, basePath);
        },
    };
};

/**
 * ItemSearchApi - interface
 * @export
 * @interface ItemSearchApi
 */
export interface ItemSearchApiInterface {
    /**
     * Performs a search from your choice of item types and fields.
     * @summary Perform a search from multiple item types
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
     * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {string} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemSearchApiInterface
     */
    searchItem(term: string, item_types?: string, fields?: string, search_for_related_items?: boolean, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any): Promise<SearchItemResponse200>;

    /**
     * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     * @summary Perform a search using a specific field from an item type
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} field_type The type of the field to perform the search from
     * @param {string} field_key The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields&#x27; API GET methods (dealFields, personFields, etc.).
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
     * @param {boolean} [return_item_ids] Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemSearchApiInterface
     */
    searchItemByField(term: string, field_type: string, field_key: string, exact_match?: boolean, return_item_ids?: boolean, start?: number, limit?: number, options?: any): Promise<SearchItemByFieldResponse200>;

}

/**
 * ItemSearchApi - object-oriented interface
 * @export
 * @class ItemSearchApi
 * @extends {BaseAPI}
 */
export class ItemSearchApi extends BaseAPI implements ItemSearchApiInterface {
    /**
     * Performs a search from your choice of item types and fields.
     * @summary Perform a search from multiple item types
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
     * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {string} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemSearchApi
     */
    public searchItem(term: string, item_types?: string, fields?: string, search_for_related_items?: boolean, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any) {
        return ItemSearchApiFp(this.configuration).searchItem(term, item_types, fields, search_for_related_items, exact_match, include_fields, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     * @summary Perform a search using a specific field from an item type
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} field_type The type of the field to perform the search from
     * @param {string} field_key The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields&#x27; API GET methods (dealFields, personFields, etc.).
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. The search &lt;b&gt;is&lt;/b&gt; case sensitive.
     * @param {boolean} [return_item_ids] Whether to return the IDs of the matching items or not. When not set or set to &#x60;0&#x60; or &#x60;false&#x60;, only distinct values of the searched field are returned. When set to &#x60;1&#x60; or &#x60;true&#x60;, the ID of each found item is returned.
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemSearchApi
     */
    public searchItemByField(term: string, field_type: string, field_key: string, exact_match?: boolean, return_item_ids?: boolean, start?: number, limit?: number, options?: any) {
        return ItemSearchApiFp(this.configuration).searchItemByField(term, field_type, field_key, exact_match, return_item_ids, start, limit, options)(this.fetch, this.basePath);
    }

}
/**
 * LeadLabelsApi - fetch parameter creator
 * @export
 */
export const LeadLabelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a lead label.
         * @summary Add a lead label
         * @param {AddLeadLabelRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLeadLabel(body?: AddLeadLabelRequest, options: any = {}): FetchArgs {
            const localVarPath = `/leadLabels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddLeadLabelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific lead label.
         * @summary Delete a lead label
         * @param {string} id The ID of the lead label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeadLabel(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLeadLabel.');
            }
            const localVarPath = `/leadLabels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
         * @summary Get all lead labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadLabels(options: any = {}): FetchArgs {
            const localVarPath = `/leadLabels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates one or more properties of a lead label. Only properties included in the request will be updated. 
         * @summary Update a lead label
         * @param {string} id The ID of the lead label
         * @param {UpdateLeadLabelRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeadLabel(id: string, body?: UpdateLeadLabelRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLeadLabel.');
            }
            const localVarPath = `/leadLabels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLeadLabelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadLabelsApi - functional programming interface
 * @export
 */
export const LeadLabelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a lead label.
         * @summary Add a lead label
         * @param {AddLeadLabelRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLeadLabel(body?: AddLeadLabelRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrUpdateLeadLabelResponse200> {
            const localVarFetchArgs = LeadLabelsApiFetchParamCreator(configuration).addLeadLabel(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a specific lead label.
         * @summary Delete a lead label
         * @param {string} id The ID of the lead label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeadLabel(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeadIdResponse200> {
            const localVarFetchArgs = LeadLabelsApiFetchParamCreator(configuration).deleteLeadLabel(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
         * @summary Get all lead labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadLabels(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetLeadLabelsResponse200> {
            const localVarFetchArgs = LeadLabelsApiFetchParamCreator(configuration).getLeadLabels(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates one or more properties of a lead label. Only properties included in the request will be updated. 
         * @summary Update a lead label
         * @param {string} id The ID of the lead label
         * @param {UpdateLeadLabelRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeadLabel(id: string, body?: UpdateLeadLabelRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrUpdateLeadLabelResponse200> {
            const localVarFetchArgs = LeadLabelsApiFetchParamCreator(configuration).updateLeadLabel(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeadLabelsApi - factory interface
 * @export
 */
export const LeadLabelsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a lead label.
         * @summary Add a lead label
         * @param {AddLeadLabelRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLeadLabel(body?: AddLeadLabelRequest, options?: any) {
            return LeadLabelsApiFp(configuration).addLeadLabel(body, options)(fetch, basePath);
        },
        /**
         * Deletes a specific lead label.
         * @summary Delete a lead label
         * @param {string} id The ID of the lead label
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeadLabel(id: string, options?: any) {
            return LeadLabelsApiFp(configuration).deleteLeadLabel(id, options)(fetch, basePath);
        },
        /**
         * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
         * @summary Get all lead labels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadLabels(options?: any) {
            return LeadLabelsApiFp(configuration).getLeadLabels(options)(fetch, basePath);
        },
        /**
         * Updates one or more properties of a lead label. Only properties included in the request will be updated. 
         * @summary Update a lead label
         * @param {string} id The ID of the lead label
         * @param {UpdateLeadLabelRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeadLabel(id: string, body?: UpdateLeadLabelRequest, options?: any) {
            return LeadLabelsApiFp(configuration).updateLeadLabel(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * LeadLabelsApi - interface
 * @export
 * @interface LeadLabelsApi
 */
export interface LeadLabelsApiInterface {
    /**
     * Creates a lead label.
     * @summary Add a lead label
     * @param {AddLeadLabelRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApiInterface
     */
    addLeadLabel(body?: AddLeadLabelRequest, options?: any): Promise<AddOrUpdateLeadLabelResponse200>;

    /**
     * Deletes a specific lead label.
     * @summary Delete a lead label
     * @param {string} id The ID of the lead label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApiInterface
     */
    deleteLeadLabel(id: string, options?: any): Promise<LeadIdResponse200>;

    /**
     * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
     * @summary Get all lead labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApiInterface
     */
    getLeadLabels(options?: any): Promise<GetLeadLabelsResponse200>;

    /**
     * Updates one or more properties of a lead label. Only properties included in the request will be updated. 
     * @summary Update a lead label
     * @param {string} id The ID of the lead label
     * @param {UpdateLeadLabelRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApiInterface
     */
    updateLeadLabel(id: string, body?: UpdateLeadLabelRequest, options?: any): Promise<AddOrUpdateLeadLabelResponse200>;

}

/**
 * LeadLabelsApi - object-oriented interface
 * @export
 * @class LeadLabelsApi
 * @extends {BaseAPI}
 */
export class LeadLabelsApi extends BaseAPI implements LeadLabelsApiInterface {
    /**
     * Creates a lead label.
     * @summary Add a lead label
     * @param {AddLeadLabelRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public addLeadLabel(body?: AddLeadLabelRequest, options?: any) {
        return LeadLabelsApiFp(this.configuration).addLeadLabel(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a specific lead label.
     * @summary Delete a lead label
     * @param {string} id The ID of the lead label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public deleteLeadLabel(id: string, options?: any) {
        return LeadLabelsApiFp(this.configuration).deleteLeadLabel(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of all lead labels. This endpoint does not support pagination and all labels are always returned.
     * @summary Get all lead labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public getLeadLabels(options?: any) {
        return LeadLabelsApiFp(this.configuration).getLeadLabels(options)(this.fetch, this.basePath);
    }

    /**
     * Updates one or more properties of a lead label. Only properties included in the request will be updated. 
     * @summary Update a lead label
     * @param {string} id The ID of the lead label
     * @param {UpdateLeadLabelRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadLabelsApi
     */
    public updateLeadLabel(id: string, body?: UpdateLeadLabelRequest, options?: any) {
        return LeadLabelsApiFp(this.configuration).updateLeadLabel(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * LeadSourcesApi - fetch parameter creator
 * @export
 */
export const LeadSourcesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned. 
         * @summary Get all lead sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadSources(options: any = {}): FetchArgs {
            const localVarPath = `/leadSources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadSourcesApi - functional programming interface
 * @export
 */
export const LeadSourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned. 
         * @summary Get all lead sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadSources(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetLeadSourcesResponse200> {
            const localVarFetchArgs = LeadSourcesApiFetchParamCreator(configuration).getLeadSources(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeadSourcesApi - factory interface
 * @export
 */
export const LeadSourcesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned. 
         * @summary Get all lead sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeadSources(options?: any) {
            return LeadSourcesApiFp(configuration).getLeadSources(options)(fetch, basePath);
        },
    };
};

/**
 * LeadSourcesApi - interface
 * @export
 * @interface LeadSourcesApi
 */
export interface LeadSourcesApiInterface {
    /**
     * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned. 
     * @summary Get all lead sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadSourcesApiInterface
     */
    getLeadSources(options?: any): Promise<GetLeadSourcesResponse200>;

}

/**
 * LeadSourcesApi - object-oriented interface
 * @export
 * @class LeadSourcesApi
 * @extends {BaseAPI}
 */
export class LeadSourcesApi extends BaseAPI implements LeadSourcesApiInterface {
    /**
     * Returns all lead sources. Please note that the list of lead sources is fixed, it cannot be modified. All leads created through the Pipedrive API will have a lead source `API` assigned. 
     * @summary Get all lead sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadSourcesApi
     */
    public getLeadSources(options?: any) {
        return LeadSourcesApiFp(this.configuration).getLeadSources(options)(this.fetch, this.basePath);
    }

}
/**
 * LeadsApi - fetch parameter creator
 * @export
 */
export const LeadsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here's the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values tutorial</a>.
         * @summary Add a lead
         * @param {AddLeadRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLead(body?: AddLeadRequest, options: any = {}): FetchArgs {
            const localVarPath = `/leads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddLeadRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific lead.
         * @summary Delete a lead
         * @param {string} id The ID of the lead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLead(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLead.');
            }
            const localVarPath = `/leads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific lead. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals.
         * @summary Get one lead
         * @param {string} id The ID of the lead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLead(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLead.');
            }
            const localVarPath = `/leads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. 
         * @summary Get all leads
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [archived_status] Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
         * @param {number} [owner_id] If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
         * @param {number} [person_id] If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
         * @param {number} [organization_id] If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeads(limit?: number, start?: number, archived_status?: string, owner_id?: number, person_id?: number, organization_id?: number, filter_id?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/leads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (archived_status !== undefined) {
                localVarQueryParameter['archived_status'] = archived_status;
            }

            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLeads(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling searchLeads.');
            }
            const localVarPath = `/leads/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields values tutorial</a>.
         * @summary Update a lead
         * @param {string} id The ID of the lead
         * @param {UpdateLeadRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLead(id: string, body?: UpdateLeadRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLead.');
            }
            const localVarPath = `/leads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLeadRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadsApi - functional programming interface
 * @export
 */
export const LeadsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here's the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values tutorial</a>.
         * @summary Add a lead
         * @param {AddLeadRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLead(body?: AddLeadRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneLeadResponse200> {
            const localVarFetchArgs = LeadsApiFetchParamCreator(configuration).addLead(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a specific lead.
         * @summary Delete a lead
         * @param {string} id The ID of the lead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLead(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeadIdResponse200> {
            const localVarFetchArgs = LeadsApiFetchParamCreator(configuration).deleteLead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of a specific lead. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals.
         * @summary Get one lead
         * @param {string} id The ID of the lead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLead(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneLeadResponse200> {
            const localVarFetchArgs = LeadsApiFetchParamCreator(configuration).getLead(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. 
         * @summary Get all leads
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [archived_status] Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
         * @param {number} [owner_id] If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
         * @param {number} [person_id] If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
         * @param {number} [organization_id] If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeads(limit?: number, start?: number, archived_status?: string, owner_id?: number, person_id?: number, organization_id?: number, filter_id?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetLeadsResponse200> {
            const localVarFetchArgs = LeadsApiFetchParamCreator(configuration).getLeads(limit, start, archived_status, owner_id, person_id, organization_id, filter_id, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLeads(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchLeadsResponse200> {
            const localVarFetchArgs = LeadsApiFetchParamCreator(configuration).searchLeads(term, fields, exact_match, person_id, organization_id, include_fields, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields values tutorial</a>.
         * @summary Update a lead
         * @param {string} id The ID of the lead
         * @param {UpdateLeadRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLead(id: string, body?: UpdateLeadRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneLeadResponse200> {
            const localVarFetchArgs = LeadsApiFetchParamCreator(configuration).updateLead(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeadsApi - factory interface
 * @export
 */
export const LeadsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here's the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values tutorial</a>.
         * @summary Add a lead
         * @param {AddLeadRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLead(body?: AddLeadRequest, options?: any) {
            return LeadsApiFp(configuration).addLead(body, options)(fetch, basePath);
        },
        /**
         * Deletes a specific lead.
         * @summary Delete a lead
         * @param {string} id The ID of the lead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLead(id: string, options?: any) {
            return LeadsApiFp(configuration).deleteLead(id, options)(fetch, basePath);
        },
        /**
         * Returns details of a specific lead. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals.
         * @summary Get one lead
         * @param {string} id The ID of the lead
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLead(id: string, options?: any) {
            return LeadsApiFp(configuration).getLead(id, options)(fetch, basePath);
        },
        /**
         * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. 
         * @summary Get all leads
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
         * @param {number} [start] For pagination, the position that represents the first result for the page
         * @param {string} [archived_status] Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
         * @param {number} [owner_id] If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
         * @param {number} [person_id] If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
         * @param {number} [organization_id] If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeads(limit?: number, start?: number, archived_status?: string, owner_id?: number, person_id?: number, organization_id?: number, filter_id?: number, sort?: string, options?: any) {
            return LeadsApiFp(configuration).getLeads(limit, start, archived_status, owner_id, person_id, organization_id, filter_id, sort, options)(fetch, basePath);
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLeads(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any) {
            return LeadsApiFp(configuration).searchLeads(term, fields, exact_match, person_id, organization_id, include_fields, start, limit, options)(fetch, basePath);
        },
        /**
         * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields values tutorial</a>.
         * @summary Update a lead
         * @param {string} id The ID of the lead
         * @param {UpdateLeadRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLead(id: string, body?: UpdateLeadRequest, options?: any) {
            return LeadsApiFp(configuration).updateLead(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * LeadsApi - interface
 * @export
 * @interface LeadsApi
 */
export interface LeadsApiInterface {
    /**
     * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here's the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values tutorial</a>.
     * @summary Add a lead
     * @param {AddLeadRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApiInterface
     */
    addLead(body?: AddLeadRequest, options?: any): Promise<OneLeadResponse200>;

    /**
     * Deletes a specific lead.
     * @summary Delete a lead
     * @param {string} id The ID of the lead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApiInterface
     */
    deleteLead(id: string, options?: any): Promise<LeadIdResponse200>;

    /**
     * Returns details of a specific lead. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals.
     * @summary Get one lead
     * @param {string} id The ID of the lead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApiInterface
     */
    getLead(id: string, options?: any): Promise<OneLeadResponse200>;

    /**
     * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. 
     * @summary Get all leads
     * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
     * @param {number} [start] For pagination, the position that represents the first result for the page
     * @param {string} [archived_status] Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
     * @param {number} [owner_id] If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
     * @param {number} [person_id] If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
     * @param {number} [organization_id] If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApiInterface
     */
    getLeads(limit?: number, start?: number, archived_status?: string, owner_id?: number, person_id?: number, organization_id?: number, filter_id?: number, sort?: string, options?: any): Promise<GetLeadsResponse200>;

    /**
     * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
     * @summary Search leads
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
     * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApiInterface
     */
    searchLeads(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any): Promise<SearchLeadsResponse200>;

    /**
     * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields values tutorial</a>.
     * @summary Update a lead
     * @param {string} id The ID of the lead
     * @param {UpdateLeadRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApiInterface
     */
    updateLead(id: string, body?: UpdateLeadRequest, options?: any): Promise<OneLeadResponse200>;

}

/**
 * LeadsApi - object-oriented interface
 * @export
 * @class LeadsApi
 * @extends {BaseAPI}
 */
export class LeadsApi extends BaseAPI implements LeadsApiInterface {
    /**
     * Creates a lead. A lead always has to be linked to a person or an organization or both. All leads created through the Pipedrive API will have a lead source `API` assigned. Here's the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-lead\" target=\"_blank\" rel=\"noopener noreferrer\">adding a lead</a>. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values tutorial</a>.
     * @summary Add a lead
     * @param {AddLeadRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public addLead(body?: AddLeadRequest, options?: any) {
        return LeadsApiFp(this.configuration).addLead(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a specific lead.
     * @summary Delete a lead
     * @param {string} id The ID of the lead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public deleteLead(id: string, options?: any) {
        return LeadsApiFp(this.configuration).deleteLead(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of a specific lead. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals.
     * @summary Get one lead
     * @param {string} id The ID of the lead
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public getLead(id: string, options?: any) {
        return LeadsApiFp(this.configuration).getLead(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns multiple leads. Leads are sorted by the time they were created, from oldest to newest. Pagination can be controlled using `limit` and `start` query parameters. If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields' structure from deals. 
     * @summary Get all leads
     * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned.
     * @param {number} [start] For pagination, the position that represents the first result for the page
     * @param {string} [archived_status] Filtering based on the archived status of a lead. If not provided, &#x60;All&#x60; is used.
     * @param {number} [owner_id] If supplied, only leads matching the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;owner_id&#x60; when supplied.
     * @param {number} [person_id] If supplied, only leads matching the given person will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;person_id&#x60; when supplied.
     * @param {number} [organization_id] If supplied, only leads matching the given organization will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;organization_id&#x60; when supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public getLeads(limit?: number, start?: number, archived_status?: string, owner_id?: number, person_id?: number, organization_id?: number, filter_id?: number, sort?: string, options?: any) {
        return LeadsApiFp(this.configuration).getLeads(limit, start, archived_status, owner_id, person_id, organization_id, filter_id, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
     * @summary Search leads
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
     * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public searchLeads(term: string, fields?: string, exact_match?: boolean, person_id?: number, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any) {
        return LeadsApiFp(this.configuration).searchLeads(term, fields, exact_match, person_id, organization_id, include_fields, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates one or more properties of a lead. Only properties included in the request will be updated. Send `null` to unset a property (applicable for example for `value`, `person_id` or `organization_id`). If a lead contains custom fields, the fields' values will be included in the response in the same format as with the `Deals` endpoints. If a custom field's value hasn't been set for the lead, it won't appear in the response. Please note that leads do not have a separate set of custom fields, instead they inherit the custom fields structure from deals. See an example given in the <a href=\"https://pipedrive.readme.io/docs/updating-custom-field-value\" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields values tutorial</a>.
     * @summary Update a lead
     * @param {string} id The ID of the lead
     * @param {UpdateLeadRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsApi
     */
    public updateLead(id: string, body?: UpdateLeadRequest, options?: any) {
        return LeadsApiFp(this.configuration).updateLead(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * LegacyTeamsApi - fetch parameter creator
 * @export
 */
export const LegacyTeamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new team to the company and returns the created object.
         * @summary Add a new team
         * @param {AddTeamRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeam(body?: AddTeamRequest, options: any = {}): FetchArgs {
            const localVarPath = `/legacyTeams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddTeamRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds users to an existing team.
         * @summary Add users to a team
         * @param {number} id The ID of the team
         * @param {AddTeamUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamUser(id: number, body?: AddTeamUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addTeamUser.');
            }
            const localVarPath = `/legacyTeams/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddTeamUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes users from an existing team.
         * @summary Delete users from a team
         * @param {number} id The ID of the team
         * @param {DeleteTeamUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamUser(id: number, body?: DeleteTeamUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTeamUser.');
            }
            const localVarPath = `/legacyTeams/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteTeamUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific team.
         * @summary Get a single team
         * @param {number} id The ID of the team
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(id: number, skip_users?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeam.');
            }
            const localVarPath = `/legacyTeams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (skip_users !== undefined) {
                localVarQueryParameter['skip_users'] = skip_users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all user IDs within a team.
         * @summary Get all users in a team
         * @param {number} id The ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamUsers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTeamUsers.');
            }
            const localVarPath = `/legacyTeams/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about teams within the company.
         * @summary Get all teams
         * @param {string} [order_by] The field name to sort returned teams by
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(order_by?: string, skip_users?: number, options: any = {}): FetchArgs {
            const localVarPath = `/legacyTeams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (order_by !== undefined) {
                localVarQueryParameter['order_by'] = order_by;
            }

            if (skip_users !== undefined) {
                localVarQueryParameter['skip_users'] = skip_users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all teams which have the specified user as a member.
         * @summary Get all teams of a user
         * @param {number} id The ID of the user
         * @param {string} [order_by] The field name to sort returned teams by
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTeams(id: number, order_by?: string, skip_users?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserTeams.');
            }
            const localVarPath = `/legacyTeams/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (order_by !== undefined) {
                localVarQueryParameter['order_by'] = order_by;
            }

            if (skip_users !== undefined) {
                localVarQueryParameter['skip_users'] = skip_users;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing team and returns the updated object.
         * @summary Update a team
         * @param {number} id The ID of the team
         * @param {UpdateTeamRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(id: number, body?: UpdateTeamRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTeam.');
            }
            const localVarPath = `/legacyTeams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateTeamRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LegacyTeamsApi - functional programming interface
 * @export
 */
export const LegacyTeamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new team to the company and returns the created object.
         * @summary Add a new team
         * @param {AddTeamRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeam(body?: AddTeamRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamResponse200> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).addTeam(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds users to an existing team.
         * @summary Add users to a team
         * @param {number} id The ID of the team
         * @param {AddTeamUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamUser(id: number, body?: AddTeamUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserIds> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).addTeamUser(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes users from an existing team.
         * @summary Delete users from a team
         * @param {number} id The ID of the team
         * @param {DeleteTeamUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamUser(id: number, body?: DeleteTeamUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserIds> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).deleteTeamUser(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific team.
         * @summary Get a single team
         * @param {number} id The ID of the team
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(id: number, skip_users?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamResponse200> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).getTeam(id, skip_users, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of all user IDs within a team.
         * @summary Get all users in a team
         * @param {number} id The ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamUsers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserIds> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).getTeamUsers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about teams within the company.
         * @summary Get all teams
         * @param {string} [order_by] The field name to sort returned teams by
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(order_by?: string, skip_users?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamsResponse200> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).getTeams(order_by, skip_users, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all teams which have the specified user as a member.
         * @summary Get all teams of a user
         * @param {number} id The ID of the user
         * @param {string} [order_by] The field name to sort returned teams by
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTeams(id: number, order_by?: string, skip_users?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamsResponse200> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).getUserTeams(id, order_by, skip_users, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an existing team and returns the updated object.
         * @summary Update a team
         * @param {number} id The ID of the team
         * @param {UpdateTeamRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(id: number, body?: UpdateTeamRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamResponse200> {
            const localVarFetchArgs = LegacyTeamsApiFetchParamCreator(configuration).updateTeam(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LegacyTeamsApi - factory interface
 * @export
 */
export const LegacyTeamsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new team to the company and returns the created object.
         * @summary Add a new team
         * @param {AddTeamRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeam(body?: AddTeamRequest, options?: any) {
            return LegacyTeamsApiFp(configuration).addTeam(body, options)(fetch, basePath);
        },
        /**
         * Adds users to an existing team.
         * @summary Add users to a team
         * @param {number} id The ID of the team
         * @param {AddTeamUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamUser(id: number, body?: AddTeamUserRequest, options?: any) {
            return LegacyTeamsApiFp(configuration).addTeamUser(id, body, options)(fetch, basePath);
        },
        /**
         * Deletes users from an existing team.
         * @summary Delete users from a team
         * @param {number} id The ID of the team
         * @param {DeleteTeamUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamUser(id: number, body?: DeleteTeamUserRequest, options?: any) {
            return LegacyTeamsApiFp(configuration).deleteTeamUser(id, body, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific team.
         * @summary Get a single team
         * @param {number} id The ID of the team
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(id: number, skip_users?: number, options?: any) {
            return LegacyTeamsApiFp(configuration).getTeam(id, skip_users, options)(fetch, basePath);
        },
        /**
         * Returns a list of all user IDs within a team.
         * @summary Get all users in a team
         * @param {number} id The ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamUsers(id: number, options?: any) {
            return LegacyTeamsApiFp(configuration).getTeamUsers(id, options)(fetch, basePath);
        },
        /**
         * Returns data about teams within the company.
         * @summary Get all teams
         * @param {string} [order_by] The field name to sort returned teams by
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(order_by?: string, skip_users?: number, options?: any) {
            return LegacyTeamsApiFp(configuration).getTeams(order_by, skip_users, options)(fetch, basePath);
        },
        /**
         * Returns data about all teams which have the specified user as a member.
         * @summary Get all teams of a user
         * @param {number} id The ID of the user
         * @param {string} [order_by] The field name to sort returned teams by
         * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTeams(id: number, order_by?: string, skip_users?: number, options?: any) {
            return LegacyTeamsApiFp(configuration).getUserTeams(id, order_by, skip_users, options)(fetch, basePath);
        },
        /**
         * Updates an existing team and returns the updated object.
         * @summary Update a team
         * @param {number} id The ID of the team
         * @param {UpdateTeamRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(id: number, body?: UpdateTeamRequest, options?: any) {
            return LegacyTeamsApiFp(configuration).updateTeam(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * LegacyTeamsApi - interface
 * @export
 * @interface LegacyTeamsApi
 */
export interface LegacyTeamsApiInterface {
    /**
     * Adds a new team to the company and returns the created object.
     * @summary Add a new team
     * @param {AddTeamRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    addTeam(body?: AddTeamRequest, options?: any): Promise<TeamResponse200>;

    /**
     * Adds users to an existing team.
     * @summary Add users to a team
     * @param {number} id The ID of the team
     * @param {AddTeamUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    addTeamUser(id: number, body?: AddTeamUserRequest, options?: any): Promise<UserIds>;

    /**
     * Deletes users from an existing team.
     * @summary Delete users from a team
     * @param {number} id The ID of the team
     * @param {DeleteTeamUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    deleteTeamUser(id: number, body?: DeleteTeamUserRequest, options?: any): Promise<UserIds>;

    /**
     * Returns data about a specific team.
     * @summary Get a single team
     * @param {number} id The ID of the team
     * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    getTeam(id: number, skip_users?: number, options?: any): Promise<TeamResponse200>;

    /**
     * Returns a list of all user IDs within a team.
     * @summary Get all users in a team
     * @param {number} id The ID of the team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    getTeamUsers(id: number, options?: any): Promise<UserIds>;

    /**
     * Returns data about teams within the company.
     * @summary Get all teams
     * @param {string} [order_by] The field name to sort returned teams by
     * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    getTeams(order_by?: string, skip_users?: number, options?: any): Promise<TeamsResponse200>;

    /**
     * Returns data about all teams which have the specified user as a member.
     * @summary Get all teams of a user
     * @param {number} id The ID of the user
     * @param {string} [order_by] The field name to sort returned teams by
     * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    getUserTeams(id: number, order_by?: string, skip_users?: number, options?: any): Promise<TeamsResponse200>;

    /**
     * Updates an existing team and returns the updated object.
     * @summary Update a team
     * @param {number} id The ID of the team
     * @param {UpdateTeamRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApiInterface
     */
    updateTeam(id: number, body?: UpdateTeamRequest, options?: any): Promise<TeamResponse200>;

}

/**
 * LegacyTeamsApi - object-oriented interface
 * @export
 * @class LegacyTeamsApi
 * @extends {BaseAPI}
 */
export class LegacyTeamsApi extends BaseAPI implements LegacyTeamsApiInterface {
    /**
     * Adds a new team to the company and returns the created object.
     * @summary Add a new team
     * @param {AddTeamRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public addTeam(body?: AddTeamRequest, options?: any) {
        return LegacyTeamsApiFp(this.configuration).addTeam(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds users to an existing team.
     * @summary Add users to a team
     * @param {number} id The ID of the team
     * @param {AddTeamUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public addTeamUser(id: number, body?: AddTeamUserRequest, options?: any) {
        return LegacyTeamsApiFp(this.configuration).addTeamUser(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes users from an existing team.
     * @summary Delete users from a team
     * @param {number} id The ID of the team
     * @param {DeleteTeamUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public deleteTeamUser(id: number, body?: DeleteTeamUserRequest, options?: any) {
        return LegacyTeamsApiFp(this.configuration).deleteTeamUser(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific team.
     * @summary Get a single team
     * @param {number} id The ID of the team
     * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getTeam(id: number, skip_users?: number, options?: any) {
        return LegacyTeamsApiFp(this.configuration).getTeam(id, skip_users, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of all user IDs within a team.
     * @summary Get all users in a team
     * @param {number} id The ID of the team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getTeamUsers(id: number, options?: any) {
        return LegacyTeamsApiFp(this.configuration).getTeamUsers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about teams within the company.
     * @summary Get all teams
     * @param {string} [order_by] The field name to sort returned teams by
     * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getTeams(order_by?: string, skip_users?: number, options?: any) {
        return LegacyTeamsApiFp(this.configuration).getTeams(order_by, skip_users, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all teams which have the specified user as a member.
     * @summary Get all teams of a user
     * @param {number} id The ID of the user
     * @param {string} [order_by] The field name to sort returned teams by
     * @param {number} [skip_users] When enabled, the teams will not include IDs of member users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public getUserTeams(id: number, order_by?: string, skip_users?: number, options?: any) {
        return LegacyTeamsApiFp(this.configuration).getUserTeams(id, order_by, skip_users, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an existing team and returns the updated object.
     * @summary Update a team
     * @param {number} id The ID of the team
     * @param {UpdateTeamRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LegacyTeamsApi
     */
    public updateTeam(id: number, body?: UpdateTeamRequest, options?: any) {
        return LegacyTeamsApiFp(this.configuration).updateTeam(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * MailboxApi - fetch parameter creator
 * @export
 */
export const MailboxApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Marks a mail thread as deleted.
         * @summary Delete mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMailThread(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteMailThread.');
            }
            const localVarPath = `/mailbox/mailThreads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific mail message.
         * @summary Get one mail message
         * @param {number} id The ID of the mail message to fetch
         * @param {number} [include_body] Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don&#x27;t include, &#x60;1&#x60; &#x3D; Include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailMessage(id: number, include_body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMailMessage.');
            }
            const localVarPath = `/mailbox/mailMessages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (include_body !== undefined) {
                localVarQueryParameter['include_body'] = include_body;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific mail thread.
         * @summary Get one mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThread(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMailThread.');
            }
            const localVarPath = `/mailbox/mailThreads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the mail messages inside a specified mail thread.
         * @summary Get all mail messages of mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThreadMessages(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMailThreadMessages.');
            }
            const localVarPath = `/mailbox/mailThreads/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns mail threads in a specified folder ordered by the most recent message within.
         * @summary Get mail threads
         * @param {string} folder The type of folder to fetch
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThreads(folder: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'folder' is not null or undefined
            if (folder === null || folder === undefined) {
                throw new RequiredError('folder','Required parameter folder was null or undefined when calling getMailThreads.');
            }
            const localVarPath = `/mailbox/mailThreads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (folder !== undefined) {
                localVarQueryParameter['folder'] = folder;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a mail thread.
         * @summary Update mail thread details
         * @param {number} id The ID of the mail thread
         * @param {number} [deal_id] 
         * @param {string} [lead_id] 
         * @param {number} [shared_flag] 
         * @param {number} [read_flag] 
         * @param {number} [archived_flag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMailThreadDetails(id: number, deal_id?: number, lead_id?: string, shared_flag?: number, read_flag?: number, archived_flag?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateMailThreadDetails.');
            }
            const localVarPath = `/mailbox/mailThreads/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (deal_id !== undefined) {
                localVarFormParams.set('deal_id', deal_id as any);
            }

            if (lead_id !== undefined) {
                localVarFormParams.set('lead_id', lead_id as any);
            }

            if (shared_flag !== undefined) {
                localVarFormParams.set('shared_flag', shared_flag as any);
            }

            if (read_flag !== undefined) {
                localVarFormParams.set('read_flag', read_flag as any);
            }

            if (archived_flag !== undefined) {
                localVarFormParams.set('archived_flag', archived_flag as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailboxApi - functional programming interface
 * @export
 */
export const MailboxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Marks a mail thread as deleted.
         * @summary Delete mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMailThread(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteMailThreadResponse200> {
            const localVarFetchArgs = MailboxApiFetchParamCreator(configuration).deleteMailThread(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific mail message.
         * @summary Get one mail message
         * @param {number} id The ID of the mail message to fetch
         * @param {number} [include_body] Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don&#x27;t include, &#x60;1&#x60; &#x3D; Include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailMessage(id: number, include_body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MailMessageResponse200> {
            const localVarFetchArgs = MailboxApiFetchParamCreator(configuration).getMailMessage(id, include_body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a specific mail thread.
         * @summary Get one mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThread(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOneMailThreadResponse200> {
            const localVarFetchArgs = MailboxApiFetchParamCreator(configuration).getMailThread(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all the mail messages inside a specified mail thread.
         * @summary Get all mail messages of mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThreadMessages(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllMailMessagesOfMailThreadResponse200> {
            const localVarFetchArgs = MailboxApiFetchParamCreator(configuration).getMailThreadMessages(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns mail threads in a specified folder ordered by the most recent message within.
         * @summary Get mail threads
         * @param {string} folder The type of folder to fetch
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThreads(folder: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetMailThreadsResponse200> {
            const localVarFetchArgs = MailboxApiFetchParamCreator(configuration).getMailThreads(folder, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of a mail thread.
         * @summary Update mail thread details
         * @param {number} id The ID of the mail thread
         * @param {number} [deal_id] 
         * @param {string} [lead_id] 
         * @param {number} [shared_flag] 
         * @param {number} [read_flag] 
         * @param {number} [archived_flag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMailThreadDetails(id: number, deal_id?: number, lead_id?: string, shared_flag?: number, read_flag?: number, archived_flag?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateMailThreadDetailsResponse200> {
            const localVarFetchArgs = MailboxApiFetchParamCreator(configuration).updateMailThreadDetails(id, deal_id, lead_id, shared_flag, read_flag, archived_flag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MailboxApi - factory interface
 * @export
 */
export const MailboxApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Marks a mail thread as deleted.
         * @summary Delete mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMailThread(id: number, options?: any) {
            return MailboxApiFp(configuration).deleteMailThread(id, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific mail message.
         * @summary Get one mail message
         * @param {number} id The ID of the mail message to fetch
         * @param {number} [include_body] Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don&#x27;t include, &#x60;1&#x60; &#x3D; Include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailMessage(id: number, include_body?: number, options?: any) {
            return MailboxApiFp(configuration).getMailMessage(id, include_body, options)(fetch, basePath);
        },
        /**
         * Returns a specific mail thread.
         * @summary Get one mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThread(id: number, options?: any) {
            return MailboxApiFp(configuration).getMailThread(id, options)(fetch, basePath);
        },
        /**
         * Returns all the mail messages inside a specified mail thread.
         * @summary Get all mail messages of mail thread
         * @param {number} id The ID of the mail thread
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThreadMessages(id: number, options?: any) {
            return MailboxApiFp(configuration).getMailThreadMessages(id, options)(fetch, basePath);
        },
        /**
         * Returns mail threads in a specified folder ordered by the most recent message within.
         * @summary Get mail threads
         * @param {string} folder The type of folder to fetch
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailThreads(folder: string, start?: number, limit?: number, options?: any) {
            return MailboxApiFp(configuration).getMailThreads(folder, start, limit, options)(fetch, basePath);
        },
        /**
         * Updates the properties of a mail thread.
         * @summary Update mail thread details
         * @param {number} id The ID of the mail thread
         * @param {number} [deal_id] 
         * @param {string} [lead_id] 
         * @param {number} [shared_flag] 
         * @param {number} [read_flag] 
         * @param {number} [archived_flag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMailThreadDetails(id: number, deal_id?: number, lead_id?: string, shared_flag?: number, read_flag?: number, archived_flag?: number, options?: any) {
            return MailboxApiFp(configuration).updateMailThreadDetails(id, deal_id, lead_id, shared_flag, read_flag, archived_flag, options)(fetch, basePath);
        },
    };
};

/**
 * MailboxApi - interface
 * @export
 * @interface MailboxApi
 */
export interface MailboxApiInterface {
    /**
     * Marks a mail thread as deleted.
     * @summary Delete mail thread
     * @param {number} id The ID of the mail thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApiInterface
     */
    deleteMailThread(id: number, options?: any): Promise<DeleteMailThreadResponse200>;

    /**
     * Returns data about a specific mail message.
     * @summary Get one mail message
     * @param {number} id The ID of the mail message to fetch
     * @param {number} [include_body] Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don&#x27;t include, &#x60;1&#x60; &#x3D; Include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApiInterface
     */
    getMailMessage(id: number, include_body?: number, options?: any): Promise<MailMessageResponse200>;

    /**
     * Returns a specific mail thread.
     * @summary Get one mail thread
     * @param {number} id The ID of the mail thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApiInterface
     */
    getMailThread(id: number, options?: any): Promise<GetOneMailThreadResponse200>;

    /**
     * Returns all the mail messages inside a specified mail thread.
     * @summary Get all mail messages of mail thread
     * @param {number} id The ID of the mail thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApiInterface
     */
    getMailThreadMessages(id: number, options?: any): Promise<GetAllMailMessagesOfMailThreadResponse200>;

    /**
     * Returns mail threads in a specified folder ordered by the most recent message within.
     * @summary Get mail threads
     * @param {string} folder The type of folder to fetch
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApiInterface
     */
    getMailThreads(folder: string, start?: number, limit?: number, options?: any): Promise<GetMailThreadsResponse200>;

    /**
     * Updates the properties of a mail thread.
     * @summary Update mail thread details
     * @param {number} id The ID of the mail thread
     * @param {number} [deal_id] 
     * @param {string} [lead_id] 
     * @param {number} [shared_flag] 
     * @param {number} [read_flag] 
     * @param {number} [archived_flag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApiInterface
     */
    updateMailThreadDetails(id: number, deal_id?: number, lead_id?: string, shared_flag?: number, read_flag?: number, archived_flag?: number, options?: any): Promise<UpdateMailThreadDetailsResponse200>;

}

/**
 * MailboxApi - object-oriented interface
 * @export
 * @class MailboxApi
 * @extends {BaseAPI}
 */
export class MailboxApi extends BaseAPI implements MailboxApiInterface {
    /**
     * Marks a mail thread as deleted.
     * @summary Delete mail thread
     * @param {number} id The ID of the mail thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public deleteMailThread(id: number, options?: any) {
        return MailboxApiFp(this.configuration).deleteMailThread(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific mail message.
     * @summary Get one mail message
     * @param {number} id The ID of the mail message to fetch
     * @param {number} [include_body] Whether to include the full message body or not. &#x60;0&#x60; &#x3D; Don&#x27;t include, &#x60;1&#x60; &#x3D; Include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailMessage(id: number, include_body?: number, options?: any) {
        return MailboxApiFp(this.configuration).getMailMessage(id, include_body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a specific mail thread.
     * @summary Get one mail thread
     * @param {number} id The ID of the mail thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailThread(id: number, options?: any) {
        return MailboxApiFp(this.configuration).getMailThread(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all the mail messages inside a specified mail thread.
     * @summary Get all mail messages of mail thread
     * @param {number} id The ID of the mail thread
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailThreadMessages(id: number, options?: any) {
        return MailboxApiFp(this.configuration).getMailThreadMessages(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns mail threads in a specified folder ordered by the most recent message within.
     * @summary Get mail threads
     * @param {string} folder The type of folder to fetch
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public getMailThreads(folder: string, start?: number, limit?: number, options?: any) {
        return MailboxApiFp(this.configuration).getMailThreads(folder, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of a mail thread.
     * @summary Update mail thread details
     * @param {number} id The ID of the mail thread
     * @param {number} [deal_id] 
     * @param {string} [lead_id] 
     * @param {number} [shared_flag] 
     * @param {number} [read_flag] 
     * @param {number} [archived_flag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailboxApi
     */
    public updateMailThreadDetails(id: number, deal_id?: number, lead_id?: string, shared_flag?: number, read_flag?: number, archived_flag?: number, options?: any) {
        return MailboxApiFp(this.configuration).updateMailThreadDetails(id, deal_id, lead_id, shared_flag, read_flag, archived_flag, options)(this.fetch, this.basePath);
    }

}
/**
 * NoteFieldsApi - fetch parameter creator
 * @export
 */
export const NoteFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about all note fields.
         * @summary Get all note fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoteFields(options: any = {}): FetchArgs {
            const localVarPath = `/noteFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoteFieldsApi - functional programming interface
 * @export
 */
export const NoteFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns data about all note fields.
         * @summary Get all note fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoteFields(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetNoteFieldsResponse200> {
            const localVarFetchArgs = NoteFieldsApiFetchParamCreator(configuration).getNoteFields(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NoteFieldsApi - factory interface
 * @export
 */
export const NoteFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns data about all note fields.
         * @summary Get all note fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoteFields(options?: any) {
            return NoteFieldsApiFp(configuration).getNoteFields(options)(fetch, basePath);
        },
    };
};

/**
 * NoteFieldsApi - interface
 * @export
 * @interface NoteFieldsApi
 */
export interface NoteFieldsApiInterface {
    /**
     * Returns data about all note fields.
     * @summary Get all note fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteFieldsApiInterface
     */
    getNoteFields(options?: any): Promise<GetNoteFieldsResponse200>;

}

/**
 * NoteFieldsApi - object-oriented interface
 * @export
 * @class NoteFieldsApi
 * @extends {BaseAPI}
 */
export class NoteFieldsApi extends BaseAPI implements NoteFieldsApiInterface {
    /**
     * Returns data about all note fields.
     * @summary Get all note fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoteFieldsApi
     */
    public getNoteFields(options?: any) {
        return NoteFieldsApiFp(this.configuration).getNoteFields(options)(this.fetch, this.basePath);
    }

}
/**
 * NotesApi - fetch parameter creator
 * @export
 */
export const NotesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new note.
         * @summary Add a note
         * @param {NotesBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNote(body?: NotesBody, options: any = {}): FetchArgs {
            const localVarPath = `/notes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NotesBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new comment to a note.
         * @summary Add a comment to a note
         * @param {number} id The ID of the note
         * @param {CommentPostPutObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoteComment(id: number, body?: CommentPostPutObject, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addNoteComment.');
            }
            const localVarPath = `/notes/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommentPostPutObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a comment.
         * @summary Delete a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(id: number, commentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteComment.');
            }
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling deleteComment.');
            }
            const localVarPath = `/notes/{id}/comments/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific note.
         * @summary Delete a note
         * @param {number} id The ID of the note
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteNote.');
            }
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a comment.
         * @summary Get one comment
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id: number, commentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getComment.');
            }
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling getComment.');
            }
            const localVarPath = `/notes/{id}/comments/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details about a specific note.
         * @summary Get one note
         * @param {number} id The ID of the note
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNote(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNote.');
            }
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all comments associated with a note.
         * @summary Get all comments for a note
         * @param {number} id The ID of the note
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoteComments(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getNoteComments.');
            }
            const localVarPath = `/notes/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all notes.
         * @summary Get all notes
         * @param {number} [user_id] The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
         * @param {string} [lead_id] The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
         * @param {number} [deal_id] The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
         * @param {number} [person_id] The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
         * @param {number} [org_id] The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {string} [start_date] The date in format of YYYY-MM-DD from which notes to fetch
         * @param {string} [end_date] The date in format of YYYY-MM-DD until which notes to fetch to
         * @param {number} [pinned_to_lead_flag] If set, the results are filtered by note to lead pinning state
         * @param {number} [pinned_to_deal_flag] If set, the results are filtered by note to deal pinning state
         * @param {number} [pinned_to_organization_flag] If set, the results are filtered by note to organization pinning state
         * @param {number} [pinned_to_person_flag] If set, the results are filtered by note to person pinning state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotes(user_id?: number, lead_id?: string, deal_id?: number, person_id?: number, org_id?: number, start?: number, limit?: number, sort?: string, start_date?: string, end_date?: string, pinned_to_lead_flag?: number, pinned_to_deal_flag?: number, pinned_to_organization_flag?: number, pinned_to_person_flag?: number, options: any = {}): FetchArgs {
            const localVarPath = `/notes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (lead_id !== undefined) {
                localVarQueryParameter['lead_id'] = lead_id;
            }

            if (deal_id !== undefined) {
                localVarQueryParameter['deal_id'] = deal_id;
            }

            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any).toISOString();
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any).toISOString();
            }

            if (pinned_to_lead_flag !== undefined) {
                localVarQueryParameter['pinned_to_lead_flag'] = pinned_to_lead_flag;
            }

            if (pinned_to_deal_flag !== undefined) {
                localVarQueryParameter['pinned_to_deal_flag'] = pinned_to_deal_flag;
            }

            if (pinned_to_organization_flag !== undefined) {
                localVarQueryParameter['pinned_to_organization_flag'] = pinned_to_organization_flag;
            }

            if (pinned_to_person_flag !== undefined) {
                localVarQueryParameter['pinned_to_person_flag'] = pinned_to_person_flag;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a comment related to a note.
         * @summary Update a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {CommentPostPutObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommentForNote(id: number, commentId: string, body?: CommentPostPutObject1, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCommentForNote.');
            }
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling updateCommentForNote.');
            }
            const localVarPath = `/notes/{id}/comments/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommentPostPutObject1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a note.
         * @summary Update a note
         * @param {number} id The ID of the note
         * @param {NoteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNote(id: number, body?: NoteRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateNote.');
            }
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NoteRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotesApi - functional programming interface
 * @export
 */
export const NotesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new note.
         * @summary Add a note
         * @param {NotesBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNote(body?: NotesBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneNoteResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).addNote(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new comment to a note.
         * @summary Add a comment to a note
         * @param {number} id The ID of the note
         * @param {CommentPostPutObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoteComment(id: number, body?: CommentPostPutObject, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneCommentResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).addNoteComment(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a comment.
         * @summary Delete a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(id: number, commentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCommentResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).deleteComment(id, commentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a specific note.
         * @summary Delete a note
         * @param {number} id The ID of the note
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteNoteResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).deleteNote(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the details of a comment.
         * @summary Get one comment
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id: number, commentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneCommentResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).getComment(id, commentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details about a specific note.
         * @summary Get one note
         * @param {number} id The ID of the note
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNote(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneNoteResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).getNote(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all comments associated with a note.
         * @summary Get all comments for a note
         * @param {number} id The ID of the note
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoteComments(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCommentsResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).getNoteComments(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all notes.
         * @summary Get all notes
         * @param {number} [user_id] The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
         * @param {string} [lead_id] The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
         * @param {number} [deal_id] The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
         * @param {number} [person_id] The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
         * @param {number} [org_id] The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {string} [start_date] The date in format of YYYY-MM-DD from which notes to fetch
         * @param {string} [end_date] The date in format of YYYY-MM-DD until which notes to fetch to
         * @param {number} [pinned_to_lead_flag] If set, the results are filtered by note to lead pinning state
         * @param {number} [pinned_to_deal_flag] If set, the results are filtered by note to deal pinning state
         * @param {number} [pinned_to_organization_flag] If set, the results are filtered by note to organization pinning state
         * @param {number} [pinned_to_person_flag] If set, the results are filtered by note to person pinning state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotes(user_id?: number, lead_id?: string, deal_id?: number, person_id?: number, org_id?: number, start?: number, limit?: number, sort?: string, start_date?: string, end_date?: string, pinned_to_lead_flag?: number, pinned_to_deal_flag?: number, pinned_to_organization_flag?: number, pinned_to_person_flag?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetNotesResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).getNotes(user_id, lead_id, deal_id, person_id, org_id, start, limit, sort, start_date, end_date, pinned_to_lead_flag, pinned_to_deal_flag, pinned_to_organization_flag, pinned_to_person_flag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a comment related to a note.
         * @summary Update a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {CommentPostPutObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommentForNote(id: number, commentId: string, body?: CommentPostPutObject1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneCommentResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).updateCommentForNote(id, commentId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a note.
         * @summary Update a note
         * @param {number} id The ID of the note
         * @param {NoteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNote(id: number, body?: NoteRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OneNoteResponse200> {
            const localVarFetchArgs = NotesApiFetchParamCreator(configuration).updateNote(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotesApi - factory interface
 * @export
 */
export const NotesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new note.
         * @summary Add a note
         * @param {NotesBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNote(body?: NotesBody, options?: any) {
            return NotesApiFp(configuration).addNote(body, options)(fetch, basePath);
        },
        /**
         * Adds a new comment to a note.
         * @summary Add a comment to a note
         * @param {number} id The ID of the note
         * @param {CommentPostPutObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoteComment(id: number, body?: CommentPostPutObject, options?: any) {
            return NotesApiFp(configuration).addNoteComment(id, body, options)(fetch, basePath);
        },
        /**
         * Deletes a comment.
         * @summary Delete a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(id: number, commentId: string, options?: any) {
            return NotesApiFp(configuration).deleteComment(id, commentId, options)(fetch, basePath);
        },
        /**
         * Deletes a specific note.
         * @summary Delete a note
         * @param {number} id The ID of the note
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(id: number, options?: any) {
            return NotesApiFp(configuration).deleteNote(id, options)(fetch, basePath);
        },
        /**
         * Returns the details of a comment.
         * @summary Get one comment
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id: number, commentId: string, options?: any) {
            return NotesApiFp(configuration).getComment(id, commentId, options)(fetch, basePath);
        },
        /**
         * Returns details about a specific note.
         * @summary Get one note
         * @param {number} id The ID of the note
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNote(id: number, options?: any) {
            return NotesApiFp(configuration).getNote(id, options)(fetch, basePath);
        },
        /**
         * Returns all comments associated with a note.
         * @summary Get all comments for a note
         * @param {number} id The ID of the note
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoteComments(id: number, start?: number, limit?: number, options?: any) {
            return NotesApiFp(configuration).getNoteComments(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Returns all notes.
         * @summary Get all notes
         * @param {number} [user_id] The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
         * @param {string} [lead_id] The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
         * @param {number} [deal_id] The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
         * @param {number} [person_id] The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
         * @param {number} [org_id] The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {string} [start_date] The date in format of YYYY-MM-DD from which notes to fetch
         * @param {string} [end_date] The date in format of YYYY-MM-DD until which notes to fetch to
         * @param {number} [pinned_to_lead_flag] If set, the results are filtered by note to lead pinning state
         * @param {number} [pinned_to_deal_flag] If set, the results are filtered by note to deal pinning state
         * @param {number} [pinned_to_organization_flag] If set, the results are filtered by note to organization pinning state
         * @param {number} [pinned_to_person_flag] If set, the results are filtered by note to person pinning state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotes(user_id?: number, lead_id?: string, deal_id?: number, person_id?: number, org_id?: number, start?: number, limit?: number, sort?: string, start_date?: string, end_date?: string, pinned_to_lead_flag?: number, pinned_to_deal_flag?: number, pinned_to_organization_flag?: number, pinned_to_person_flag?: number, options?: any) {
            return NotesApiFp(configuration).getNotes(user_id, lead_id, deal_id, person_id, org_id, start, limit, sort, start_date, end_date, pinned_to_lead_flag, pinned_to_deal_flag, pinned_to_organization_flag, pinned_to_person_flag, options)(fetch, basePath);
        },
        /**
         * Updates a comment related to a note.
         * @summary Update a comment related to a note
         * @param {number} id The ID of the note
         * @param {string} commentId The ID of the comment
         * @param {CommentPostPutObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommentForNote(id: number, commentId: string, body?: CommentPostPutObject1, options?: any) {
            return NotesApiFp(configuration).updateCommentForNote(id, commentId, body, options)(fetch, basePath);
        },
        /**
         * Updates a note.
         * @summary Update a note
         * @param {number} id The ID of the note
         * @param {NoteRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNote(id: number, body?: NoteRequest, options?: any) {
            return NotesApiFp(configuration).updateNote(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * NotesApi - interface
 * @export
 * @interface NotesApi
 */
export interface NotesApiInterface {
    /**
     * Adds a new note.
     * @summary Add a note
     * @param {NotesBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    addNote(body?: NotesBody, options?: any): Promise<OneNoteResponse200>;

    /**
     * Adds a new comment to a note.
     * @summary Add a comment to a note
     * @param {number} id The ID of the note
     * @param {CommentPostPutObject} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    addNoteComment(id: number, body?: CommentPostPutObject, options?: any): Promise<OneCommentResponse200>;

    /**
     * Deletes a comment.
     * @summary Delete a comment related to a note
     * @param {number} id The ID of the note
     * @param {string} commentId The ID of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    deleteComment(id: number, commentId: string, options?: any): Promise<DeleteCommentResponse200>;

    /**
     * Deletes a specific note.
     * @summary Delete a note
     * @param {number} id The ID of the note
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    deleteNote(id: number, options?: any): Promise<DeleteNoteResponse200>;

    /**
     * Returns the details of a comment.
     * @summary Get one comment
     * @param {number} id The ID of the note
     * @param {string} commentId The ID of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    getComment(id: number, commentId: string, options?: any): Promise<OneCommentResponse200>;

    /**
     * Returns details about a specific note.
     * @summary Get one note
     * @param {number} id The ID of the note
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    getNote(id: number, options?: any): Promise<OneNoteResponse200>;

    /**
     * Returns all comments associated with a note.
     * @summary Get all comments for a note
     * @param {number} id The ID of the note
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    getNoteComments(id: number, start?: number, limit?: number, options?: any): Promise<GetCommentsResponse200>;

    /**
     * Returns all notes.
     * @summary Get all notes
     * @param {number} [user_id] The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
     * @param {string} [lead_id] The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
     * @param {number} [deal_id] The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
     * @param {number} [person_id] The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
     * @param {number} [org_id] The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
     * @param {string} [start_date] The date in format of YYYY-MM-DD from which notes to fetch
     * @param {string} [end_date] The date in format of YYYY-MM-DD until which notes to fetch to
     * @param {number} [pinned_to_lead_flag] If set, the results are filtered by note to lead pinning state
     * @param {number} [pinned_to_deal_flag] If set, the results are filtered by note to deal pinning state
     * @param {number} [pinned_to_organization_flag] If set, the results are filtered by note to organization pinning state
     * @param {number} [pinned_to_person_flag] If set, the results are filtered by note to person pinning state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    getNotes(user_id?: number, lead_id?: string, deal_id?: number, person_id?: number, org_id?: number, start?: number, limit?: number, sort?: string, start_date?: string, end_date?: string, pinned_to_lead_flag?: number, pinned_to_deal_flag?: number, pinned_to_organization_flag?: number, pinned_to_person_flag?: number, options?: any): Promise<GetNotesResponse200>;

    /**
     * Updates a comment related to a note.
     * @summary Update a comment related to a note
     * @param {number} id The ID of the note
     * @param {string} commentId The ID of the comment
     * @param {CommentPostPutObject1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    updateCommentForNote(id: number, commentId: string, body?: CommentPostPutObject1, options?: any): Promise<OneCommentResponse200>;

    /**
     * Updates a note.
     * @summary Update a note
     * @param {number} id The ID of the note
     * @param {NoteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApiInterface
     */
    updateNote(id: number, body?: NoteRequest, options?: any): Promise<OneNoteResponse200>;

}

/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
export class NotesApi extends BaseAPI implements NotesApiInterface {
    /**
     * Adds a new note.
     * @summary Add a note
     * @param {NotesBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public addNote(body?: NotesBody, options?: any) {
        return NotesApiFp(this.configuration).addNote(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a new comment to a note.
     * @summary Add a comment to a note
     * @param {number} id The ID of the note
     * @param {CommentPostPutObject} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public addNoteComment(id: number, body?: CommentPostPutObject, options?: any) {
        return NotesApiFp(this.configuration).addNoteComment(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a comment.
     * @summary Delete a comment related to a note
     * @param {number} id The ID of the note
     * @param {string} commentId The ID of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public deleteComment(id: number, commentId: string, options?: any) {
        return NotesApiFp(this.configuration).deleteComment(id, commentId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a specific note.
     * @summary Delete a note
     * @param {number} id The ID of the note
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public deleteNote(id: number, options?: any) {
        return NotesApiFp(this.configuration).deleteNote(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the details of a comment.
     * @summary Get one comment
     * @param {number} id The ID of the note
     * @param {string} commentId The ID of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getComment(id: number, commentId: string, options?: any) {
        return NotesApiFp(this.configuration).getComment(id, commentId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details about a specific note.
     * @summary Get one note
     * @param {number} id The ID of the note
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getNote(id: number, options?: any) {
        return NotesApiFp(this.configuration).getNote(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all comments associated with a note.
     * @summary Get all comments for a note
     * @param {number} id The ID of the note
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getNoteComments(id: number, start?: number, limit?: number, options?: any) {
        return NotesApiFp(this.configuration).getNoteComments(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all notes.
     * @summary Get all notes
     * @param {number} [user_id] The ID of the user whose notes to fetch. If omitted, notes by all users will be returned.
     * @param {string} [lead_id] The ID of the lead which notes to fetch. If omitted, notes about all leads will be returned.
     * @param {number} [deal_id] The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned.
     * @param {number} [person_id] The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned.
     * @param {number} [org_id] The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned.
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;content&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
     * @param {string} [start_date] The date in format of YYYY-MM-DD from which notes to fetch
     * @param {string} [end_date] The date in format of YYYY-MM-DD until which notes to fetch to
     * @param {number} [pinned_to_lead_flag] If set, the results are filtered by note to lead pinning state
     * @param {number} [pinned_to_deal_flag] If set, the results are filtered by note to deal pinning state
     * @param {number} [pinned_to_organization_flag] If set, the results are filtered by note to organization pinning state
     * @param {number} [pinned_to_person_flag] If set, the results are filtered by note to person pinning state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public getNotes(user_id?: number, lead_id?: string, deal_id?: number, person_id?: number, org_id?: number, start?: number, limit?: number, sort?: string, start_date?: string, end_date?: string, pinned_to_lead_flag?: number, pinned_to_deal_flag?: number, pinned_to_organization_flag?: number, pinned_to_person_flag?: number, options?: any) {
        return NotesApiFp(this.configuration).getNotes(user_id, lead_id, deal_id, person_id, org_id, start, limit, sort, start_date, end_date, pinned_to_lead_flag, pinned_to_deal_flag, pinned_to_organization_flag, pinned_to_person_flag, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a comment related to a note.
     * @summary Update a comment related to a note
     * @param {number} id The ID of the note
     * @param {string} commentId The ID of the comment
     * @param {CommentPostPutObject1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public updateCommentForNote(id: number, commentId: string, body?: CommentPostPutObject1, options?: any) {
        return NotesApiFp(this.configuration).updateCommentForNote(id, commentId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a note.
     * @summary Update a note
     * @param {number} id The ID of the note
     * @param {NoteRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public updateNote(id: number, body?: NoteRequest, options?: any) {
        return NotesApiFp(this.configuration).updateNote(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * OrganizationFieldsApi - fetch parameter creator
 * @export
 */
export const OrganizationFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new organization field
         * @param {CreateFieldRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationField(body?: CreateFieldRequest1, options: any = {}): FetchArgs {
            const localVarPath = `/organizationFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateFieldRequest1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete an organization field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOrganizationField.');
            }
            const localVarPath = `/organizationFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple organization fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationFields(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteOrganizationFields.');
            }
            const localVarPath = `/organizationFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific organization field.
         * @summary Get one organization field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationField.');
            }
            const localVarPath = `/organizationFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all organization fields.
         * @summary Get all organization fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFields(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/organizationFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update an organization field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationField(id: number, body?: UpdateFieldRequest1, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateOrganizationField.');
            }
            const localVarPath = `/organizationFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateFieldRequest1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationFieldsApi - functional programming interface
 * @export
 */
export const OrganizationFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new organization field
         * @param {CreateFieldRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationField(body?: CreateFieldRequest1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = OrganizationFieldsApiFetchParamCreator(configuration).addOrganizationField(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete an organization field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFieldResponse200> {
            const localVarFetchArgs = OrganizationFieldsApiFetchParamCreator(configuration).deleteOrganizationField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple organization fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationFields(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFieldsResponse200> {
            const localVarFetchArgs = OrganizationFieldsApiFetchParamCreator(configuration).deleteOrganizationFields(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific organization field.
         * @summary Get one organization field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = OrganizationFieldsApiFetchParamCreator(configuration).getOrganizationField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all organization fields.
         * @summary Get all organization fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFields(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldsResponse200> {
            const localVarFetchArgs = OrganizationFieldsApiFetchParamCreator(configuration).getOrganizationFields(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update an organization field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationField(id: number, body?: UpdateFieldRequest1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = OrganizationFieldsApiFetchParamCreator(configuration).updateOrganizationField(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationFieldsApi - factory interface
 * @export
 */
export const OrganizationFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new organization field
         * @param {CreateFieldRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationField(body?: CreateFieldRequest1, options?: any) {
            return OrganizationFieldsApiFp(configuration).addOrganizationField(body, options)(fetch, basePath);
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete an organization field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationField(id: number, options?: any) {
            return OrganizationFieldsApiFp(configuration).deleteOrganizationField(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple organization fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationFields(ids: string, options?: any) {
            return OrganizationFieldsApiFp(configuration).deleteOrganizationFields(ids, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific organization field.
         * @summary Get one organization field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationField(id: number, options?: any) {
            return OrganizationFieldsApiFp(configuration).getOrganizationField(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all organization fields.
         * @summary Get all organization fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFields(start?: number, limit?: number, options?: any) {
            return OrganizationFieldsApiFp(configuration).getOrganizationFields(start, limit, options)(fetch, basePath);
        },
        /**
         * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update an organization field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationField(id: number, body?: UpdateFieldRequest1, options?: any) {
            return OrganizationFieldsApiFp(configuration).updateOrganizationField(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationFieldsApi - interface
 * @export
 * @interface OrganizationFieldsApi
 */
export interface OrganizationFieldsApiInterface {
    /**
     * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new organization field
     * @param {CreateFieldRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApiInterface
     */
    addOrganizationField(body?: CreateFieldRequest1, options?: any): Promise<FieldResponse200>;

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete an organization field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApiInterface
     */
    deleteOrganizationField(id: number, options?: any): Promise<DeleteFieldResponse200>;

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple organization fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApiInterface
     */
    deleteOrganizationFields(ids: string, options?: any): Promise<DeleteFieldsResponse200>;

    /**
     * Returns data about a specific organization field.
     * @summary Get one organization field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApiInterface
     */
    getOrganizationField(id: number, options?: any): Promise<FieldResponse200>;

    /**
     * Returns data about all organization fields.
     * @summary Get all organization fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApiInterface
     */
    getOrganizationFields(start?: number, limit?: number, options?: any): Promise<FieldsResponse200>;

    /**
     * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update an organization field
     * @param {number} id The ID of the field
     * @param {UpdateFieldRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApiInterface
     */
    updateOrganizationField(id: number, body?: UpdateFieldRequest1, options?: any): Promise<FieldResponse200>;

}

/**
 * OrganizationFieldsApi - object-oriented interface
 * @export
 * @class OrganizationFieldsApi
 * @extends {BaseAPI}
 */
export class OrganizationFieldsApi extends BaseAPI implements OrganizationFieldsApiInterface {
    /**
     * Adds a new organization field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new organization field
     * @param {CreateFieldRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public addOrganizationField(body?: CreateFieldRequest1, options?: any) {
        return OrganizationFieldsApiFp(this.configuration).addOrganizationField(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete an organization field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public deleteOrganizationField(id: number, options?: any) {
        return OrganizationFieldsApiFp(this.configuration).deleteOrganizationField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple organization fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public deleteOrganizationFields(ids: string, options?: any) {
        return OrganizationFieldsApiFp(this.configuration).deleteOrganizationFields(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific organization field.
     * @summary Get one organization field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public getOrganizationField(id: number, options?: any) {
        return OrganizationFieldsApiFp(this.configuration).getOrganizationField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all organization fields.
     * @summary Get all organization fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public getOrganizationFields(start?: number, limit?: number, options?: any) {
        return OrganizationFieldsApiFp(this.configuration).getOrganizationFields(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an organization field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update an organization field
     * @param {number} id The ID of the field
     * @param {UpdateFieldRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationFieldsApi
     */
    public updateOrganizationField(id: number, body?: UpdateFieldRequest1, options?: any) {
        return OrganizationFieldsApiFp(this.configuration).updateOrganizationField(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * OrganizationRelationshipsApi - fetch parameter creator
 * @export
 */
export const OrganizationRelationshipsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates and returns an organization relationship.
         * @summary Create an organization relationship
         * @param {AddOrganizationRelationshipRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationRelationship(body?: AddOrganizationRelationshipRequest, options: any = {}): FetchArgs {
            const localVarPath = `/organizationRelationships`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddOrganizationRelationshipRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an organization relationship and returns the deleted ID.
         * @summary Delete an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRelationship(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOrganizationRelationship.');
            }
            const localVarPath = `/organizationRelationships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds and returns an organization relationship from its ID.
         * @summary Get one organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {number} [org_id] The ID of the base organization for the returned calculated values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRelationship(id: number, org_id?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationRelationship.');
            }
            const localVarPath = `/organizationRelationships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all of the relationships for a supplied organization ID.
         * @summary Get all relationships for organization
         * @param {number} org_id The ID of the organization to get relationships for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRelationships(org_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'org_id' is not null or undefined
            if (org_id === null || org_id === undefined) {
                throw new RequiredError('org_id','Required parameter org_id was null or undefined when calling getOrganizationRelationships.');
            }
            const localVarPath = `/organizationRelationships`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates and returns an organization relationship.
         * @summary Update an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {OrganizationRelationship} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationRelationship(id: number, body?: OrganizationRelationship, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateOrganizationRelationship.');
            }
            const localVarPath = `/organizationRelationships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationRelationship" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationRelationshipsApi - functional programming interface
 * @export
 */
export const OrganizationRelationshipsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates and returns an organization relationship.
         * @summary Create an organization relationship
         * @param {AddOrganizationRelationshipRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationRelationship(body?: AddOrganizationRelationshipRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrganizationRelationshipResponse200> {
            const localVarFetchArgs = OrganizationRelationshipsApiFetchParamCreator(configuration).addOrganizationRelationship(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an organization relationship and returns the deleted ID.
         * @summary Delete an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRelationship(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteOrganizationRelationshipResponse200> {
            const localVarFetchArgs = OrganizationRelationshipsApiFetchParamCreator(configuration).deleteOrganizationRelationship(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds and returns an organization relationship from its ID.
         * @summary Get one organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {number} [org_id] The ID of the base organization for the returned calculated values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRelationship(id: number, org_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOrganizationRelationshipResponse200> {
            const localVarFetchArgs = OrganizationRelationshipsApiFetchParamCreator(configuration).getOrganizationRelationship(id, org_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets all of the relationships for a supplied organization ID.
         * @summary Get all relationships for organization
         * @param {number} org_id The ID of the organization to get relationships for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRelationships(org_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOrganizationRelationshipsResponse200> {
            const localVarFetchArgs = OrganizationRelationshipsApiFetchParamCreator(configuration).getOrganizationRelationships(org_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates and returns an organization relationship.
         * @summary Update an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {OrganizationRelationship} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationRelationship(id: number, body?: OrganizationRelationship, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateOrganizationRelationshipResponse200> {
            const localVarFetchArgs = OrganizationRelationshipsApiFetchParamCreator(configuration).updateOrganizationRelationship(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationRelationshipsApi - factory interface
 * @export
 */
export const OrganizationRelationshipsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates and returns an organization relationship.
         * @summary Create an organization relationship
         * @param {AddOrganizationRelationshipRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationRelationship(body?: AddOrganizationRelationshipRequest, options?: any) {
            return OrganizationRelationshipsApiFp(configuration).addOrganizationRelationship(body, options)(fetch, basePath);
        },
        /**
         * Deletes an organization relationship and returns the deleted ID.
         * @summary Delete an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRelationship(id: number, options?: any) {
            return OrganizationRelationshipsApiFp(configuration).deleteOrganizationRelationship(id, options)(fetch, basePath);
        },
        /**
         * Finds and returns an organization relationship from its ID.
         * @summary Get one organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {number} [org_id] The ID of the base organization for the returned calculated values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRelationship(id: number, org_id?: number, options?: any) {
            return OrganizationRelationshipsApiFp(configuration).getOrganizationRelationship(id, org_id, options)(fetch, basePath);
        },
        /**
         * Gets all of the relationships for a supplied organization ID.
         * @summary Get all relationships for organization
         * @param {number} org_id The ID of the organization to get relationships for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRelationships(org_id: number, options?: any) {
            return OrganizationRelationshipsApiFp(configuration).getOrganizationRelationships(org_id, options)(fetch, basePath);
        },
        /**
         * Updates and returns an organization relationship.
         * @summary Update an organization relationship
         * @param {number} id The ID of the organization relationship
         * @param {OrganizationRelationship} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationRelationship(id: number, body?: OrganizationRelationship, options?: any) {
            return OrganizationRelationshipsApiFp(configuration).updateOrganizationRelationship(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationRelationshipsApi - interface
 * @export
 * @interface OrganizationRelationshipsApi
 */
export interface OrganizationRelationshipsApiInterface {
    /**
     * Creates and returns an organization relationship.
     * @summary Create an organization relationship
     * @param {AddOrganizationRelationshipRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApiInterface
     */
    addOrganizationRelationship(body?: AddOrganizationRelationshipRequest, options?: any): Promise<AddOrganizationRelationshipResponse200>;

    /**
     * Deletes an organization relationship and returns the deleted ID.
     * @summary Delete an organization relationship
     * @param {number} id The ID of the organization relationship
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApiInterface
     */
    deleteOrganizationRelationship(id: number, options?: any): Promise<DeleteOrganizationRelationshipResponse200>;

    /**
     * Finds and returns an organization relationship from its ID.
     * @summary Get one organization relationship
     * @param {number} id The ID of the organization relationship
     * @param {number} [org_id] The ID of the base organization for the returned calculated values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApiInterface
     */
    getOrganizationRelationship(id: number, org_id?: number, options?: any): Promise<GetOrganizationRelationshipResponse200>;

    /**
     * Gets all of the relationships for a supplied organization ID.
     * @summary Get all relationships for organization
     * @param {number} org_id The ID of the organization to get relationships for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApiInterface
     */
    getOrganizationRelationships(org_id: number, options?: any): Promise<GetOrganizationRelationshipsResponse200>;

    /**
     * Updates and returns an organization relationship.
     * @summary Update an organization relationship
     * @param {number} id The ID of the organization relationship
     * @param {OrganizationRelationship} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApiInterface
     */
    updateOrganizationRelationship(id: number, body?: OrganizationRelationship, options?: any): Promise<UpdateOrganizationRelationshipResponse200>;

}

/**
 * OrganizationRelationshipsApi - object-oriented interface
 * @export
 * @class OrganizationRelationshipsApi
 * @extends {BaseAPI}
 */
export class OrganizationRelationshipsApi extends BaseAPI implements OrganizationRelationshipsApiInterface {
    /**
     * Creates and returns an organization relationship.
     * @summary Create an organization relationship
     * @param {AddOrganizationRelationshipRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public addOrganizationRelationship(body?: AddOrganizationRelationshipRequest, options?: any) {
        return OrganizationRelationshipsApiFp(this.configuration).addOrganizationRelationship(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an organization relationship and returns the deleted ID.
     * @summary Delete an organization relationship
     * @param {number} id The ID of the organization relationship
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public deleteOrganizationRelationship(id: number, options?: any) {
        return OrganizationRelationshipsApiFp(this.configuration).deleteOrganizationRelationship(id, options)(this.fetch, this.basePath);
    }

    /**
     * Finds and returns an organization relationship from its ID.
     * @summary Get one organization relationship
     * @param {number} id The ID of the organization relationship
     * @param {number} [org_id] The ID of the base organization for the returned calculated values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public getOrganizationRelationship(id: number, org_id?: number, options?: any) {
        return OrganizationRelationshipsApiFp(this.configuration).getOrganizationRelationship(id, org_id, options)(this.fetch, this.basePath);
    }

    /**
     * Gets all of the relationships for a supplied organization ID.
     * @summary Get all relationships for organization
     * @param {number} org_id The ID of the organization to get relationships for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public getOrganizationRelationships(org_id: number, options?: any) {
        return OrganizationRelationshipsApiFp(this.configuration).getOrganizationRelationships(org_id, options)(this.fetch, this.basePath);
    }

    /**
     * Updates and returns an organization relationship.
     * @summary Update an organization relationship
     * @param {number} id The ID of the organization relationship
     * @param {OrganizationRelationship} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRelationshipsApi
     */
    public updateOrganizationRelationship(id: number, body?: OrganizationRelationship, options?: any) {
        return OrganizationRelationshipsApiFp(this.configuration).updateOrganizationRelationship(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export const OrganizationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
         * @summary Add an organization
         * @param {AddOrganizationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganization(body?: AddOrganizationRequest, options: any = {}): FetchArgs {
            const localVarPath = `/organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddOrganizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to an organization.
         * @summary Add a follower to an organization
         * @param {number} id The ID of the organization
         * @param {AddOrganizationFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationFollower(id: number, body?: AddOrganizationFollowerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addOrganizationFollower.');
            }
            const localVarPath = `/organizations/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddOrganizationFollowerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an organization as deleted.
         * @summary Delete an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOrganization.');
            }
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
         * @summary Delete a follower from an organization
         * @param {number} id The ID of the organization
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationFollower(id: number, follower_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOrganizationFollower.');
            }
            // verify required parameter 'follower_id' is not null or undefined
            if (follower_id === null || follower_id === undefined) {
                throw new RequiredError('follower_id','Required parameter follower_id was null or undefined when calling deleteOrganizationFollower.');
            }
            const localVarPath = `/organizations/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple organizations as deleted.
         * @summary Delete multiple organizations in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizations(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteOrganizations.');
            }
            const localVarPath = `/organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
         * @summary Get details of an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganization.');
            }
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists activities associated with an organization.
         * @summary List activities associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationActivities.');
            }
            const localVarPath = `/organizations/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals associated with an organization.
         * @summary List deals associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {number} [only_primary_association] If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, only_primary_association?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationDeals.');
            }
            const localVarPath = `/organizations/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (only_primary_association !== undefined) {
                localVarQueryParameter['only_primary_association'] = only_primary_association;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with an organization.
         * @summary List files attached to an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationFiles.');
            }
            const localVarPath = `/organizations/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (include_deleted_files !== undefined) {
                localVarQueryParameter['include_deleted_files'] = include_deleted_files;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of an organization.
         * @summary List followers of an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFollowers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationFollowers.');
            }
            const localVarPath = `/organizations/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists mail messages associated with an organization.
         * @summary List mail messages associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMailMessages(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationMailMessages.');
            }
            const localVarPath = `/organizations/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List persons of an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPersons(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationPersons.');
            }
            const localVarPath = `/organizations/{id}/persons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists updates about an organization.
         * @summary List updates about an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationUpdates.');
            }
            const localVarPath = `/organizations/{id}/flow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (all_changes !== undefined) {
                localVarQueryParameter['all_changes'] = all_changes;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users permitted to access an organization.
         * @summary List permitted users
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrganizationUsers.');
            }
            const localVarPath = `/organizations/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all organizations.
         * @summary Get all organizations
         * @param {number} [user_id] If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
         * @summary Merge two organizations
         * @param {number} id The ID of the organization
         * @param {MergeOrganizationsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeOrganizations(id: number, body?: MergeOrganizationsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling mergeOrganizations.');
            }
            const localVarPath = `/organizations/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MergeOrganizationsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrganization(term: string, fields?: string, exact_match?: boolean, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling searchOrganization.');
            }
            const localVarPath = `/organizations/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of an organization.
         * @summary Update an organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(id: number, body?: UpdateOrganizationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateOrganization.');
            }
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOrganizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
         * @summary Add an organization
         * @param {AddOrganizationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganization(body?: AddOrganizationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrganizationResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).addOrganization(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a follower to an organization.
         * @summary Add a follower to an organization
         * @param {number} id The ID of the organization
         * @param {AddOrganizationFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationFollower(id: number, body?: AddOrganizationFollowerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrganizationFollowerResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).addOrganizationFollower(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks an organization as deleted.
         * @summary Delete an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteOrganizationResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganization(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
         * @summary Delete a follower from an organization
         * @param {number} id The ID of the organization
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationFollower(id: number, follower_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteOrganizationFollowerResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganizationFollower(id, follower_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple organizations as deleted.
         * @summary Delete multiple organizations in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizations(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteOrganizationsResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganizations(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
         * @summary Get details of an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOrganizationResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganization(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists activities associated with an organization.
         * @summary List activities associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedActivitiesResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationActivities(id, start, limit, done, exclude, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists deals associated with an organization.
         * @summary List deals associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {number} [only_primary_association] If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, only_primary_association?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedDealsResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationDeals(id, start, limit, status, sort, only_primary_association, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists files associated with an organization.
         * @summary List files attached to an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedFilesResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationFiles(id, start, limit, include_deleted_files, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the followers of an organization.
         * @summary List followers of an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFollowers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedFollowersResponse2001> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationFollowers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists mail messages associated with an organization.
         * @summary List mail messages associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMailMessages(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedMailMessagesResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationMailMessages(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List persons of an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPersons(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListPersonsResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationPersons(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists updates about an organization.
         * @summary List updates about an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedUpdatesResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationUpdates(id, start, limit, all_changes, items, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List users permitted to access an organization.
         * @summary List permitted users
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListPermittedUsersResponse2001> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationUsers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all organizations.
         * @summary Get all organizations
         * @param {number} [user_id] If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOrganizationsResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizations(user_id, filter_id, first_char, start, limit, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
         * @summary Merge two organizations
         * @param {number} id The ID of the organization
         * @param {MergeOrganizationsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeOrganizations(id: number, body?: MergeOrganizationsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MergeOrganizationsResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).mergeOrganizations(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrganization(term: string, fields?: string, exact_match?: boolean, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchOrganizationResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).searchOrganization(term, fields, exact_match, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of an organization.
         * @summary Update an organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(id: number, body?: UpdateOrganizationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateOrganizationResponse200> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateOrganization(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
         * @summary Add an organization
         * @param {AddOrganizationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganization(body?: AddOrganizationRequest, options?: any) {
            return OrganizationsApiFp(configuration).addOrganization(body, options)(fetch, basePath);
        },
        /**
         * Adds a follower to an organization.
         * @summary Add a follower to an organization
         * @param {number} id The ID of the organization
         * @param {AddOrganizationFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationFollower(id: number, body?: AddOrganizationFollowerRequest, options?: any) {
            return OrganizationsApiFp(configuration).addOrganizationFollower(id, body, options)(fetch, basePath);
        },
        /**
         * Marks an organization as deleted.
         * @summary Delete an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(id: number, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganization(id, options)(fetch, basePath);
        },
        /**
         * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
         * @summary Delete a follower from an organization
         * @param {number} id The ID of the organization
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationFollower(id: number, follower_id: number, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganizationFollower(id, follower_id, options)(fetch, basePath);
        },
        /**
         * Marks multiple organizations as deleted.
         * @summary Delete multiple organizations in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizations(ids: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganizations(ids, options)(fetch, basePath);
        },
        /**
         * Returns details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
         * @summary Get details of an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganization(id, options)(fetch, basePath);
        },
        /**
         * Lists activities associated with an organization.
         * @summary List activities associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationActivities(id, start, limit, done, exclude, options)(fetch, basePath);
        },
        /**
         * Lists deals associated with an organization.
         * @summary List deals associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {number} [only_primary_association] If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, only_primary_association?: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationDeals(id, start, limit, status, sort, only_primary_association, options)(fetch, basePath);
        },
        /**
         * Lists files associated with an organization.
         * @summary List files attached to an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationFiles(id, start, limit, include_deleted_files, sort, options)(fetch, basePath);
        },
        /**
         * Lists the followers of an organization.
         * @summary List followers of an organization
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationFollowers(id: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationFollowers(id, options)(fetch, basePath);
        },
        /**
         * Lists mail messages associated with an organization.
         * @summary List mail messages associated with an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMailMessages(id: number, start?: number, limit?: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationMailMessages(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary List persons of an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPersons(id: number, start?: number, limit?: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationPersons(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists updates about an organization.
         * @summary List updates about an organization
         * @param {number} id The ID of the organization
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationUpdates(id, start, limit, all_changes, items, options)(fetch, basePath);
        },
        /**
         * List users permitted to access an organization.
         * @summary List permitted users
         * @param {number} id The ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsers(id: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationUsers(id, options)(fetch, basePath);
        },
        /**
         * Returns all organizations.
         * @summary Get all organizations
         * @param {number} [user_id] If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizations(user_id, filter_id, first_char, start, limit, sort, options)(fetch, basePath);
        },
        /**
         * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
         * @summary Merge two organizations
         * @param {number} id The ID of the organization
         * @param {MergeOrganizationsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeOrganizations(id: number, body?: MergeOrganizationsRequest, options?: any) {
            return OrganizationsApiFp(configuration).mergeOrganizations(id, body, options)(fetch, basePath);
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrganization(term: string, fields?: string, exact_match?: boolean, start?: number, limit?: number, options?: any) {
            return OrganizationsApiFp(configuration).searchOrganization(term, fields, exact_match, start, limit, options)(fetch, basePath);
        },
        /**
         * Updates the properties of an organization.
         * @summary Update an organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(id: number, body?: UpdateOrganizationRequest, options?: any) {
            return OrganizationsApiFp(configuration).updateOrganization(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsApi - interface
 * @export
 * @interface OrganizationsApi
 */
export interface OrganizationsApiInterface {
    /**
     * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
     * @summary Add an organization
     * @param {AddOrganizationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    addOrganization(body?: AddOrganizationRequest, options?: any): Promise<AddOrganizationResponse200>;

    /**
     * Adds a follower to an organization.
     * @summary Add a follower to an organization
     * @param {number} id The ID of the organization
     * @param {AddOrganizationFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    addOrganizationFollower(id: number, body?: AddOrganizationFollowerRequest, options?: any): Promise<AddOrganizationFollowerResponse200>;

    /**
     * Marks an organization as deleted.
     * @summary Delete an organization
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    deleteOrganization(id: number, options?: any): Promise<DeleteOrganizationResponse200>;

    /**
     * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
     * @summary Delete a follower from an organization
     * @param {number} id The ID of the organization
     * @param {number} follower_id The ID of the follower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    deleteOrganizationFollower(id: number, follower_id: number, options?: any): Promise<DeleteOrganizationFollowerResponse200>;

    /**
     * Marks multiple organizations as deleted.
     * @summary Delete multiple organizations in bulk
     * @param {string} ids The comma-separated IDs that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    deleteOrganizations(ids: string, options?: any): Promise<DeleteOrganizationsResponse200>;

    /**
     * Returns details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
     * @summary Get details of an organization
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganization(id: number, options?: any): Promise<GetOrganizationResponse200>;

    /**
     * Lists activities associated with an organization.
     * @summary List activities associated with an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
     * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any): Promise<GetAssociatedActivitiesResponse200>;

    /**
     * Lists deals associated with an organization.
     * @summary List deals associated with an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {number} [only_primary_association] If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, only_primary_association?: number, options?: any): Promise<GetAssociatedDealsResponse200>;

    /**
     * Lists files associated with an organization.
     * @summary List files attached to an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): Promise<GetAssociatedFilesResponse200>;

    /**
     * Lists the followers of an organization.
     * @summary List followers of an organization
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationFollowers(id: number, options?: any): Promise<GetAssociatedFollowersResponse2001>;

    /**
     * Lists mail messages associated with an organization.
     * @summary List mail messages associated with an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationMailMessages(id: number, start?: number, limit?: number, options?: any): Promise<GetAssociatedMailMessagesResponse200>;

    /**
     * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary List persons of an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationPersons(id: number, start?: number, limit?: number, options?: any): Promise<ListPersonsResponse200>;

    /**
     * Lists updates about an organization.
     * @summary List updates about an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
     * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any): Promise<GetAssociatedUpdatesResponse200>;

    /**
     * List users permitted to access an organization.
     * @summary List permitted users
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizationUsers(id: number, options?: any): Promise<ListPermittedUsersResponse2001>;

    /**
     * Returns all organizations.
     * @summary Get all organizations
     * @param {number} [user_id] If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case insensitive)
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    getOrganizations(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any): Promise<GetOrganizationsResponse200>;

    /**
     * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
     * @summary Merge two organizations
     * @param {number} id The ID of the organization
     * @param {MergeOrganizationsRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    mergeOrganizations(id: number, body?: MergeOrganizationsRequest, options?: any): Promise<MergeOrganizationsResponse200>;

    /**
     * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search organizations
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    searchOrganization(term: string, fields?: string, exact_match?: boolean, start?: number, limit?: number, options?: any): Promise<SearchOrganizationResponse200>;

    /**
     * Updates the properties of an organization.
     * @summary Update an organization
     * @param {number} id The ID of the organization
     * @param {UpdateOrganizationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApiInterface
     */
    updateOrganization(id: number, body?: UpdateOrganizationRequest, options?: any): Promise<UpdateOrganizationResponse200>;

}

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI implements OrganizationsApiInterface {
    /**
     * Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-an-organization\" target=\"_blank\" rel=\"noopener noreferrer\">adding an organization</a>.
     * @summary Add an organization
     * @param {AddOrganizationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganization(body?: AddOrganizationRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).addOrganization(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a follower to an organization.
     * @summary Add a follower to an organization
     * @param {number} id The ID of the organization
     * @param {AddOrganizationFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationFollower(id: number, body?: AddOrganizationFollowerRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).addOrganizationFollower(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks an organization as deleted.
     * @summary Delete an organization
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganization(id: number, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganization(id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a follower from an organization. You can retrieve the `follower_id` from the <a href=\"https://developers.pipedrive.com/docs/api/v1/Organizations#getOrganizationFollowers\">List followers of an organization</a> endpoint.
     * @summary Delete a follower from an organization
     * @param {number} id The ID of the organization
     * @param {number} follower_id The ID of the follower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationFollower(id: number, follower_id: number, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationFollower(id, follower_id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple organizations as deleted.
     * @summary Delete multiple organizations in bulk
     * @param {string} ids The comma-separated IDs that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizations(ids: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganizations(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.
     * @summary Get details of an organization
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(id: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganization(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists activities associated with an organization.
     * @summary List activities associated with an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted returns both Done and Not done activities.
     * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationActivities(id, start, limit, done, exclude, options)(this.fetch, this.basePath);
    }

    /**
     * Lists deals associated with an organization.
     * @summary List deals associated with an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {number} [only_primary_association] If set, only deals that are directly associated to the organization are fetched. If not set (default), all deals are fetched that are either directly or indirectly related to the organization. Indirect relations include relations through custom, organization-type fields and through persons of the given organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, only_primary_association?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationDeals(id, start, limit, status, sort, only_primary_association, options)(this.fetch, this.basePath);
    }

    /**
     * Lists files associated with an organization.
     * @summary List files attached to an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationFiles(id, start, limit, include_deleted_files, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the followers of an organization.
     * @summary List followers of an organization
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationFollowers(id: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationFollowers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists mail messages associated with an organization.
     * @summary List mail messages associated with an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationMailMessages(id: number, start?: number, limit?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationMailMessages(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary List persons of an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationPersons(id: number, start?: number, limit?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationPersons(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists updates about an organization.
     * @summary List updates about an organization
     * @param {number} id The ID of the organization
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted, returns changes without custom field updates.
     * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - activity, plannedActivity, note, file, change, deal, follower, participant, mailMessage, mailMessageWithAttachment, invoice, activityFile, document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationUpdates(id, start, limit, all_changes, items, options)(this.fetch, this.basePath);
    }

    /**
     * List users permitted to access an organization.
     * @summary List permitted users
     * @param {number} id The ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationUsers(id: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationUsers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all organizations.
     * @summary Get all organizations
     * @param {number} [user_id] If supplied, only organizations owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {string} [first_char] If supplied, only organizations whose name starts with the specified letter will be returned (case insensitive)
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizations(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizations(user_id, filter_id, first_char, start, limit, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Merges an organization with another organization. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-organizations\" target=\"_blank\" rel=\"noopener noreferrer\">merging two organizations</a>.
     * @summary Merge two organizations
     * @param {number} id The ID of the organization
     * @param {MergeOrganizationsRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public mergeOrganizations(id: number, body?: MergeOrganizationsRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).mergeOrganizations(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search organizations
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public searchOrganization(term: string, fields?: string, exact_match?: boolean, start?: number, limit?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).searchOrganization(term, fields, exact_match, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of an organization.
     * @summary Update an organization
     * @param {number} id The ID of the organization
     * @param {UpdateOrganizationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganization(id: number, body?: UpdateOrganizationRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganization(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * PermissionSetsApi - fetch parameter creator
 * @export
 */
export const PermissionSetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about a specific permission set.
         * @summary Get one permission set
         * @param {string} id The ID of the permission set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPermissionSet.');
            }
            const localVarPath = `/permissionSets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of assignments for a permission set.
         * @summary List permission set assignments
         * @param {string} id The ID of the permission set
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSetAssignments(id: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPermissionSetAssignments.');
            }
            const localVarPath = `/permissionSets/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all permission sets.
         * @summary Get all permission sets
         * @param {string} [app] The app to filter the permission sets by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSets(app?: string, options: any = {}): FetchArgs {
            const localVarPath = `/permissionSets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionSetsApi - functional programming interface
 * @export
 */
export const PermissionSetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns data about a specific permission set.
         * @summary Get one permission set
         * @param {string} id The ID of the permission set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SinglePermissionSetResponse200> {
            const localVarFetchArgs = PermissionSetsApiFetchParamCreator(configuration).getPermissionSet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the list of assignments for a permission set.
         * @summary List permission set assignments
         * @param {string} id The ID of the permission set
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSetAssignments(id: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAssignmentsToPermissionSetResponse200> {
            const localVarFetchArgs = PermissionSetsApiFetchParamCreator(configuration).getPermissionSetAssignments(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all permission sets.
         * @summary Get all permission sets
         * @param {string} [app] The app to filter the permission sets by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSets(app?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPermissionSetsResponse200> {
            const localVarFetchArgs = PermissionSetsApiFetchParamCreator(configuration).getPermissionSets(app, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PermissionSetsApi - factory interface
 * @export
 */
export const PermissionSetsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns data about a specific permission set.
         * @summary Get one permission set
         * @param {string} id The ID of the permission set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSet(id: string, options?: any) {
            return PermissionSetsApiFp(configuration).getPermissionSet(id, options)(fetch, basePath);
        },
        /**
         * Returns the list of assignments for a permission set.
         * @summary List permission set assignments
         * @param {string} id The ID of the permission set
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSetAssignments(id: string, start?: number, limit?: number, options?: any) {
            return PermissionSetsApiFp(configuration).getPermissionSetAssignments(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Returns data about all permission sets.
         * @summary Get all permission sets
         * @param {string} [app] The app to filter the permission sets by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionSets(app?: string, options?: any) {
            return PermissionSetsApiFp(configuration).getPermissionSets(app, options)(fetch, basePath);
        },
    };
};

/**
 * PermissionSetsApi - interface
 * @export
 * @interface PermissionSetsApi
 */
export interface PermissionSetsApiInterface {
    /**
     * Returns data about a specific permission set.
     * @summary Get one permission set
     * @param {string} id The ID of the permission set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionSetsApiInterface
     */
    getPermissionSet(id: string, options?: any): Promise<SinglePermissionSetResponse200>;

    /**
     * Returns the list of assignments for a permission set.
     * @summary List permission set assignments
     * @param {string} id The ID of the permission set
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionSetsApiInterface
     */
    getPermissionSetAssignments(id: string, start?: number, limit?: number, options?: any): Promise<UserAssignmentsToPermissionSetResponse200>;

    /**
     * Returns data about all permission sets.
     * @summary Get all permission sets
     * @param {string} [app] The app to filter the permission sets by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionSetsApiInterface
     */
    getPermissionSets(app?: string, options?: any): Promise<GetPermissionSetsResponse200>;

}

/**
 * PermissionSetsApi - object-oriented interface
 * @export
 * @class PermissionSetsApi
 * @extends {BaseAPI}
 */
export class PermissionSetsApi extends BaseAPI implements PermissionSetsApiInterface {
    /**
     * Returns data about a specific permission set.
     * @summary Get one permission set
     * @param {string} id The ID of the permission set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionSetsApi
     */
    public getPermissionSet(id: string, options?: any) {
        return PermissionSetsApiFp(this.configuration).getPermissionSet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the list of assignments for a permission set.
     * @summary List permission set assignments
     * @param {string} id The ID of the permission set
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionSetsApi
     */
    public getPermissionSetAssignments(id: string, start?: number, limit?: number, options?: any) {
        return PermissionSetsApiFp(this.configuration).getPermissionSetAssignments(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all permission sets.
     * @summary Get all permission sets
     * @param {string} [app] The app to filter the permission sets by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionSetsApi
     */
    public getPermissionSets(app?: string, options?: any) {
        return PermissionSetsApiFp(this.configuration).getPermissionSets(app, options)(this.fetch, this.basePath);
    }

}
/**
 * PersonFieldsApi - fetch parameter creator
 * @export
 */
export const PersonFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new person field
         * @param {CreateFieldRequest2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonField(body?: CreateFieldRequest2, options: any = {}): FetchArgs {
            const localVarPath = `/personFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateFieldRequest2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a person field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePersonField.');
            }
            const localVarPath = `/personFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple person fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonFields(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deletePersonFields.');
            }
            const localVarPath = `/personFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific person field.
         * @summary Get one person field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonField.');
            }
            const localVarPath = `/personFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get all person fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFields(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/personFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a person field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonField(id: number, body?: UpdateFieldRequest2, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePersonField.');
            }
            const localVarPath = `/personFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateFieldRequest2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonFieldsApi - functional programming interface
 * @export
 */
export const PersonFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new person field
         * @param {CreateFieldRequest2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonField(body?: CreateFieldRequest2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = PersonFieldsApiFetchParamCreator(configuration).addPersonField(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a person field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFieldResponse200> {
            const localVarFetchArgs = PersonFieldsApiFetchParamCreator(configuration).deletePersonField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple person fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonFields(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteFieldsResponse200> {
            const localVarFetchArgs = PersonFieldsApiFetchParamCreator(configuration).deletePersonFields(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific person field.
         * @summary Get one person field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = PersonFieldsApiFetchParamCreator(configuration).getPersonField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get all person fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFields(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldsResponse200> {
            const localVarFetchArgs = PersonFieldsApiFetchParamCreator(configuration).getPersonFields(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a person field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonField(id: number, body?: UpdateFieldRequest2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FieldResponse200> {
            const localVarFetchArgs = PersonFieldsApiFetchParamCreator(configuration).updatePersonField(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PersonFieldsApi - factory interface
 * @export
 */
export const PersonFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new person field
         * @param {CreateFieldRequest2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonField(body?: CreateFieldRequest2, options?: any) {
            return PersonFieldsApiFp(configuration).addPersonField(body, options)(fetch, basePath);
        },
        /**
         * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a person field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonField(id: number, options?: any) {
            return PersonFieldsApiFp(configuration).deletePersonField(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple person fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonFields(ids: string, options?: any) {
            return PersonFieldsApiFp(configuration).deletePersonFields(ids, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific person field.
         * @summary Get one person field
         * @param {number} id The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonField(id: number, options?: any) {
            return PersonFieldsApiFp(configuration).getPersonField(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get all person fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFields(start?: number, limit?: number, options?: any) {
            return PersonFieldsApiFp(configuration).getPersonFields(start, limit, options)(fetch, basePath);
        },
        /**
         * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a person field
         * @param {number} id The ID of the field
         * @param {UpdateFieldRequest2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonField(id: number, body?: UpdateFieldRequest2, options?: any) {
            return PersonFieldsApiFp(configuration).updatePersonField(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * PersonFieldsApi - interface
 * @export
 * @interface PersonFieldsApi
 */
export interface PersonFieldsApiInterface {
    /**
     * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new person field
     * @param {CreateFieldRequest2} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApiInterface
     */
    addPersonField(body?: CreateFieldRequest2, options?: any): Promise<FieldResponse200>;

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a person field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApiInterface
     */
    deletePersonField(id: number, options?: any): Promise<DeleteFieldResponse200>;

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple person fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApiInterface
     */
    deletePersonFields(ids: string, options?: any): Promise<DeleteFieldsResponse200>;

    /**
     * Returns data about a specific person field.
     * @summary Get one person field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApiInterface
     */
    getPersonField(id: number, options?: any): Promise<FieldResponse200>;

    /**
     * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary Get all person fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApiInterface
     */
    getPersonFields(start?: number, limit?: number, options?: any): Promise<FieldsResponse200>;

    /**
     * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update a person field
     * @param {number} id The ID of the field
     * @param {UpdateFieldRequest2} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApiInterface
     */
    updatePersonField(id: number, body?: UpdateFieldRequest2, options?: any): Promise<FieldResponse200>;

}

/**
 * PersonFieldsApi - object-oriented interface
 * @export
 * @class PersonFieldsApi
 * @extends {BaseAPI}
 */
export class PersonFieldsApi extends BaseAPI implements PersonFieldsApiInterface {
    /**
     * Adds a new person field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new person field
     * @param {CreateFieldRequest2} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public addPersonField(body?: CreateFieldRequest2, options?: any) {
        return PersonFieldsApiFp(this.configuration).addPersonField(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a person field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public deletePersonField(id: number, options?: any) {
        return PersonFieldsApiFp(this.configuration).deletePersonField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple person fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public deletePersonFields(ids: string, options?: any) {
        return PersonFieldsApiFp(this.configuration).deletePersonFields(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific person field.
     * @summary Get one person field
     * @param {number} id The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public getPersonField(id: number, options?: any) {
        return PersonFieldsApiFp(this.configuration).getPersonField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary Get all person fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public getPersonFields(start?: number, limit?: number, options?: any) {
        return PersonFieldsApiFp(this.configuration).getPersonFields(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a person field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update a person field
     * @param {number} id The ID of the field
     * @param {UpdateFieldRequest2} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonFieldsApi
     */
    public updatePersonField(id: number, body?: UpdateFieldRequest2, options?: any) {
        return PersonFieldsApiFp(this.configuration).updatePersonField(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * PersonsApi - fetch parameter creator
 * @export
 */
export const PersonsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {AddPersonRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPerson(body?: AddPersonRequest, options: any = {}): FetchArgs {
            const localVarPath = `/persons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddPersonRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {number} id The ID of the person
         * @param {AddPersonFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonFollower(id: number, body?: AddPersonFollowerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPersonFollower.');
            }
            const localVarPath = `/persons/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddPersonFollowerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {number} id The ID of the person
         * @param {Blob} [file] 
         * @param {number} [crop_x] 
         * @param {number} [crop_y] 
         * @param {number} [crop_width] 
         * @param {number} [crop_height] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonPicture(id: number, file?: Blob, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPersonPicture.');
            }
            const localVarPath = `/persons/{id}/picture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (crop_x !== undefined) {
                localVarFormParams.set('crop_x', crop_x as any);
            }

            if (crop_y !== undefined) {
                localVarFormParams.set('crop_y', crop_y as any);
            }

            if (crop_width !== undefined) {
                localVarFormParams.set('crop_width', crop_width as any);
            }

            if (crop_height !== undefined) {
                localVarFormParams.set('crop_height', crop_height as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a person as deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePerson.');
            }
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {number} id The ID of the person
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonFollower(id: number, follower_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePersonFollower.');
            }
            // verify required parameter 'follower_id' is not null or undefined
            if (follower_id === null || follower_id === undefined) {
                throw new RequiredError('follower_id','Required parameter follower_id was null or undefined when calling deletePersonFollower.');
            }
            const localVarPath = `/persons/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a persons picture.
         * @summary Delete person picture
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonPicture(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePersonPicture.');
            }
            const localVarPath = `/persons/{id}/picture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple persons as deleted.
         * @summary Delete multiple persons in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersons(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deletePersons.');
            }
            const localVarPath = `/persons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPerson.');
            }
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonActivities.');
            }
            const localVarPath = `/persons/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (done !== undefined) {
                localVarQueryParameter['done'] = done;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonDeals.');
            }
            const localVarPath = `/persons/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonFiles.');
            }
            const localVarPath = `/persons/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (include_deleted_files !== undefined) {
                localVarQueryParameter['include_deleted_files'] = include_deleted_files;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFollowers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonFollowers.');
            }
            const localVarPath = `/persons/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonMailMessages(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonMailMessages.');
            }
            const localVarPath = `/persons/{id}/mailMessages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonProducts(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonProducts.');
            }
            const localVarPath = `/persons/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint's response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonUpdates.');
            }
            const localVarPath = `/persons/{id}/flow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (all_changes !== undefined) {
                localVarQueryParameter['all_changes'] = all_changes;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonUsers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPersonUsers.');
            }
            const localVarPath = `/persons/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/persons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {number} id The ID of the person
         * @param {MergePersonsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergePersons(id: number, body?: MergePersonsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling mergePersons.');
            }
            const localVarPath = `/persons/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MergePersonsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersons(term: string, fields?: string, exact_match?: boolean, organization_id?: number, include_fields?: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling searchPersons.');
            }
            const localVarPath = `/persons/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: number, body?: UpdatePersonRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePerson.');
            }
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePersonRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonsApi - functional programming interface
 * @export
 */
export const PersonsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {AddPersonRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPerson(body?: AddPersonRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddPersonResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).addPerson(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {number} id The ID of the person
         * @param {AddPersonFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonFollower(id: number, body?: AddPersonFollowerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddPersonFollowerResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).addPersonFollower(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {number} id The ID of the person
         * @param {Blob} [file] 
         * @param {number} [crop_x] 
         * @param {number} [crop_y] 
         * @param {number} [crop_width] 
         * @param {number} [crop_height] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonPicture(id: number, file?: Blob, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddPersonPictureResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).addPersonPicture(id, file, crop_x, crop_y, crop_width, crop_height, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a person as deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeletePersonResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).deletePerson(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {number} id The ID of the person
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonFollower(id: number, follower_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeletePersonResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).deletePersonFollower(id, follower_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a persons picture.
         * @summary Delete person picture
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonPicture(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeletePersonResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).deletePersonPicture(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple persons as deleted.
         * @summary Delete multiple persons in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersons(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeletePersonsResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).deletePersons(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPersonResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPerson(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedActivitiesResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonActivities(id, start, limit, done, exclude, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedDealsResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonDeals(id, start, limit, status, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedFilesResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonFiles(id, start, limit, include_deleted_files, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFollowers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedFollowersResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonFollowers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonMailMessages(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedMailMessagesResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonMailMessages(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonProducts(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPersonProductsResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonProducts(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint's response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedPersonUpdatesResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonUpdates(id, start, limit, all_changes, items, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonUsers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListPermittedUsersResponse2001> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersonUsers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPersonsResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).getPersons(user_id, filter_id, first_char, start, limit, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {number} id The ID of the person
         * @param {MergePersonsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergePersons(id: number, body?: MergePersonsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MergePersonsResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).mergePersons(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersons(term: string, fields?: string, exact_match?: boolean, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchPersonsResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).searchPersons(term, fields, exact_match, organization_id, include_fields, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: number, body?: UpdatePersonRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdatePersonResponse200> {
            const localVarFetchArgs = PersonsApiFetchParamCreator(configuration).updatePerson(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PersonsApi - factory interface
 * @export
 */
export const PersonsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Add a person
         * @param {AddPersonRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPerson(body?: AddPersonRequest, options?: any) {
            return PersonsApiFp(configuration).addPerson(body, options)(fetch, basePath);
        },
        /**
         * Adds a follower to a person.
         * @summary Add a follower to a person
         * @param {number} id The ID of the person
         * @param {AddPersonFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonFollower(id: number, body?: AddPersonFollowerRequest, options?: any) {
            return PersonsApiFp(configuration).addPersonFollower(id, body, options)(fetch, basePath);
        },
        /**
         * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
         * @summary Add person picture
         * @param {number} id The ID of the person
         * @param {Blob} [file] 
         * @param {number} [crop_x] 
         * @param {number} [crop_y] 
         * @param {number} [crop_width] 
         * @param {number} [crop_height] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPersonPicture(id: number, file?: Blob, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, options?: any) {
            return PersonsApiFp(configuration).addPersonPicture(id, file, crop_x, crop_y, crop_width, crop_height, options)(fetch, basePath);
        },
        /**
         * Marks a person as deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(id: number, options?: any) {
            return PersonsApiFp(configuration).deletePerson(id, options)(fetch, basePath);
        },
        /**
         * Deletes a follower from a person.
         * @summary Delete a follower from a person
         * @param {number} id The ID of the person
         * @param {number} follower_id The ID of the follower
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonFollower(id: number, follower_id: number, options?: any) {
            return PersonsApiFp(configuration).deletePersonFollower(id, follower_id, options)(fetch, basePath);
        },
        /**
         * Deletes a persons picture.
         * @summary Delete person picture
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonPicture(id: number, options?: any) {
            return PersonsApiFp(configuration).deletePersonPicture(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple persons as deleted.
         * @summary Delete multiple persons in bulk
         * @param {string} ids The comma-separated IDs that will be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersons(ids: string, options?: any) {
            return PersonsApiFp(configuration).deletePersons(ids, options)(fetch, basePath);
        },
        /**
         * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
         * @summary Get details of a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(id: number, options?: any) {
            return PersonsApiFp(configuration).getPerson(id, options)(fetch, basePath);
        },
        /**
         * Lists activities associated with a person.
         * @summary List activities associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
         * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any) {
            return PersonsApiFp(configuration).getPersonActivities(id, start, limit, done, exclude, options)(fetch, basePath);
        },
        /**
         * Lists deals associated with a person.
         * @summary List deals associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, options?: any) {
            return PersonsApiFp(configuration).getPersonDeals(id, start, limit, status, sort, options)(fetch, basePath);
        },
        /**
         * Lists files associated with a person.
         * @summary List files attached to a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
            return PersonsApiFp(configuration).getPersonFiles(id, start, limit, include_deleted_files, sort, options)(fetch, basePath);
        },
        /**
         * Lists the followers of a person.
         * @summary List followers of a person
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonFollowers(id: number, options?: any) {
            return PersonsApiFp(configuration).getPersonFollowers(id, options)(fetch, basePath);
        },
        /**
         * Lists mail messages associated with a person.
         * @summary List mail messages associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonMailMessages(id: number, start?: number, limit?: number, options?: any) {
            return PersonsApiFp(configuration).getPersonMailMessages(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists products associated with a person.
         * @summary List products associated with a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonProducts(id: number, start?: number, limit?: number, options?: any) {
            return PersonsApiFp(configuration).getPersonProducts(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint's response will also include updates for the `marketing_status` field.
         * @summary List updates about a person
         * @param {number} id The ID of the person
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
         * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any) {
            return PersonsApiFp(configuration).getPersonUpdates(id, start, limit, all_changes, items, options)(fetch, basePath);
        },
        /**
         * List users permitted to access a person.
         * @summary List permitted users
         * @param {number} id The ID of the person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonUsers(id: number, options?: any) {
            return PersonsApiFp(configuration).getPersonUsers(id, options)(fetch, basePath);
        },
        /**
         * Returns all persons.
         * @summary Get all persons
         * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
         * @param {number} [filter_id] The ID of the filter to use
         * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case insensitive)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any) {
            return PersonsApiFp(configuration).getPersons(user_id, filter_id, first_char, start, limit, sort, options)(fetch, basePath);
        },
        /**
         * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
         * @summary Merge two persons
         * @param {number} id The ID of the person
         * @param {MergePersonsRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergePersons(id: number, body?: MergePersonsRequest, options?: any) {
            return PersonsApiFp(configuration).mergePersons(id, body, options)(fetch, basePath);
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPersons(term: string, fields?: string, exact_match?: boolean, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any) {
            return PersonsApiFp(configuration).searchPersons(term, fields, exact_match, organization_id, include_fields, start, limit, options)(fetch, basePath);
        },
        /**
         * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(id: number, body?: UpdatePersonRequest, options?: any) {
            return PersonsApiFp(configuration).updatePerson(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * PersonsApi - interface
 * @export
 * @interface PersonsApi
 */
export interface PersonsApiInterface {
    /**
     * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Add a person
     * @param {AddPersonRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    addPerson(body?: AddPersonRequest, options?: any): Promise<AddPersonResponse200>;

    /**
     * Adds a follower to a person.
     * @summary Add a follower to a person
     * @param {number} id The ID of the person
     * @param {AddPersonFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    addPersonFollower(id: number, body?: AddPersonFollowerRequest, options?: any): Promise<AddPersonFollowerResponse200>;

    /**
     * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
     * @summary Add person picture
     * @param {number} id The ID of the person
     * @param {Blob} [file] 
     * @param {number} [crop_x] 
     * @param {number} [crop_y] 
     * @param {number} [crop_width] 
     * @param {number} [crop_height] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    addPersonPicture(id: number, file?: Blob, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, options?: any): Promise<AddPersonPictureResponse200>;

    /**
     * Marks a person as deleted.
     * @summary Delete a person
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    deletePerson(id: number, options?: any): Promise<DeletePersonResponse200>;

    /**
     * Deletes a follower from a person.
     * @summary Delete a follower from a person
     * @param {number} id The ID of the person
     * @param {number} follower_id The ID of the follower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    deletePersonFollower(id: number, follower_id: number, options?: any): Promise<DeletePersonResponse200>;

    /**
     * Deletes a persons picture.
     * @summary Delete person picture
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    deletePersonPicture(id: number, options?: any): Promise<DeletePersonResponse200>;

    /**
     * Marks multiple persons as deleted.
     * @summary Delete multiple persons in bulk
     * @param {string} ids The comma-separated IDs that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    deletePersons(ids: string, options?: any): Promise<DeletePersonsResponse200>;

    /**
     * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary Get details of a person
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPerson(id: number, options?: any): Promise<GetPersonResponse200>;

    /**
     * Lists activities associated with a person.
     * @summary List activities associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
     * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any): Promise<GetAssociatedActivitiesResponse200>;

    /**
     * Lists deals associated with a person.
     * @summary List deals associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, options?: any): Promise<GetAssociatedDealsResponse200>;

    /**
     * Lists files associated with a person.
     * @summary List files attached to a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): Promise<GetAssociatedFilesResponse200>;

    /**
     * Lists the followers of a person.
     * @summary List followers of a person
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonFollowers(id: number, options?: any): Promise<GetAssociatedFollowersResponse200>;

    /**
     * Lists mail messages associated with a person.
     * @summary List mail messages associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonMailMessages(id: number, start?: number, limit?: number, options?: any): Promise<GetAssociatedMailMessagesResponse200>;

    /**
     * Lists products associated with a person.
     * @summary List products associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonProducts(id: number, start?: number, limit?: number, options?: any): Promise<GetPersonProductsResponse200>;

    /**
     * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint's response will also include updates for the `marketing_status` field.
     * @summary List updates about a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
     * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any): Promise<GetAssociatedPersonUpdatesResponse200>;

    /**
     * List users permitted to access a person.
     * @summary List permitted users
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersonUsers(id: number, options?: any): Promise<ListPermittedUsersResponse2001>;

    /**
     * Returns all persons.
     * @summary Get all persons
     * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case insensitive)
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    getPersons(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any): Promise<GetPersonsResponse200>;

    /**
     * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
     * @summary Merge two persons
     * @param {number} id The ID of the person
     * @param {MergePersonsRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    mergePersons(id: number, body?: MergePersonsRequest, options?: any): Promise<MergePersonsResponse200>;

    /**
     * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     * @summary Search persons
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    searchPersons(term: string, fields?: string, exact_match?: boolean, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any): Promise<SearchPersonsResponse200>;

    /**
     * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Update a person
     * @param {number} id The ID of the person
     * @param {UpdatePersonRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApiInterface
     */
    updatePerson(id: number, body?: UpdatePersonRequest, options?: any): Promise<UpdatePersonResponse200>;

}

/**
 * PersonsApi - object-oriented interface
 * @export
 * @class PersonsApi
 * @extends {BaseAPI}
 */
export class PersonsApi extends BaseAPI implements PersonsApiInterface {
    /**
     * Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Add a person
     * @param {AddPersonRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPerson(body?: AddPersonRequest, options?: any) {
        return PersonsApiFp(this.configuration).addPerson(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a follower to a person.
     * @summary Add a follower to a person
     * @param {number} id The ID of the person
     * @param {AddPersonFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPersonFollower(id: number, body?: AddPersonFollowerRequest, options?: any) {
        return PersonsApiFp(this.configuration).addPersonFollower(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a picture to a person. If a picture is already set, the old picture will be replaced. Added image (or the cropping parameters supplied with the request) should have an equal width and height and should be at least 128 pixels. GIF, JPG and PNG are accepted. All added images will be resized to 128 and 512 pixel wide squares.
     * @summary Add person picture
     * @param {number} id The ID of the person
     * @param {Blob} [file] 
     * @param {number} [crop_x] 
     * @param {number} [crop_y] 
     * @param {number} [crop_width] 
     * @param {number} [crop_height] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public addPersonPicture(id: number, file?: Blob, crop_x?: number, crop_y?: number, crop_width?: number, crop_height?: number, options?: any) {
        return PersonsApiFp(this.configuration).addPersonPicture(id, file, crop_x, crop_y, crop_width, crop_height, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a person as deleted.
     * @summary Delete a person
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePerson(id: number, options?: any) {
        return PersonsApiFp(this.configuration).deletePerson(id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a follower from a person.
     * @summary Delete a follower from a person
     * @param {number} id The ID of the person
     * @param {number} follower_id The ID of the follower
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersonFollower(id: number, follower_id: number, options?: any) {
        return PersonsApiFp(this.configuration).deletePersonFollower(id, follower_id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a persons picture.
     * @summary Delete person picture
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersonPicture(id: number, options?: any) {
        return PersonsApiFp(this.configuration).deletePersonPicture(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple persons as deleted.
     * @summary Delete multiple persons in bulk
     * @param {string} ids The comma-separated IDs that will be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePersons(ids: string, options?: any) {
        return PersonsApiFp(this.configuration).deletePersons(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.
     * @summary Get details of a person
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPerson(id: number, options?: any) {
        return PersonsApiFp(this.configuration).getPerson(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists activities associated with a person.
     * @summary List activities associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [done] Whether the activity is done or not. 0 &#x3D; Not done, 1 &#x3D; Done. If omitted, returns both Done and Not done activities.
     * @param {string} [exclude] A comma-separated string of activity IDs to exclude from result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonActivities(id: number, start?: number, limit?: number, done?: number, exclude?: string, options?: any) {
        return PersonsApiFp(this.configuration).getPersonActivities(id, start, limit, done, exclude, options)(this.fetch, this.basePath);
    }

    /**
     * Lists deals associated with a person.
     * @summary List deals associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonDeals(id: number, start?: number, limit?: number, status?: string, sort?: string, options?: any) {
        return PersonsApiFp(this.configuration).getPersonDeals(id, start, limit, status, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Lists files associated with a person.
     * @summary List files attached to a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
        return PersonsApiFp(this.configuration).getPersonFiles(id, start, limit, include_deleted_files, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the followers of a person.
     * @summary List followers of a person
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonFollowers(id: number, options?: any) {
        return PersonsApiFp(this.configuration).getPersonFollowers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists mail messages associated with a person.
     * @summary List mail messages associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonMailMessages(id: number, start?: number, limit?: number, options?: any) {
        return PersonsApiFp(this.configuration).getPersonMailMessages(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists products associated with a person.
     * @summary List products associated with a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonProducts(id: number, start?: number, limit?: number, options?: any) {
        return PersonsApiFp(this.configuration).getPersonProducts(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint's response will also include updates for the `marketing_status` field.
     * @summary List updates about a person
     * @param {number} id The ID of the person
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [all_changes] Whether to show custom field updates or not. 1 &#x3D; Include custom field changes. If omitted returns changes without custom field updates.
     * @param {string} [items] A comma-separated string for filtering out item specific updates. (Possible values - call, activity, plannedActivity, change, note, deal, file, dealChange, personChange, organizationChange, follower, dealFollower, personFollower, organizationFollower, participant, comment, mailMessage, mailMessageWithAttachment, invoice, document, marketing_campaign_stat, marketing_status_change)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonUpdates(id: number, start?: number, limit?: number, all_changes?: string, items?: string, options?: any) {
        return PersonsApiFp(this.configuration).getPersonUpdates(id, start, limit, all_changes, items, options)(this.fetch, this.basePath);
    }

    /**
     * List users permitted to access a person.
     * @summary List permitted users
     * @param {number} id The ID of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersonUsers(id: number, options?: any) {
        return PersonsApiFp(this.configuration).getPersonUsers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all persons.
     * @summary Get all persons
     * @param {number} [user_id] If supplied, only persons owned by the given user will be returned. However, &#x60;filter_id&#x60; takes precedence over &#x60;user_id&#x60; when both are supplied.
     * @param {number} [filter_id] The ID of the filter to use
     * @param {string} [first_char] If supplied, only persons whose name starts with the specified letter will be returned (case insensitive)
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersons(user_id?: number, filter_id?: number, first_char?: string, start?: number, limit?: number, sort?: string, options?: any) {
        return PersonsApiFp(this.configuration).getPersons(user_id, filter_id, first_char, start, limit, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Merges a person with another person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/merging-two-persons\" target=\"_blank\" rel=\"noopener noreferrer\">merging two persons</a>.
     * @summary Merge two persons
     * @param {number} id The ID of the person
     * @param {MergePersonsRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public mergePersons(id: number, body?: MergePersonsRequest, options?: any) {
        return PersonsApiFp(this.configuration).mergePersons(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     * @summary Search persons
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public searchPersons(term: string, fields?: string, exact_match?: boolean, organization_id?: number, include_fields?: string, start?: number, limit?: number, options?: any) {
        return PersonsApiFp(this.configuration).searchPersons(term, fields, exact_match, organization_id, include_fields, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of a person. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/updating-a-person\" target=\"_blank\" rel=\"noopener noreferrer\">updating a person</a>.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.
     * @summary Update a person
     * @param {number} id The ID of the person
     * @param {UpdatePersonRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public updatePerson(id: number, body?: UpdatePersonRequest, options?: any) {
        return PersonsApiFp(this.configuration).updatePerson(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * PipelinesApi - fetch parameter creator
 * @export
 */
export const PipelinesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new pipeline.
         * @summary Add a new pipeline
         * @param {PipelineRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPipeline(body?: PipelineRequest, options: any = {}): FetchArgs {
            const localVarPath = `/pipelines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PipelineRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a pipeline as deleted.
         * @summary Delete a pipeline
         * @param {number} id The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePipeline.');
            }
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
         * @summary Get one pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(id: number, totals_convert_currency?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPipeline.');
            }
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (totals_convert_currency !== undefined) {
                localVarQueryParameter['totals_convert_currency'] = totals_convert_currency;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
         * @summary Get deals conversion rates in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who&#x27;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineConversionStatistics(id: number, start_date: string, end_date: string, user_id?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPipelineConversionStatistics.');
            }
            // verify required parameter 'start_date' is not null or undefined
            if (start_date === null || start_date === undefined) {
                throw new RequiredError('start_date','Required parameter start_date was null or undefined when calling getPipelineConversionStatistics.');
            }
            // verify required parameter 'end_date' is not null or undefined
            if (end_date === null || end_date === undefined) {
                throw new RequiredError('end_date','Required parameter end_date was null or undefined when calling getPipelineConversionStatistics.');
            }
            const localVarPath = `/pipelines/{id}/conversion_statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any).toISOString();
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any).toISOString();
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals in a specific pipeline across all its stages.
         * @summary Get deals in a pipeline
         * @param {number} id The ID of the pipeline
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [get_summary] Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, stage_id?: number, start?: number, limit?: number, get_summary?: number, totals_convert_currency?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPipelineDeals.');
            }
            const localVarPath = `/pipelines/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (everyone !== undefined) {
                localVarQueryParameter['everyone'] = everyone;
            }

            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (get_summary !== undefined) {
                localVarQueryParameter['get_summary'] = get_summary;
            }

            if (totals_convert_currency !== undefined) {
                localVarQueryParameter['totals_convert_currency'] = totals_convert_currency;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics for deals movements for the given time period.
         * @summary Get deals movements in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who&#x27;s pipeline statistics to fetch. If omitted, the authorized user will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineMovementStatistics(id: number, start_date: string, end_date: string, user_id?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPipelineMovementStatistics.');
            }
            // verify required parameter 'start_date' is not null or undefined
            if (start_date === null || start_date === undefined) {
                throw new RequiredError('start_date','Required parameter start_date was null or undefined when calling getPipelineMovementStatistics.');
            }
            // verify required parameter 'end_date' is not null or undefined
            if (end_date === null || end_date === undefined) {
                throw new RequiredError('end_date','Required parameter end_date was null or undefined when calling getPipelineMovementStatistics.');
            }
            const localVarPath = `/pipelines/{id}/movement_statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start_date !== undefined) {
                localVarQueryParameter['start_date'] = (start_date as any).toISOString();
            }

            if (end_date !== undefined) {
                localVarQueryParameter['end_date'] = (end_date as any).toISOString();
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all pipelines.
         * @summary Get all pipelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(options: any = {}): FetchArgs {
            const localVarPath = `/pipelines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a pipeline.
         * @summary Update a pipeline
         * @param {number} id The ID of the pipeline
         * @param {PipelineRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline(id: number, body?: PipelineRequest1, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePipeline.');
            }
            const localVarPath = `/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PipelineRequest1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new pipeline.
         * @summary Add a new pipeline
         * @param {PipelineRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPipeline(body?: PipelineRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddPipelineResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).addPipeline(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a pipeline as deleted.
         * @summary Delete a pipeline
         * @param {number} id The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeletePipelineResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).deletePipeline(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
         * @summary Get one pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(id: number, totals_convert_currency?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPipelineResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).getPipeline(id, totals_convert_currency, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
         * @summary Get deals conversion rates in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who&#x27;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineConversionStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPipelineConversionStatisticsResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).getPipelineConversionStatistics(id, start_date, end_date, user_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists deals in a specific pipeline across all its stages.
         * @summary Get deals in a pipeline
         * @param {number} id The ID of the pipeline
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [get_summary] Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, stage_id?: number, start?: number, limit?: number, get_summary?: number, totals_convert_currency?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStageDealsResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).getPipelineDeals(id, filter_id, user_id, everyone, stage_id, start, limit, get_summary, totals_convert_currency, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns statistics for deals movements for the given time period.
         * @summary Get deals movements in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who&#x27;s pipeline statistics to fetch. If omitted, the authorized user will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineMovementStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPipelineMovementStatisticsResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).getPipelineMovementStatistics(id, start_date, end_date, user_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all pipelines.
         * @summary Get all pipelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPipelinesResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).getPipelines(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of a pipeline.
         * @summary Update a pipeline
         * @param {number} id The ID of the pipeline
         * @param {PipelineRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline(id: number, body?: PipelineRequest1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdatePipelineResponse200> {
            const localVarFetchArgs = PipelinesApiFetchParamCreator(configuration).updatePipeline(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new pipeline.
         * @summary Add a new pipeline
         * @param {PipelineRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPipeline(body?: PipelineRequest, options?: any) {
            return PipelinesApiFp(configuration).addPipeline(body, options)(fetch, basePath);
        },
        /**
         * Marks a pipeline as deleted.
         * @summary Delete a pipeline
         * @param {number} id The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline(id: number, options?: any) {
            return PipelinesApiFp(configuration).deletePipeline(id, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
         * @summary Get one pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(id: number, totals_convert_currency?: string, options?: any) {
            return PipelinesApiFp(configuration).getPipeline(id, totals_convert_currency, options)(fetch, basePath);
        },
        /**
         * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
         * @summary Get deals conversion rates in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who&#x27;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineConversionStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any) {
            return PipelinesApiFp(configuration).getPipelineConversionStatistics(id, start_date, end_date, user_id, options)(fetch, basePath);
        },
        /**
         * Lists deals in a specific pipeline across all its stages.
         * @summary Get deals in a pipeline
         * @param {number} id The ID of the pipeline
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
         * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [get_summary] Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
         * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, stage_id?: number, start?: number, limit?: number, get_summary?: number, totals_convert_currency?: string, options?: any) {
            return PipelinesApiFp(configuration).getPipelineDeals(id, filter_id, user_id, everyone, stage_id, start, limit, get_summary, totals_convert_currency, options)(fetch, basePath);
        },
        /**
         * Returns statistics for deals movements for the given time period.
         * @summary Get deals movements in pipeline
         * @param {number} id The ID of the pipeline
         * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
         * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
         * @param {number} [user_id] The ID of the user who&#x27;s pipeline statistics to fetch. If omitted, the authorized user will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineMovementStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any) {
            return PipelinesApiFp(configuration).getPipelineMovementStatistics(id, start_date, end_date, user_id, options)(fetch, basePath);
        },
        /**
         * Returns data about all pipelines.
         * @summary Get all pipelines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(options?: any) {
            return PipelinesApiFp(configuration).getPipelines(options)(fetch, basePath);
        },
        /**
         * Updates the properties of a pipeline.
         * @summary Update a pipeline
         * @param {number} id The ID of the pipeline
         * @param {PipelineRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline(id: number, body?: PipelineRequest1, options?: any) {
            return PipelinesApiFp(configuration).updatePipeline(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * PipelinesApi - interface
 * @export
 * @interface PipelinesApi
 */
export interface PipelinesApiInterface {
    /**
     * Adds a new pipeline.
     * @summary Add a new pipeline
     * @param {PipelineRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    addPipeline(body?: PipelineRequest, options?: any): Promise<AddPipelineResponse200>;

    /**
     * Marks a pipeline as deleted.
     * @summary Delete a pipeline
     * @param {number} id The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    deletePipeline(id: number, options?: any): Promise<DeletePipelineResponse200>;

    /**
     * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
     * @summary Get one pipeline
     * @param {number} id The ID of the pipeline
     * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    getPipeline(id: number, totals_convert_currency?: string, options?: any): Promise<GetPipelineResponse200>;

    /**
     * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
     * @summary Get deals conversion rates in pipeline
     * @param {number} id The ID of the pipeline
     * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
     * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
     * @param {number} [user_id] The ID of the user who&#x27;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    getPipelineConversionStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any): Promise<GetPipelineConversionStatisticsResponse200>;

    /**
     * Lists deals in a specific pipeline across all its stages.
     * @summary Get deals in a pipeline
     * @param {number} id The ID of the pipeline
     * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
     * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
     * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
     * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [get_summary] Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
     * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    getPipelineDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, stage_id?: number, start?: number, limit?: number, get_summary?: number, totals_convert_currency?: string, options?: any): Promise<GetStageDealsResponse200>;

    /**
     * Returns statistics for deals movements for the given time period.
     * @summary Get deals movements in pipeline
     * @param {number} id The ID of the pipeline
     * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
     * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
     * @param {number} [user_id] The ID of the user who&#x27;s pipeline statistics to fetch. If omitted, the authorized user will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    getPipelineMovementStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any): Promise<GetPipelineMovementStatisticsResponse200>;

    /**
     * Returns data about all pipelines.
     * @summary Get all pipelines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    getPipelines(options?: any): Promise<GetPipelinesResponse200>;

    /**
     * Updates the properties of a pipeline.
     * @summary Update a pipeline
     * @param {number} id The ID of the pipeline
     * @param {PipelineRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApiInterface
     */
    updatePipeline(id: number, body?: PipelineRequest1, options?: any): Promise<UpdatePipelineResponse200>;

}

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI implements PipelinesApiInterface {
    /**
     * Adds a new pipeline.
     * @summary Add a new pipeline
     * @param {PipelineRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public addPipeline(body?: PipelineRequest, options?: any) {
        return PipelinesApiFp(this.configuration).addPipeline(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a pipeline as deleted.
     * @summary Delete a pipeline
     * @param {number} id The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public deletePipeline(id: number, options?: any) {
        return PipelinesApiFp(this.configuration).deletePipeline(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific pipeline. Also returns the summary of the deals in this pipeline across its stages.
     * @summary Get one pipeline
     * @param {number} id The ID of the pipeline
     * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned in &#x60;deals_summary&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipeline(id: number, totals_convert_currency?: string, options?: any) {
        return PipelinesApiFp(this.configuration).getPipeline(id, totals_convert_currency, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all stage-to-stage conversion and pipeline-to-close rates for the given time period.
     * @summary Get deals conversion rates in pipeline
     * @param {number} id The ID of the pipeline
     * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
     * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
     * @param {number} [user_id] The ID of the user who&#x27;s pipeline metrics statistics to fetch. If omitted, the authorized user will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineConversionStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any) {
        return PipelinesApiFp(this.configuration).getPipelineConversionStatistics(id, start_date, end_date, user_id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists deals in a specific pipeline across all its stages.
     * @summary Get deals in a pipeline
     * @param {number} id The ID of the pipeline
     * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
     * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
     * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
     * @param {number} [stage_id] If supplied, only deals within the given stage will be returned
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [get_summary] Whether to include a summary of the pipeline in the &#x60;additional_data&#x60; or not
     * @param {string} [totals_convert_currency] The 3-letter currency code of any of the supported currencies. When supplied, &#x60;per_stages_converted&#x60; is returned inside &#x60;deals_summary&#x60; inside &#x60;additional_data&#x60; which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to &#x60;default_currency&#x60; in which case users default currency is used. Only works when &#x60;get_summary&#x60; parameter flag is enabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, stage_id?: number, start?: number, limit?: number, get_summary?: number, totals_convert_currency?: string, options?: any) {
        return PipelinesApiFp(this.configuration).getPipelineDeals(id, filter_id, user_id, everyone, stage_id, start, limit, get_summary, totals_convert_currency, options)(this.fetch, this.basePath);
    }

    /**
     * Returns statistics for deals movements for the given time period.
     * @summary Get deals movements in pipeline
     * @param {number} id The ID of the pipeline
     * @param {string} start_date The start of the period. Date in format of YYYY-MM-DD.
     * @param {string} end_date The end of the period. Date in format of YYYY-MM-DD.
     * @param {number} [user_id] The ID of the user who&#x27;s pipeline statistics to fetch. If omitted, the authorized user will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineMovementStatistics(id: number, start_date: string, end_date: string, user_id?: number, options?: any) {
        return PipelinesApiFp(this.configuration).getPipelineMovementStatistics(id, start_date, end_date, user_id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all pipelines.
     * @summary Get all pipelines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelines(options?: any) {
        return PipelinesApiFp(this.configuration).getPipelines(options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of a pipeline.
     * @summary Update a pipeline
     * @param {number} id The ID of the pipeline
     * @param {PipelineRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public updatePipeline(id: number, body?: PipelineRequest1, options?: any) {
        return PipelinesApiFp(this.configuration).updatePipeline(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ProductFieldsApi - fetch parameter creator
 * @export
 */
export const ProductFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new product field
         * @param {ProductFieldsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductField(body?: ProductFieldsBody, options: any = {}): FetchArgs {
            const localVarPath = `/productFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductFieldsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a product field
         * @param {number} id The ID of the product field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProductField.');
            }
            const localVarPath = `/productFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple product fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFields(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteProductFields.');
            }
            const localVarPath = `/productFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific product field.
         * @summary Get one product field
         * @param {number} id The ID of the product field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductField(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductField.');
            }
            const localVarPath = `/productFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all product fields.
         * @summary Get all product fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFields(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/productFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a product field
         * @param {number} id The ID of the product field
         * @param {UpdateProductFieldResponse200} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductField(id: number, body?: UpdateProductFieldResponse200, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProductField.');
            }
            const localVarPath = `/productFields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateProductFieldResponse200" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductFieldsApi - functional programming interface
 * @export
 */
export const ProductFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new product field
         * @param {ProductFieldsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductField(body?: ProductFieldsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetProductFieldResponse200> {
            const localVarFetchArgs = ProductFieldsApiFetchParamCreator(configuration).addProductField(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a product field
         * @param {number} id The ID of the product field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteProductFieldResponse200> {
            const localVarFetchArgs = ProductFieldsApiFetchParamCreator(configuration).deleteProductField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple product fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFields(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteProductFieldsResponse200> {
            const localVarFetchArgs = ProductFieldsApiFetchParamCreator(configuration).deleteProductFields(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific product field.
         * @summary Get one product field
         * @param {number} id The ID of the product field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductField(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetProductFieldResponse200> {
            const localVarFetchArgs = ProductFieldsApiFetchParamCreator(configuration).getProductField(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all product fields.
         * @summary Get all product fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFields(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetProductFieldsResponse200> {
            const localVarFetchArgs = ProductFieldsApiFetchParamCreator(configuration).getProductFields(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a product field
         * @param {number} id The ID of the product field
         * @param {UpdateProductFieldResponse200} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductField(id: number, body?: UpdateProductFieldResponse200, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetProductFieldResponse200> {
            const localVarFetchArgs = ProductFieldsApiFetchParamCreator(configuration).updateProductField(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductFieldsApi - factory interface
 * @export
 */
export const ProductFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
         * @summary Add a new product field
         * @param {ProductFieldsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductField(body?: ProductFieldsBody, options?: any) {
            return ProductFieldsApiFp(configuration).addProductField(body, options)(fetch, basePath);
        },
        /**
         * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
         * @summary Delete a product field
         * @param {number} id The ID of the product field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductField(id: number, options?: any) {
            return ProductFieldsApiFp(configuration).deleteProductField(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple fields as deleted.
         * @summary Delete multiple product fields in bulk
         * @param {string} ids The comma-separated field IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFields(ids: string, options?: any) {
            return ProductFieldsApiFp(configuration).deleteProductFields(ids, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific product field.
         * @summary Get one product field
         * @param {number} id The ID of the product field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductField(id: number, options?: any) {
            return ProductFieldsApiFp(configuration).getProductField(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all product fields.
         * @summary Get all product fields
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFields(start?: number, limit?: number, options?: any) {
            return ProductFieldsApiFp(configuration).getProductFields(start, limit, options)(fetch, basePath);
        },
        /**
         * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
         * @summary Update a product field
         * @param {number} id The ID of the product field
         * @param {UpdateProductFieldResponse200} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductField(id: number, body?: UpdateProductFieldResponse200, options?: any) {
            return ProductFieldsApiFp(configuration).updateProductField(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProductFieldsApi - interface
 * @export
 * @interface ProductFieldsApi
 */
export interface ProductFieldsApiInterface {
    /**
     * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new product field
     * @param {ProductFieldsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApiInterface
     */
    addProductField(body?: ProductFieldsBody, options?: any): Promise<GetProductFieldResponse200>;

    /**
     * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a product field
     * @param {number} id The ID of the product field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApiInterface
     */
    deleteProductField(id: number, options?: any): Promise<DeleteProductFieldResponse200>;

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple product fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApiInterface
     */
    deleteProductFields(ids: string, options?: any): Promise<DeleteProductFieldsResponse200>;

    /**
     * Returns data about a specific product field.
     * @summary Get one product field
     * @param {number} id The ID of the product field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApiInterface
     */
    getProductField(id: number, options?: any): Promise<GetProductFieldResponse200>;

    /**
     * Returns data about all product fields.
     * @summary Get all product fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApiInterface
     */
    getProductFields(start?: number, limit?: number, options?: any): Promise<GetProductFieldsResponse200>;

    /**
     * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update a product field
     * @param {number} id The ID of the product field
     * @param {UpdateProductFieldResponse200} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApiInterface
     */
    updateProductField(id: number, body?: UpdateProductFieldResponse200, options?: any): Promise<GetProductFieldResponse200>;

}

/**
 * ProductFieldsApi - object-oriented interface
 * @export
 * @class ProductFieldsApi
 * @extends {BaseAPI}
 */
export class ProductFieldsApi extends BaseAPI implements ProductFieldsApiInterface {
    /**
     * Adds a new product field. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">adding a new custom field</a>.
     * @summary Add a new product field
     * @param {ProductFieldsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public addProductField(body?: ProductFieldsBody, options?: any) {
        return ProductFieldsApiFp(this.configuration).addProductField(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a product field as deleted. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/deleting-a-custom-field\" target=\"_blank\" rel=\"noopener noreferrer\">deleting a custom field</a>.
     * @summary Delete a product field
     * @param {number} id The ID of the product field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public deleteProductField(id: number, options?: any) {
        return ProductFieldsApiFp(this.configuration).deleteProductField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple fields as deleted.
     * @summary Delete multiple product fields in bulk
     * @param {string} ids The comma-separated field IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public deleteProductFields(ids: string, options?: any) {
        return ProductFieldsApiFp(this.configuration).deleteProductFields(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific product field.
     * @summary Get one product field
     * @param {number} id The ID of the product field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public getProductField(id: number, options?: any) {
        return ProductFieldsApiFp(this.configuration).getProductField(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all product fields.
     * @summary Get all product fields
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public getProductFields(start?: number, limit?: number, options?: any) {
        return ProductFieldsApiFp(this.configuration).getProductFields(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a product field. For more information, see the tutorial for <a href=\" https://pipedrive.readme.io/docs/updating-custom-field-value \" target=\"_blank\" rel=\"noopener noreferrer\">updating custom fields' values</a>.
     * @summary Update a product field
     * @param {number} id The ID of the product field
     * @param {UpdateProductFieldResponse200} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFieldsApi
     */
    public updateProductField(id: number, body?: UpdateProductFieldResponse200, options?: any) {
        return ProductFieldsApiFp(this.configuration).updateProductField(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ProductsApi - fetch parameter creator
 * @export
 */
export const ProductsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
         * @summary Add a product
         * @param {AddProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(body?: AddProductRequest, options: any = {}): FetchArgs {
            const localVarPath = `/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a follower to a product.
         * @summary Add a follower to a product
         * @param {number} id The ID of the product
         * @param {AddProductFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductFollower(id: number, body?: AddProductFollowerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addProductFollower.');
            }
            const localVarPath = `/products/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddProductFollowerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a product as deleted.
         * @summary Delete a product
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProduct.');
            }
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a follower from a product.
         * @summary Delete a follower from a product
         * @param {number} id The ID of the product
         * @param {number} follower_id The ID of the relationship between the follower and the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFollower(id: number, follower_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProductFollower.');
            }
            // verify required parameter 'follower_id' is not null or undefined
            if (follower_id === null || follower_id === undefined) {
                throw new RequiredError('follower_id','Required parameter follower_id was null or undefined when calling deleteProductFollower.');
            }
            const localVarPath = `/products/{id}/followers/{follower_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(follower_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific product.
         * @summary Get one product
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProduct.');
            }
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about deals that have a product attached to it.
         * @summary Get deals where a product is attached to
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDeals(id: number, start?: number, limit?: number, status?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductDeals.');
            }
            const localVarPath = `/products/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists files associated with a product.
         * @summary List files attached to a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductFiles.');
            }
            const localVarPath = `/products/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (include_deleted_files !== undefined) {
                localVarQueryParameter['include_deleted_files'] = include_deleted_files;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a product.
         * @summary List followers of a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFollowers(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductFollowers.');
            }
            const localVarPath = `/products/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists users permitted to access a product.
         * @summary List permitted users
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductUsers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProductUsers.');
            }
            const localVarPath = `/products/{id}/permittedUsers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all products.
         * @summary Get all products
         * @param {number} [user_id] If supplied, only products owned by the given user will be returned
         * @param {number} [filter_id] The ID of the filter to use
         * @param {Array<number>} [ids] An array of integers with the IDs of the products that should be returned in the response
         * @param {string} [first_char] If supplied, only products whose name starts with the specified letter will be returned (case insensitive)
         * @param {boolean} [get_summary] If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(user_id?: number, filter_id?: number, ids?: Array<number>, first_char?: string, get_summary?: boolean, start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (first_char !== undefined) {
                localVarQueryParameter['first_char'] = first_char;
            }

            if (get_summary !== undefined) {
                localVarQueryParameter['get_summary'] = get_summary;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search products
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProducts(term: string, fields?: string, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling searchProducts.');
            }
            const localVarPath = `/products/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }

            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates product data.
         * @summary Update a product
         * @param {number} id The ID of the product
         * @param {AddProductRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, body?: AddProductRequest1, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProduct.');
            }
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddProductRequest1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
         * @summary Add a product
         * @param {AddProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(body?: AddProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetproductResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).addProduct(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a follower to a product.
         * @summary Add a follower to a product
         * @param {number} id The ID of the product
         * @param {AddProductFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductFollower(id: number, body?: AddProductFollowerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NewFollowerResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).addProductFollower(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a product as deleted.
         * @summary Delete a product
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteProductResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).deleteProduct(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a follower from a product.
         * @summary Delete a follower from a product
         * @param {number} id The ID of the product
         * @param {number} follower_id The ID of the relationship between the follower and the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFollower(id: number, follower_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteProductFollowerResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).deleteProductFollower(id, follower_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific product.
         * @summary Get one product
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetproductResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getProduct(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about deals that have a product attached to it.
         * @summary Get deals where a product is attached to
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDeals(id: number, start?: number, limit?: number, status?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateDealRequest> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getProductDeals(id, start, limit, status, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists files associated with a product.
         * @summary List files attached to a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssociatedFilesResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getProductFiles(id, start, limit, include_deleted_files, sort, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the followers of a product.
         * @summary List followers of a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFollowers(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetProductFollowersResponseSuccess> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getProductFollowers(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists users permitted to access a product.
         * @summary List permitted users
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductUsers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserIds> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getProductUsers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all products.
         * @summary Get all products
         * @param {number} [user_id] If supplied, only products owned by the given user will be returned
         * @param {number} [filter_id] The ID of the filter to use
         * @param {Array<number>} [ids] An array of integers with the IDs of the products that should be returned in the response
         * @param {string} [first_char] If supplied, only products whose name starts with the specified letter will be returned (case insensitive)
         * @param {boolean} [get_summary] If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(user_id?: number, filter_id?: number, ids?: Array<number>, first_char?: string, get_summary?: boolean, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetProductsResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getProducts(user_id, filter_id, ids, first_char, get_summary, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search products
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProducts(term: string, fields?: string, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchProductsResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).searchProducts(term, fields, exact_match, include_fields, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates product data.
         * @summary Update a product
         * @param {number} id The ID of the product
         * @param {AddProductRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, body?: AddProductRequest1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateProductResponse200> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).updateProduct(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
         * @summary Add a product
         * @param {AddProductRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(body?: AddProductRequest, options?: any) {
            return ProductsApiFp(configuration).addProduct(body, options)(fetch, basePath);
        },
        /**
         * Adds a follower to a product.
         * @summary Add a follower to a product
         * @param {number} id The ID of the product
         * @param {AddProductFollowerRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductFollower(id: number, body?: AddProductFollowerRequest, options?: any) {
            return ProductsApiFp(configuration).addProductFollower(id, body, options)(fetch, basePath);
        },
        /**
         * Marks a product as deleted.
         * @summary Delete a product
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: number, options?: any) {
            return ProductsApiFp(configuration).deleteProduct(id, options)(fetch, basePath);
        },
        /**
         * Deletes a follower from a product.
         * @summary Delete a follower from a product
         * @param {number} id The ID of the product
         * @param {number} follower_id The ID of the relationship between the follower and the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFollower(id: number, follower_id: number, options?: any) {
            return ProductsApiFp(configuration).deleteProductFollower(id, follower_id, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific product.
         * @summary Get one product
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: number, options?: any) {
            return ProductsApiFp(configuration).getProduct(id, options)(fetch, basePath);
        },
        /**
         * Returns data about deals that have a product attached to it.
         * @summary Get deals where a product is attached to
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductDeals(id: number, start?: number, limit?: number, status?: string, options?: any) {
            return ProductsApiFp(configuration).getProductDeals(id, start, limit, status, options)(fetch, basePath);
        },
        /**
         * Lists files associated with a product.
         * @summary List files attached to a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
         * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
            return ProductsApiFp(configuration).getProductFiles(id, start, limit, include_deleted_files, sort, options)(fetch, basePath);
        },
        /**
         * Lists the followers of a product.
         * @summary List followers of a product
         * @param {number} id The ID of the product
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFollowers(id: number, start?: number, limit?: number, options?: any) {
            return ProductsApiFp(configuration).getProductFollowers(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists users permitted to access a product.
         * @summary List permitted users
         * @param {number} id The ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductUsers(id: number, options?: any) {
            return ProductsApiFp(configuration).getProductUsers(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all products.
         * @summary Get all products
         * @param {number} [user_id] If supplied, only products owned by the given user will be returned
         * @param {number} [filter_id] The ID of the filter to use
         * @param {Array<number>} [ids] An array of integers with the IDs of the products that should be returned in the response
         * @param {string} [first_char] If supplied, only products whose name starts with the specified letter will be returned (case insensitive)
         * @param {boolean} [get_summary] If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(user_id?: number, filter_id?: number, ids?: Array<number>, first_char?: string, get_summary?: boolean, start?: number, limit?: number, options?: any) {
            return ProductsApiFp(configuration).getProducts(user_id, filter_id, ids, first_char, get_summary, start, limit, options)(fetch, basePath);
        },
        /**
         * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search products
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
         * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProducts(term: string, fields?: string, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any) {
            return ProductsApiFp(configuration).searchProducts(term, fields, exact_match, include_fields, start, limit, options)(fetch, basePath);
        },
        /**
         * Updates product data.
         * @summary Update a product
         * @param {number} id The ID of the product
         * @param {AddProductRequest1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, body?: AddProductRequest1, options?: any) {
            return ProductsApiFp(configuration).updateProduct(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProductsApi - interface
 * @export
 * @interface ProductsApi
 */
export interface ProductsApiInterface {
    /**
     * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
     * @summary Add a product
     * @param {AddProductRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    addProduct(body?: AddProductRequest, options?: any): Promise<GetproductResponse200>;

    /**
     * Adds a follower to a product.
     * @summary Add a follower to a product
     * @param {number} id The ID of the product
     * @param {AddProductFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    addProductFollower(id: number, body?: AddProductFollowerRequest, options?: any): Promise<NewFollowerResponse200>;

    /**
     * Marks a product as deleted.
     * @summary Delete a product
     * @param {number} id The ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    deleteProduct(id: number, options?: any): Promise<DeleteProductResponse200>;

    /**
     * Deletes a follower from a product.
     * @summary Delete a follower from a product
     * @param {number} id The ID of the product
     * @param {number} follower_id The ID of the relationship between the follower and the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    deleteProductFollower(id: number, follower_id: number, options?: any): Promise<DeleteProductFollowerResponse200>;

    /**
     * Returns data about a specific product.
     * @summary Get one product
     * @param {number} id The ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    getProduct(id: number, options?: any): Promise<GetproductResponse200>;

    /**
     * Returns data about deals that have a product attached to it.
     * @summary Get deals where a product is attached to
     * @param {number} id The ID of the product
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    getProductDeals(id: number, start?: number, limit?: number, status?: string, options?: any): Promise<UpdateDealRequest>;

    /**
     * Lists files associated with a product.
     * @summary List files attached to a product
     * @param {number} id The ID of the product
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    getProductFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any): Promise<GetAssociatedFilesResponse200>;

    /**
     * Lists the followers of a product.
     * @summary List followers of a product
     * @param {number} id The ID of the product
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    getProductFollowers(id: number, start?: number, limit?: number, options?: any): Promise<GetProductFollowersResponseSuccess>;

    /**
     * Lists users permitted to access a product.
     * @summary List permitted users
     * @param {number} id The ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    getProductUsers(id: number, options?: any): Promise<UserIds>;

    /**
     * Returns data about all products.
     * @summary Get all products
     * @param {number} [user_id] If supplied, only products owned by the given user will be returned
     * @param {number} [filter_id] The ID of the filter to use
     * @param {Array<number>} [ids] An array of integers with the IDs of the products that should be returned in the response
     * @param {string} [first_char] If supplied, only products whose name starts with the specified letter will be returned (case insensitive)
     * @param {boolean} [get_summary] If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    getProducts(user_id?: number, filter_id?: number, ids?: Array<number>, first_char?: string, get_summary?: boolean, start?: number, limit?: number, options?: any): Promise<GetProductsResponse200>;

    /**
     * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search products
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    searchProducts(term: string, fields?: string, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any): Promise<SearchProductsResponse200>;

    /**
     * Updates product data.
     * @summary Update a product
     * @param {number} id The ID of the product
     * @param {AddProductRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApiInterface
     */
    updateProduct(id: number, body?: AddProductRequest1, options?: any): Promise<UpdateProductResponse200>;

}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI implements ProductsApiInterface {
    /**
     * Adds a new product to the Products inventory. For more information, see the tutorial for <a href=\"https://pipedrive.readme.io/docs/adding-a-product\" target=\"_blank\" rel=\"noopener noreferrer\">adding a product</a>.
     * @summary Add a product
     * @param {AddProductRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProduct(body?: AddProductRequest, options?: any) {
        return ProductsApiFp(this.configuration).addProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a follower to a product.
     * @summary Add a follower to a product
     * @param {number} id The ID of the product
     * @param {AddProductFollowerRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProductFollower(id: number, body?: AddProductFollowerRequest, options?: any) {
        return ProductsApiFp(this.configuration).addProductFollower(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a product as deleted.
     * @summary Delete a product
     * @param {number} id The ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(id: number, options?: any) {
        return ProductsApiFp(this.configuration).deleteProduct(id, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a follower from a product.
     * @summary Delete a follower from a product
     * @param {number} id The ID of the product
     * @param {number} follower_id The ID of the relationship between the follower and the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductFollower(id: number, follower_id: number, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductFollower(id, follower_id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific product.
     * @summary Get one product
     * @param {number} id The ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(id: number, options?: any) {
        return ProductsApiFp(this.configuration).getProduct(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about deals that have a product attached to it.
     * @summary Get deals where a product is attached to
     * @param {number} id The ID of the product
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {string} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductDeals(id: number, start?: number, limit?: number, status?: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductDeals(id, start, limit, status, options)(this.fetch, this.basePath);
    }

    /**
     * Lists files associated with a product.
     * @summary List files attached to a product
     * @param {number} id The ID of the product
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {number} [include_deleted_files] When enabled, the list of files will also include deleted files. Please note that trying to download these files will not work.
     * @param {string} [sort] The field names and sorting mode separated by a comma (&#x60;field_name_1 ASC&#x60;, &#x60;field_name_2 DESC&#x60;). Only first-level field keys are supported (no nested keys). Supported fields: &#x60;id&#x60;, &#x60;user_id&#x60;, &#x60;deal_id&#x60;, &#x60;person_id&#x60;, &#x60;org_id&#x60;, &#x60;product_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;, &#x60;file_name&#x60;, &#x60;file_type&#x60;, &#x60;file_size&#x60;, &#x60;comment&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductFiles(id: number, start?: number, limit?: number, include_deleted_files?: number, sort?: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductFiles(id, start, limit, include_deleted_files, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the followers of a product.
     * @summary List followers of a product
     * @param {number} id The ID of the product
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductFollowers(id: number, start?: number, limit?: number, options?: any) {
        return ProductsApiFp(this.configuration).getProductFollowers(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists users permitted to access a product.
     * @summary List permitted users
     * @param {number} id The ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductUsers(id: number, options?: any) {
        return ProductsApiFp(this.configuration).getProductUsers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all products.
     * @summary Get all products
     * @param {number} [user_id] If supplied, only products owned by the given user will be returned
     * @param {number} [filter_id] The ID of the filter to use
     * @param {Array<number>} [ids] An array of integers with the IDs of the products that should be returned in the response
     * @param {string} [first_char] If supplied, only products whose name starts with the specified letter will be returned (case insensitive)
     * @param {boolean} [get_summary] If supplied, the response will return the total numbers of products in the &#x60;additional_data.summary.total_count&#x60; property
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProducts(user_id?: number, filter_id?: number, ids?: Array<number>, first_char?: string, get_summary?: boolean, start?: number, limit?: number, options?: any) {
        return ProductsApiFp(this.configuration).getProducts(user_id, filter_id, ids, first_char, get_summary, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Searches all products by name, code and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search products
     * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;).
     * @param {string} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
     * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
     * @param {string} [include_fields] Supports including optional fields in the results which are not provided by default
     * @param {number} [start] Pagination start. Note that the pagination is based on main results and does not include related items when using &#x60;search_for_related_items&#x60; parameter.
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public searchProducts(term: string, fields?: string, exact_match?: boolean, include_fields?: string, start?: number, limit?: number, options?: any) {
        return ProductsApiFp(this.configuration).searchProducts(term, fields, exact_match, include_fields, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates product data.
     * @summary Update a product
     * @param {number} id The ID of the product
     * @param {AddProductRequest1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: number, body?: AddProductRequest1, options?: any) {
        return ProductsApiFp(this.configuration).updateProduct(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * RecentsApi - fetch parameter creator
 * @export
 */
export const RecentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about all recent changes occurred after the given timestamp.
         * @summary Get recents
         * @param {string} since_timestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
         * @param {string} [items] Multiple selection of item types to include in the query (optional)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecents(since_timestamp: string, items?: string, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'since_timestamp' is not null or undefined
            if (since_timestamp === null || since_timestamp === undefined) {
                throw new RequiredError('since_timestamp','Required parameter since_timestamp was null or undefined when calling getRecents.');
            }
            const localVarPath = `/recents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (since_timestamp !== undefined) {
                localVarQueryParameter['since_timestamp'] = since_timestamp;
            }

            if (items !== undefined) {
                localVarQueryParameter['items'] = items;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecentsApi - functional programming interface
 * @export
 */
export const RecentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns data about all recent changes occurred after the given timestamp.
         * @summary Get recents
         * @param {string} since_timestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
         * @param {string} [items] Multiple selection of item types to include in the query (optional)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecents(since_timestamp: string, items?: string, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetRecentsResponse200> {
            const localVarFetchArgs = RecentsApiFetchParamCreator(configuration).getRecents(since_timestamp, items, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RecentsApi - factory interface
 * @export
 */
export const RecentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns data about all recent changes occurred after the given timestamp.
         * @summary Get recents
         * @param {string} since_timestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
         * @param {string} [items] Multiple selection of item types to include in the query (optional)
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecents(since_timestamp: string, items?: string, start?: number, limit?: number, options?: any) {
            return RecentsApiFp(configuration).getRecents(since_timestamp, items, start, limit, options)(fetch, basePath);
        },
    };
};

/**
 * RecentsApi - interface
 * @export
 * @interface RecentsApi
 */
export interface RecentsApiInterface {
    /**
     * Returns data about all recent changes occurred after the given timestamp.
     * @summary Get recents
     * @param {string} since_timestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
     * @param {string} [items] Multiple selection of item types to include in the query (optional)
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentsApiInterface
     */
    getRecents(since_timestamp: string, items?: string, start?: number, limit?: number, options?: any): Promise<GetRecentsResponse200>;

}

/**
 * RecentsApi - object-oriented interface
 * @export
 * @class RecentsApi
 * @extends {BaseAPI}
 */
export class RecentsApi extends BaseAPI implements RecentsApiInterface {
    /**
     * Returns data about all recent changes occurred after the given timestamp.
     * @summary Get recents
     * @param {string} since_timestamp The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS
     * @param {string} [items] Multiple selection of item types to include in the query (optional)
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentsApi
     */
    public getRecents(since_timestamp: string, items?: string, start?: number, limit?: number, options?: any) {
        return RecentsApiFp(this.configuration).getRecents(since_timestamp, items, start, limit, options)(this.fetch, this.basePath);
    }

}
/**
 * RolesApi - fetch parameter creator
 * @export
 */
export const RolesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds or updates the visibility setting for a role.
         * @summary Add or update role setting
         * @param {number} id The ID of the role
         * @param {AddOrUpdateRoleSettingRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateRoleSetting(id: number, body?: AddOrUpdateRoleSettingRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addOrUpdateRoleSetting.');
            }
            const localVarPath = `/roles/{id}/settings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddOrUpdateRoleSettingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new role.
         * @summary Add a role
         * @param {AddRoleRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRole(body?: AddRoleRequest, options: any = {}): FetchArgs {
            const localVarPath = `/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddRoleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a user to a role.
         * @summary Add role assignment
         * @param {number} id The ID of the role
         * @param {AddRoleAssignmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleAssignment(id: number, body?: AddRoleAssignmentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addRoleAssignment.');
            }
            const localVarPath = `/roles/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddRoleAssignmentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a role as deleted.
         * @summary Delete a role
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRole.');
            }
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the assigned user from a role and adds to the default role.
         * @summary Delete a role assignment
         * @param {number} id The ID of the role
         * @param {DeleteRoleAssignmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleAssignment(id: number, body?: DeleteRoleAssignmentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRoleAssignment.');
            }
            const localVarPath = `/roles/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteRoleAssignmentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of a specific role.
         * @summary Get one role
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRole.');
            }
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all users assigned to a role.
         * @summary List role assignments
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignments(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoleAssignments.');
            }
            const localVarPath = `/roles/{id}/assignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the visibility settings of a specific role.
         * @summary List role settings
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleSettings(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoleSettings.');
            }
            const localVarPath = `/roles/{id}/settings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the direct children of a specific role.
         * @summary List role sub-roles
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleSubRoles(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoleSubRoles.');
            }
            const localVarPath = `/roles/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the roles within the company.
         * @summary Get all roles
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(start?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the parent role and/or the name of a specific role.
         * @summary Update role details
         * @param {number} id The ID of the role
         * @param {BaseRoleRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: number, body?: BaseRoleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRole.');
            }
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BaseRoleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds or updates the visibility setting for a role.
         * @summary Add or update role setting
         * @param {number} id The ID of the role
         * @param {AddOrUpdateRoleSettingRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateRoleSetting(id: number, body?: AddOrUpdateRoleSettingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddOrUpdateRoleSettingResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).addOrUpdateRoleSetting(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new role.
         * @summary Add a role
         * @param {AddRoleRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRole(body?: AddRoleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddRoleResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).addRole(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Assigns a user to a role.
         * @summary Add role assignment
         * @param {number} id The ID of the role
         * @param {AddRoleAssignmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleAssignment(id: number, body?: AddRoleAssignmentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddRoleAssignmentResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).addRoleAssignment(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a role as deleted.
         * @summary Delete a role
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteRoleResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).deleteRole(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes the assigned user from a role and adds to the default role.
         * @summary Delete a role assignment
         * @param {number} id The ID of the role
         * @param {DeleteRoleAssignmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleAssignment(id: number, body?: DeleteRoleAssignmentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteRoleAssignmentResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).deleteRoleAssignment(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the details of a specific role.
         * @summary Get one role
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetRoleResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).getRole(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all users assigned to a role.
         * @summary List role assignments
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignments(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserRoleAssignmentsResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).getRoleAssignments(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the visibility settings of a specific role.
         * @summary List role settings
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleSettings(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetRoleSettingsResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).getRoleSettings(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the direct children of a specific role.
         * @summary List role sub-roles
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleSubRoles(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetRoleSubrolesResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).getRoleSubRoles(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all the roles within the company.
         * @summary Get all roles
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetRolesResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).getRoles(start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the parent role and/or the name of a specific role.
         * @summary Update role details
         * @param {number} id The ID of the role
         * @param {BaseRoleRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: number, body?: BaseRoleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateRoleResponse200> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).updateRole(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds or updates the visibility setting for a role.
         * @summary Add or update role setting
         * @param {number} id The ID of the role
         * @param {AddOrUpdateRoleSettingRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateRoleSetting(id: number, body?: AddOrUpdateRoleSettingRequest, options?: any) {
            return RolesApiFp(configuration).addOrUpdateRoleSetting(id, body, options)(fetch, basePath);
        },
        /**
         * Adds a new role.
         * @summary Add a role
         * @param {AddRoleRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRole(body?: AddRoleRequest, options?: any) {
            return RolesApiFp(configuration).addRole(body, options)(fetch, basePath);
        },
        /**
         * Assigns a user to a role.
         * @summary Add role assignment
         * @param {number} id The ID of the role
         * @param {AddRoleAssignmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleAssignment(id: number, body?: AddRoleAssignmentRequest, options?: any) {
            return RolesApiFp(configuration).addRoleAssignment(id, body, options)(fetch, basePath);
        },
        /**
         * Marks a role as deleted.
         * @summary Delete a role
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: number, options?: any) {
            return RolesApiFp(configuration).deleteRole(id, options)(fetch, basePath);
        },
        /**
         * Removes the assigned user from a role and adds to the default role.
         * @summary Delete a role assignment
         * @param {number} id The ID of the role
         * @param {DeleteRoleAssignmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleAssignment(id: number, body?: DeleteRoleAssignmentRequest, options?: any) {
            return RolesApiFp(configuration).deleteRoleAssignment(id, body, options)(fetch, basePath);
        },
        /**
         * Returns the details of a specific role.
         * @summary Get one role
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: number, options?: any) {
            return RolesApiFp(configuration).getRole(id, options)(fetch, basePath);
        },
        /**
         * Returns all users assigned to a role.
         * @summary List role assignments
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignments(id: number, start?: number, limit?: number, options?: any) {
            return RolesApiFp(configuration).getRoleAssignments(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Returns the visibility settings of a specific role.
         * @summary List role settings
         * @param {number} id The ID of the role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleSettings(id: number, options?: any) {
            return RolesApiFp(configuration).getRoleSettings(id, options)(fetch, basePath);
        },
        /**
         * Returns the direct children of a specific role.
         * @summary List role sub-roles
         * @param {number} id The ID of the role
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleSubRoles(id: number, start?: number, limit?: number, options?: any) {
            return RolesApiFp(configuration).getRoleSubRoles(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Returns all the roles within the company.
         * @summary Get all roles
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(start?: number, limit?: number, options?: any) {
            return RolesApiFp(configuration).getRoles(start, limit, options)(fetch, basePath);
        },
        /**
         * Updates the parent role and/or the name of a specific role.
         * @summary Update role details
         * @param {number} id The ID of the role
         * @param {BaseRoleRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: number, body?: BaseRoleRequest, options?: any) {
            return RolesApiFp(configuration).updateRole(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * RolesApi - interface
 * @export
 * @interface RolesApi
 */
export interface RolesApiInterface {
    /**
     * Adds or updates the visibility setting for a role.
     * @summary Add or update role setting
     * @param {number} id The ID of the role
     * @param {AddOrUpdateRoleSettingRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    addOrUpdateRoleSetting(id: number, body?: AddOrUpdateRoleSettingRequest, options?: any): Promise<AddOrUpdateRoleSettingResponse200>;

    /**
     * Adds a new role.
     * @summary Add a role
     * @param {AddRoleRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    addRole(body?: AddRoleRequest, options?: any): Promise<AddRoleResponse200>;

    /**
     * Assigns a user to a role.
     * @summary Add role assignment
     * @param {number} id The ID of the role
     * @param {AddRoleAssignmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    addRoleAssignment(id: number, body?: AddRoleAssignmentRequest, options?: any): Promise<AddRoleAssignmentResponse200>;

    /**
     * Marks a role as deleted.
     * @summary Delete a role
     * @param {number} id The ID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    deleteRole(id: number, options?: any): Promise<DeleteRoleResponse200>;

    /**
     * Removes the assigned user from a role and adds to the default role.
     * @summary Delete a role assignment
     * @param {number} id The ID of the role
     * @param {DeleteRoleAssignmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    deleteRoleAssignment(id: number, body?: DeleteRoleAssignmentRequest, options?: any): Promise<DeleteRoleAssignmentResponse200>;

    /**
     * Returns the details of a specific role.
     * @summary Get one role
     * @param {number} id The ID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    getRole(id: number, options?: any): Promise<GetRoleResponse200>;

    /**
     * Returns all users assigned to a role.
     * @summary List role assignments
     * @param {number} id The ID of the role
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    getRoleAssignments(id: number, start?: number, limit?: number, options?: any): Promise<GetUserRoleAssignmentsResponse200>;

    /**
     * Returns the visibility settings of a specific role.
     * @summary List role settings
     * @param {number} id The ID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    getRoleSettings(id: number, options?: any): Promise<GetRoleSettingsResponse200>;

    /**
     * Returns the direct children of a specific role.
     * @summary List role sub-roles
     * @param {number} id The ID of the role
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    getRoleSubRoles(id: number, start?: number, limit?: number, options?: any): Promise<GetRoleSubrolesResponse200>;

    /**
     * Returns all the roles within the company.
     * @summary Get all roles
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    getRoles(start?: number, limit?: number, options?: any): Promise<GetRolesResponse200>;

    /**
     * Updates the parent role and/or the name of a specific role.
     * @summary Update role details
     * @param {number} id The ID of the role
     * @param {BaseRoleRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApiInterface
     */
    updateRole(id: number, body?: BaseRoleRequest, options?: any): Promise<UpdateRoleResponse200>;

}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI implements RolesApiInterface {
    /**
     * Adds or updates the visibility setting for a role.
     * @summary Add or update role setting
     * @param {number} id The ID of the role
     * @param {AddOrUpdateRoleSettingRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addOrUpdateRoleSetting(id: number, body?: AddOrUpdateRoleSettingRequest, options?: any) {
        return RolesApiFp(this.configuration).addOrUpdateRoleSetting(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a new role.
     * @summary Add a role
     * @param {AddRoleRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addRole(body?: AddRoleRequest, options?: any) {
        return RolesApiFp(this.configuration).addRole(body, options)(this.fetch, this.basePath);
    }

    /**
     * Assigns a user to a role.
     * @summary Add role assignment
     * @param {number} id The ID of the role
     * @param {AddRoleAssignmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addRoleAssignment(id: number, body?: AddRoleAssignmentRequest, options?: any) {
        return RolesApiFp(this.configuration).addRoleAssignment(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a role as deleted.
     * @summary Delete a role
     * @param {number} id The ID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(id: number, options?: any) {
        return RolesApiFp(this.configuration).deleteRole(id, options)(this.fetch, this.basePath);
    }

    /**
     * Removes the assigned user from a role and adds to the default role.
     * @summary Delete a role assignment
     * @param {number} id The ID of the role
     * @param {DeleteRoleAssignmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoleAssignment(id: number, body?: DeleteRoleAssignmentRequest, options?: any) {
        return RolesApiFp(this.configuration).deleteRoleAssignment(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the details of a specific role.
     * @summary Get one role
     * @param {number} id The ID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(id: number, options?: any) {
        return RolesApiFp(this.configuration).getRole(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all users assigned to a role.
     * @summary List role assignments
     * @param {number} id The ID of the role
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleAssignments(id: number, start?: number, limit?: number, options?: any) {
        return RolesApiFp(this.configuration).getRoleAssignments(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the visibility settings of a specific role.
     * @summary List role settings
     * @param {number} id The ID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleSettings(id: number, options?: any) {
        return RolesApiFp(this.configuration).getRoleSettings(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the direct children of a specific role.
     * @summary List role sub-roles
     * @param {number} id The ID of the role
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleSubRoles(id: number, start?: number, limit?: number, options?: any) {
        return RolesApiFp(this.configuration).getRoleSubRoles(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all the roles within the company.
     * @summary Get all roles
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoles(start?: number, limit?: number, options?: any) {
        return RolesApiFp(this.configuration).getRoles(start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the parent role and/or the name of a specific role.
     * @summary Update role details
     * @param {number} id The ID of the role
     * @param {BaseRoleRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRole(id: number, body?: BaseRoleRequest, options?: any) {
        return RolesApiFp(this.configuration).updateRole(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * StagesApi - fetch parameter creator
 * @export
 */
export const StagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new stage, returns the ID upon success.
         * @summary Add a new stage
         * @param {AddStageRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStage(body?: AddStageRequest, options: any = {}): FetchArgs {
            const localVarPath = `/stages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddStageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks a stage as deleted.
         * @summary Delete a stage
         * @param {number} id The ID of the stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStage(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteStage.');
            }
            const localVarPath = `/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks multiple stages as deleted.
         * @summary Delete multiple stages in bulk
         * @param {string} ids The comma-separated stage IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStages(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteStages.');
            }
            const localVarPath = `/stages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific stage.
         * @summary Get one stage
         * @param {number} id The ID of the stage
         * @param {number} [everyone] If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStage(id: number, everyone?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStage.');
            }
            const localVarPath = `/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (everyone !== undefined) {
                localVarQueryParameter['everyone'] = everyone;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists deals in a specific stage.
         * @summary Get deals in a stage
         * @param {number} id The ID of the stage
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStageDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStageDeals.');
            }
            const localVarPath = `/stages/{id}/deals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (everyone !== undefined) {
                localVarQueryParameter['everyone'] = everyone;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all stages.
         * @summary Get all stages
         * @param {number} [pipeline_id] The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStages(pipeline_id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/stages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pipeline_id !== undefined) {
                localVarQueryParameter['pipeline_id'] = pipeline_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a stage.
         * @summary Update stage details
         * @param {number} id The ID of the stage
         * @param {UpdateStageRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStage(id: number, body?: UpdateStageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateStage.');
            }
            const localVarPath = `/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateStageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StagesApi - functional programming interface
 * @export
 */
export const StagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new stage, returns the ID upon success.
         * @summary Add a new stage
         * @param {AddStageRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStage(body?: AddStageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StageResponse200> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).addStage(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks a stage as deleted.
         * @summary Delete a stage
         * @param {number} id The ID of the stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStage(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteStageResponse200> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).deleteStage(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks multiple stages as deleted.
         * @summary Delete multiple stages in bulk
         * @param {string} ids The comma-separated stage IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStages(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteStagesResponse200> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).deleteStages(ids, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific stage.
         * @summary Get one stage
         * @param {number} id The ID of the stage
         * @param {number} [everyone] If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStage(id: number, everyone?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStageResponse200> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).getStage(id, everyone, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists deals in a specific stage.
         * @summary Get deals in a stage
         * @param {number} id The ID of the stage
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStageDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStageDealsResponse200> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).getStageDeals(id, filter_id, user_id, everyone, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all stages.
         * @summary Get all stages
         * @param {number} [pipeline_id] The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStages(pipeline_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStagesResponse200> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).getStages(pipeline_id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of a stage.
         * @summary Update stage details
         * @param {number} id The ID of the stage
         * @param {UpdateStageRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStage(id: number, body?: UpdateStageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StageResponse200> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).updateStage(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StagesApi - factory interface
 * @export
 */
export const StagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new stage, returns the ID upon success.
         * @summary Add a new stage
         * @param {AddStageRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStage(body?: AddStageRequest, options?: any) {
            return StagesApiFp(configuration).addStage(body, options)(fetch, basePath);
        },
        /**
         * Marks a stage as deleted.
         * @summary Delete a stage
         * @param {number} id The ID of the stage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStage(id: number, options?: any) {
            return StagesApiFp(configuration).deleteStage(id, options)(fetch, basePath);
        },
        /**
         * Marks multiple stages as deleted.
         * @summary Delete multiple stages in bulk
         * @param {string} ids The comma-separated stage IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStages(ids: string, options?: any) {
            return StagesApiFp(configuration).deleteStages(ids, options)(fetch, basePath);
        },
        /**
         * Returns data about a specific stage.
         * @summary Get one stage
         * @param {number} id The ID of the stage
         * @param {number} [everyone] If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStage(id: number, everyone?: number, options?: any) {
            return StagesApiFp(configuration).getStage(id, everyone, options)(fetch, basePath);
        },
        /**
         * Lists deals in a specific stage.
         * @summary Get deals in a stage
         * @param {number} id The ID of the stage
         * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
         * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
         * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStageDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, start?: number, limit?: number, options?: any) {
            return StagesApiFp(configuration).getStageDeals(id, filter_id, user_id, everyone, start, limit, options)(fetch, basePath);
        },
        /**
         * Returns data about all stages.
         * @summary Get all stages
         * @param {number} [pipeline_id] The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStages(pipeline_id?: number, options?: any) {
            return StagesApiFp(configuration).getStages(pipeline_id, options)(fetch, basePath);
        },
        /**
         * Updates the properties of a stage.
         * @summary Update stage details
         * @param {number} id The ID of the stage
         * @param {UpdateStageRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStage(id: number, body?: UpdateStageRequest, options?: any) {
            return StagesApiFp(configuration).updateStage(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * StagesApi - interface
 * @export
 * @interface StagesApi
 */
export interface StagesApiInterface {
    /**
     * Adds a new stage, returns the ID upon success.
     * @summary Add a new stage
     * @param {AddStageRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApiInterface
     */
    addStage(body?: AddStageRequest, options?: any): Promise<StageResponse200>;

    /**
     * Marks a stage as deleted.
     * @summary Delete a stage
     * @param {number} id The ID of the stage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApiInterface
     */
    deleteStage(id: number, options?: any): Promise<DeleteStageResponse200>;

    /**
     * Marks multiple stages as deleted.
     * @summary Delete multiple stages in bulk
     * @param {string} ids The comma-separated stage IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApiInterface
     */
    deleteStages(ids: string, options?: any): Promise<DeleteStagesResponse200>;

    /**
     * Returns data about a specific stage.
     * @summary Get one stage
     * @param {number} id The ID of the stage
     * @param {number} [everyone] If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApiInterface
     */
    getStage(id: number, everyone?: number, options?: any): Promise<GetStageResponse200>;

    /**
     * Lists deals in a specific stage.
     * @summary Get deals in a stage
     * @param {number} id The ID of the stage
     * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
     * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
     * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApiInterface
     */
    getStageDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, start?: number, limit?: number, options?: any): Promise<GetStageDealsResponse200>;

    /**
     * Returns data about all stages.
     * @summary Get all stages
     * @param {number} [pipeline_id] The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApiInterface
     */
    getStages(pipeline_id?: number, options?: any): Promise<GetStagesResponse200>;

    /**
     * Updates the properties of a stage.
     * @summary Update stage details
     * @param {number} id The ID of the stage
     * @param {UpdateStageRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApiInterface
     */
    updateStage(id: number, body?: UpdateStageRequest, options?: any): Promise<StageResponse200>;

}

/**
 * StagesApi - object-oriented interface
 * @export
 * @class StagesApi
 * @extends {BaseAPI}
 */
export class StagesApi extends BaseAPI implements StagesApiInterface {
    /**
     * Adds a new stage, returns the ID upon success.
     * @summary Add a new stage
     * @param {AddStageRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public addStage(body?: AddStageRequest, options?: any) {
        return StagesApiFp(this.configuration).addStage(body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks a stage as deleted.
     * @summary Delete a stage
     * @param {number} id The ID of the stage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public deleteStage(id: number, options?: any) {
        return StagesApiFp(this.configuration).deleteStage(id, options)(this.fetch, this.basePath);
    }

    /**
     * Marks multiple stages as deleted.
     * @summary Delete multiple stages in bulk
     * @param {string} ids The comma-separated stage IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public deleteStages(ids: string, options?: any) {
        return StagesApiFp(this.configuration).deleteStages(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific stage.
     * @summary Get one stage
     * @param {number} id The ID of the stage
     * @param {number} [everyone] If &#x60;everyone&#x3D;1&#x60; is provided, deals summary will return deals owned by every user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public getStage(id: number, everyone?: number, options?: any) {
        return StagesApiFp(this.configuration).getStage(id, everyone, options)(this.fetch, this.basePath);
    }

    /**
     * Lists deals in a specific stage.
     * @summary Get deals in a stage
     * @param {number} id The ID of the stage
     * @param {number} [filter_id] If supplied, only deals matching the given filter will be returned
     * @param {number} [user_id] If supplied, &#x60;filter_id&#x60; will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned.
     * @param {number} [everyone] If supplied, &#x60;filter_id&#x60; and &#x60;user_id&#x60; will not be considered  instead, deals owned by everyone will be returned
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public getStageDeals(id: number, filter_id?: number, user_id?: number, everyone?: number, start?: number, limit?: number, options?: any) {
        return StagesApiFp(this.configuration).getStageDeals(id, filter_id, user_id, everyone, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all stages.
     * @summary Get all stages
     * @param {number} [pipeline_id] The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public getStages(pipeline_id?: number, options?: any) {
        return StagesApiFp(this.configuration).getStages(pipeline_id, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of a stage.
     * @summary Update stage details
     * @param {number} id The ID of the stage
     * @param {UpdateStageRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public updateStage(id: number, body?: UpdateStageRequest, options?: any) {
        return StagesApiFp(this.configuration).updateStage(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * SubscriptionsApi - fetch parameter creator
 * @export
 */
export const SubscriptionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {AddRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRecurringSubscription(body?: AddRecurringSubscriptionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/subscriptions/recurring`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddRecurringSubscriptionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {AddSubscriptionInstallmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionInstallment(body?: AddSubscriptionInstallmentRequest, options: any = {}): FetchArgs {
            const localVarPath = `/subscriptions/installment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddSubscriptionInstallmentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {CancelRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRecurringSubscription(id: number, body?: CancelRecurringSubscriptionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancelRecurringSubscription.');
            }
            const localVarPath = `/subscriptions/recurring/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CancelRecurringSubscriptionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSubscription.');
            }
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {number} dealId The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubscriptionByDeal(dealId: number, options: any = {}): FetchArgs {
            // verify required parameter 'dealId' is not null or undefined
            if (dealId === null || dealId === undefined) {
                throw new RequiredError('dealId','Required parameter dealId was null or undefined when calling findSubscriptionByDeal.');
            }
            const localVarPath = `/subscriptions/find/{dealId}`
                .replace(`{${"dealId"}}`, encodeURIComponent(String(dealId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSubscription.');
            }
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPayments(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSubscriptionPayments.');
            }
            const localVarPath = `/subscriptions/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurringSubscription(id: number, body?: UpdateRecurringSubscriptionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRecurringSubscription.');
            }
            const localVarPath = `/subscriptions/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateRecurringSubscriptionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateSubscriptionInstallmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionInstallment(id: number, body?: UpdateSubscriptionInstallmentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSubscriptionInstallment.');
            }
            const localVarPath = `/subscriptions/installment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSubscriptionInstallmentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {AddRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRecurringSubscription(body?: AddRecurringSubscriptionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).addRecurringSubscription(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {AddSubscriptionInstallmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionInstallment(body?: AddSubscriptionInstallmentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).addSubscriptionInstallment(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {CancelRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRecurringSubscription(id: number, body?: CancelRecurringSubscriptionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).cancelRecurringSubscription(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).deleteSubscription(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {number} dealId The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubscriptionByDeal(dealId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).findSubscriptionByDeal(dealId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getSubscription(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPayments(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getSubscriptionPayments(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurringSubscription(id: number, body?: UpdateRecurringSubscriptionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).updateRecurringSubscription(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateSubscriptionInstallmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionInstallment(id: number, body?: UpdateSubscriptionInstallmentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionsIdResponse200> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).updateSubscriptionInstallment(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new recurring subscription.
         * @summary Add a recurring subscription
         * @param {AddRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRecurringSubscription(body?: AddRecurringSubscriptionRequest, options?: any) {
            return SubscriptionsApiFp(configuration).addRecurringSubscription(body, options)(fetch, basePath);
        },
        /**
         * Adds a new installment subscription.
         * @summary Add an installment subscription
         * @param {AddSubscriptionInstallmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionInstallment(body?: AddSubscriptionInstallmentRequest, options?: any) {
            return SubscriptionsApiFp(configuration).addSubscriptionInstallment(body, options)(fetch, basePath);
        },
        /**
         * Cancels a recurring subscription.
         * @summary Cancel a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {CancelRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRecurringSubscription(id: number, body?: CancelRecurringSubscriptionRequest, options?: any) {
            return SubscriptionsApiFp(configuration).cancelRecurringSubscription(id, body, options)(fetch, basePath);
        },
        /**
         * Marks an installment or a recurring subscription as deleted.
         * @summary Delete a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(id: number, options?: any) {
            return SubscriptionsApiFp(configuration).deleteSubscription(id, options)(fetch, basePath);
        },
        /**
         * Returns details of an installment or a recurring subscription by the deal ID.
         * @summary Find subscription by deal
         * @param {number} dealId The ID of the deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubscriptionByDeal(dealId: number, options?: any) {
            return SubscriptionsApiFp(configuration).findSubscriptionByDeal(dealId, options)(fetch, basePath);
        },
        /**
         * Returns details of an installment or a recurring subscription.
         * @summary Get details of a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(id: number, options?: any) {
            return SubscriptionsApiFp(configuration).getSubscription(id, options)(fetch, basePath);
        },
        /**
         * Returns all payments of an installment or recurring subscription.
         * @summary Get all payments of a subscription
         * @param {number} id The ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPayments(id: number, options?: any) {
            return SubscriptionsApiFp(configuration).getSubscriptionPayments(id, options)(fetch, basePath);
        },
        /**
         * Updates a recurring subscription.
         * @summary Update a recurring subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateRecurringSubscriptionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurringSubscription(id: number, body?: UpdateRecurringSubscriptionRequest, options?: any) {
            return SubscriptionsApiFp(configuration).updateRecurringSubscription(id, body, options)(fetch, basePath);
        },
        /**
         * Updates an installment subscription.
         * @summary Update an installment subscription
         * @param {number} id The ID of the subscription
         * @param {UpdateSubscriptionInstallmentRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionInstallment(id: number, body?: UpdateSubscriptionInstallmentRequest, options?: any) {
            return SubscriptionsApiFp(configuration).updateSubscriptionInstallment(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionsApi - interface
 * @export
 * @interface SubscriptionsApi
 */
export interface SubscriptionsApiInterface {
    /**
     * Adds a new recurring subscription.
     * @summary Add a recurring subscription
     * @param {AddRecurringSubscriptionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    addRecurringSubscription(body?: AddRecurringSubscriptionRequest, options?: any): Promise<SubscriptionsIdResponse200>;

    /**
     * Adds a new installment subscription.
     * @summary Add an installment subscription
     * @param {AddSubscriptionInstallmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    addSubscriptionInstallment(body?: AddSubscriptionInstallmentRequest, options?: any): Promise<SubscriptionsIdResponse200>;

    /**
     * Cancels a recurring subscription.
     * @summary Cancel a recurring subscription
     * @param {number} id The ID of the subscription
     * @param {CancelRecurringSubscriptionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    cancelRecurringSubscription(id: number, body?: CancelRecurringSubscriptionRequest, options?: any): Promise<SubscriptionsIdResponse200>;

    /**
     * Marks an installment or a recurring subscription as deleted.
     * @summary Delete a subscription
     * @param {number} id The ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    deleteSubscription(id: number, options?: any): Promise<SubscriptionsIdResponse200>;

    /**
     * Returns details of an installment or a recurring subscription by the deal ID.
     * @summary Find subscription by deal
     * @param {number} dealId The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    findSubscriptionByDeal(dealId: number, options?: any): Promise<SubscriptionsIdResponse200>;

    /**
     * Returns details of an installment or a recurring subscription.
     * @summary Get details of a subscription
     * @param {number} id The ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    getSubscription(id: number, options?: any): Promise<SubscriptionsIdResponse200>;

    /**
     * Returns all payments of an installment or recurring subscription.
     * @summary Get all payments of a subscription
     * @param {number} id The ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    getSubscriptionPayments(id: number, options?: any): Promise<PaymentResponse200>;

    /**
     * Updates a recurring subscription.
     * @summary Update a recurring subscription
     * @param {number} id The ID of the subscription
     * @param {UpdateRecurringSubscriptionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    updateRecurringSubscription(id: number, body?: UpdateRecurringSubscriptionRequest, options?: any): Promise<SubscriptionsIdResponse200>;

    /**
     * Updates an installment subscription.
     * @summary Update an installment subscription
     * @param {number} id The ID of the subscription
     * @param {UpdateSubscriptionInstallmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    updateSubscriptionInstallment(id: number, body?: UpdateSubscriptionInstallmentRequest, options?: any): Promise<SubscriptionsIdResponse200>;

}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI implements SubscriptionsApiInterface {
    /**
     * Adds a new recurring subscription.
     * @summary Add a recurring subscription
     * @param {AddRecurringSubscriptionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public addRecurringSubscription(body?: AddRecurringSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).addRecurringSubscription(body, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a new installment subscription.
     * @summary Add an installment subscription
     * @param {AddSubscriptionInstallmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public addSubscriptionInstallment(body?: AddSubscriptionInstallmentRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).addSubscriptionInstallment(body, options)(this.fetch, this.basePath);
    }

    /**
     * Cancels a recurring subscription.
     * @summary Cancel a recurring subscription
     * @param {number} id The ID of the subscription
     * @param {CancelRecurringSubscriptionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public cancelRecurringSubscription(id: number, body?: CancelRecurringSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).cancelRecurringSubscription(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Marks an installment or a recurring subscription as deleted.
     * @summary Delete a subscription
     * @param {number} id The ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public deleteSubscription(id: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).deleteSubscription(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of an installment or a recurring subscription by the deal ID.
     * @summary Find subscription by deal
     * @param {number} dealId The ID of the deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public findSubscriptionByDeal(dealId: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).findSubscriptionByDeal(dealId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns details of an installment or a recurring subscription.
     * @summary Get details of a subscription
     * @param {number} id The ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscription(id: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).getSubscription(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all payments of an installment or recurring subscription.
     * @summary Get all payments of a subscription
     * @param {number} id The ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionPayments(id: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionPayments(id, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a recurring subscription.
     * @summary Update a recurring subscription
     * @param {number} id The ID of the subscription
     * @param {UpdateRecurringSubscriptionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateRecurringSubscription(id: number, body?: UpdateRecurringSubscriptionRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).updateRecurringSubscription(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates an installment subscription.
     * @summary Update an installment subscription
     * @param {number} id The ID of the subscription
     * @param {UpdateSubscriptionInstallmentRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscriptionInstallment(id: number, body?: UpdateSubscriptionInstallmentRequest, options?: any) {
        return SubscriptionsApiFp(this.configuration).updateSubscriptionInstallment(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * UserConnectionsApi - fetch parameter creator
 * @export
 */
export const UserConnectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data about all connections for the authorized user.
         * @summary Get all user connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections(options: any = {}): FetchArgs {
            const localVarPath = `/userConnections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserConnectionsApi - functional programming interface
 * @export
 */
export const UserConnectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns data about all connections for the authorized user.
         * @summary Get all user connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserConnectionsResponse200> {
            const localVarFetchArgs = UserConnectionsApiFetchParamCreator(configuration).getUserConnections(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserConnectionsApi - factory interface
 * @export
 */
export const UserConnectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns data about all connections for the authorized user.
         * @summary Get all user connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections(options?: any) {
            return UserConnectionsApiFp(configuration).getUserConnections(options)(fetch, basePath);
        },
    };
};

/**
 * UserConnectionsApi - interface
 * @export
 * @interface UserConnectionsApi
 */
export interface UserConnectionsApiInterface {
    /**
     * Returns data about all connections for the authorized user.
     * @summary Get all user connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionsApiInterface
     */
    getUserConnections(options?: any): Promise<UserConnectionsResponse200>;

}

/**
 * UserConnectionsApi - object-oriented interface
 * @export
 * @class UserConnectionsApi
 * @extends {BaseAPI}
 */
export class UserConnectionsApi extends BaseAPI implements UserConnectionsApiInterface {
    /**
     * Returns data about all connections for the authorized user.
     * @summary Get all user connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionsApi
     */
    public getUserConnections(options?: any) {
        return UserConnectionsApiFp(this.configuration).getUserConnections(options)(this.fetch, this.basePath);
    }

}
/**
 * UserSettingsApi - fetch parameter creator
 * @export
 */
export const UserSettingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists the settings of an authorized user. Example response contains a shortened list of settings.
         * @summary List settings of an authorized user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options: any = {}): FetchArgs {
            const localVarPath = `/userSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSettingsApi - functional programming interface
 * @export
 */
export const UserSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Lists the settings of an authorized user. Example response contains a shortened list of settings.
         * @summary List settings of an authorized user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserSettingsResponse200> {
            const localVarFetchArgs = UserSettingsApiFetchParamCreator(configuration).getUserSettings(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserSettingsApi - factory interface
 * @export
 */
export const UserSettingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists the settings of an authorized user. Example response contains a shortened list of settings.
         * @summary List settings of an authorized user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options?: any) {
            return UserSettingsApiFp(configuration).getUserSettings(options)(fetch, basePath);
        },
    };
};

/**
 * UserSettingsApi - interface
 * @export
 * @interface UserSettingsApi
 */
export interface UserSettingsApiInterface {
    /**
     * Lists the settings of an authorized user. Example response contains a shortened list of settings.
     * @summary List settings of an authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApiInterface
     */
    getUserSettings(options?: any): Promise<GetUserSettingsResponse200>;

}

/**
 * UserSettingsApi - object-oriented interface
 * @export
 * @class UserSettingsApi
 * @extends {BaseAPI}
 */
export class UserSettingsApi extends BaseAPI implements UserSettingsApiInterface {
    /**
     * Lists the settings of an authorized user. Example response contains a shortened list of settings.
     * @summary List settings of an authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserSettings(options?: any) {
        return UserSettingsApiFp(this.configuration).getUserSettings(options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new user to the company, returns the ID upon success.
         * @summary Add a new user
         * @param {AddUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(body?: AddUserRequest, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds users by their name.
         * @summary Find users by name
         * @param {string} term The search term to look for
         * @param {number} [search_by_email] When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByName(term: string, search_by_email?: number, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term','Required parameter term was null or undefined when calling findUsersByName.');
            }
            const localVarPath = `/users/find`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (search_by_email !== undefined) {
                localVarQueryParameter['search_by_email'] = search_by_email;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means 'Date/number format' in the Pipedrive account settings, not the chosen language.
         * @summary Get current user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about a specific user within the company.
         * @summary Get one user
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the followers of a specific user.
         * @summary List followers of a user
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserFollowers.');
            }
            const localVarPath = `/users/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists aggregated permissions over all assigned permission sets for a user.
         * @summary List user permissions
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserPermissions.');
            }
            const localVarPath = `/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists role assignments for a user.
         * @summary List role assignments
         * @param {number} id The ID of the user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleAssignments(id: number, start?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserRoleAssignments.');
            }
            const localVarPath = `/users/{id}/roleAssignments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the settings of user's assigned role.
         * @summary List user role settings
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleSettings(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserRoleSettings.');
            }
            const localVarPath = `/users/{id}/roleSettings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all users within the company.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a user. Currently, only `active_flag` can be updated.
         * @summary Update user details
         * @param {number} id The ID of the user
         * @param {UpdateUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, body?: UpdateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new user to the company, returns the ID upon success.
         * @summary Add a new user
         * @param {AddUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(body?: AddUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).addUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finds users by their name.
         * @summary Find users by name
         * @param {string} term The search term to look for
         * @param {number} [search_by_email] When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByName(term: string, search_by_email?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsersResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).findUsersByName(term, search_by_email, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means 'Date/number format' in the Pipedrive account settings, not the chosen language.
         * @summary Get current user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCurrentUserResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUser(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about a specific user within the company.
         * @summary Get one user
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the followers of a specific user.
         * @summary List followers of a user
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserIds> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserFollowers(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists aggregated permissions over all assigned permission sets for a user.
         * @summary List user permissions
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserPermissionsResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserPermissions(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists role assignments for a user.
         * @summary List role assignments
         * @param {number} id The ID of the user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleAssignments(id: number, start?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserRoleAssignmentsResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserRoleAssignments(id, start, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists the settings of user's assigned role.
         * @summary List user role settings
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleSettings(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetRoleSettingsResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserRoleSettings(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all users within the company.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsersResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the properties of a user. Currently, only `active_flag` can be updated.
         * @summary Update user details
         * @param {number} id The ID of the user
         * @param {UpdateUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, body?: UpdateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse200> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new user to the company, returns the ID upon success.
         * @summary Add a new user
         * @param {AddUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(body?: AddUserRequest, options?: any) {
            return UsersApiFp(configuration).addUser(body, options)(fetch, basePath);
        },
        /**
         * Finds users by their name.
         * @summary Find users by name
         * @param {string} term The search term to look for
         * @param {number} [search_by_email] When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByName(term: string, search_by_email?: number, options?: any) {
            return UsersApiFp(configuration).findUsersByName(term, search_by_email, options)(fetch, basePath);
        },
        /**
         * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means 'Date/number format' in the Pipedrive account settings, not the chosen language.
         * @summary Get current user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any) {
            return UsersApiFp(configuration).getCurrentUser(options)(fetch, basePath);
        },
        /**
         * Returns data about a specific user within the company.
         * @summary Get one user
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: any) {
            return UsersApiFp(configuration).getUser(id, options)(fetch, basePath);
        },
        /**
         * Lists the followers of a specific user.
         * @summary List followers of a user
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowers(id: number, options?: any) {
            return UsersApiFp(configuration).getUserFollowers(id, options)(fetch, basePath);
        },
        /**
         * Lists aggregated permissions over all assigned permission sets for a user.
         * @summary List user permissions
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions(id: number, options?: any) {
            return UsersApiFp(configuration).getUserPermissions(id, options)(fetch, basePath);
        },
        /**
         * Lists role assignments for a user.
         * @summary List role assignments
         * @param {number} id The ID of the user
         * @param {number} [start] Pagination start
         * @param {number} [limit] Items shown per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleAssignments(id: number, start?: number, limit?: number, options?: any) {
            return UsersApiFp(configuration).getUserRoleAssignments(id, start, limit, options)(fetch, basePath);
        },
        /**
         * Lists the settings of user's assigned role.
         * @summary List user role settings
         * @param {number} id The ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleSettings(id: number, options?: any) {
            return UsersApiFp(configuration).getUserRoleSettings(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all users within the company.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any) {
            return UsersApiFp(configuration).getUsers(options)(fetch, basePath);
        },
        /**
         * Updates the properties of a user. Currently, only `active_flag` can be updated.
         * @summary Update user details
         * @param {number} id The ID of the user
         * @param {UpdateUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, body?: UpdateUserRequest, options?: any) {
            return UsersApiFp(configuration).updateUser(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Adds a new user to the company, returns the ID upon success.
     * @summary Add a new user
     * @param {AddUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    addUser(body?: AddUserRequest, options?: any): Promise<UserResponse200>;

    /**
     * Finds users by their name.
     * @summary Find users by name
     * @param {string} term The search term to look for
     * @param {number} [search_by_email] When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    findUsersByName(term: string, search_by_email?: number, options?: any): Promise<UsersResponse200>;

    /**
     * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means 'Date/number format' in the Pipedrive account settings, not the chosen language.
     * @summary Get current user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getCurrentUser(options?: any): Promise<GetCurrentUserResponse200>;

    /**
     * Returns data about a specific user within the company.
     * @summary Get one user
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUser(id: number, options?: any): Promise<UserResponse200>;

    /**
     * Lists the followers of a specific user.
     * @summary List followers of a user
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserFollowers(id: number, options?: any): Promise<UserIds>;

    /**
     * Lists aggregated permissions over all assigned permission sets for a user.
     * @summary List user permissions
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserPermissions(id: number, options?: any): Promise<GetUserPermissionsResponse200>;

    /**
     * Lists role assignments for a user.
     * @summary List role assignments
     * @param {number} id The ID of the user
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserRoleAssignments(id: number, start?: number, limit?: number, options?: any): Promise<GetUserRoleAssignmentsResponse200>;

    /**
     * Lists the settings of user's assigned role.
     * @summary List user role settings
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserRoleSettings(id: number, options?: any): Promise<GetRoleSettingsResponse200>;

    /**
     * Returns data about all users within the company.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUsers(options?: any): Promise<UsersResponse200>;

    /**
     * Updates the properties of a user. Currently, only `active_flag` can be updated.
     * @summary Update user details
     * @param {number} id The ID of the user
     * @param {UpdateUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    updateUser(id: number, body?: UpdateUserRequest, options?: any): Promise<UserResponse200>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Adds a new user to the company, returns the ID upon success.
     * @summary Add a new user
     * @param {AddUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(body?: AddUserRequest, options?: any) {
        return UsersApiFp(this.configuration).addUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Finds users by their name.
     * @summary Find users by name
     * @param {string} term The search term to look for
     * @param {number} [search_by_email] When enabled, the term will only be matched against email addresses of users. Default: &#x60;false&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersByName(term: string, search_by_email?: number, options?: any) {
        return UsersApiFp(this.configuration).findUsersByName(term, search_by_email, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means 'Date/number format' in the Pipedrive account settings, not the chosen language.
     * @summary Get current user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about a specific user within the company.
     * @summary Get one user
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the followers of a specific user.
     * @summary List followers of a user
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserFollowers(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUserFollowers(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists aggregated permissions over all assigned permission sets for a user.
     * @summary List user permissions
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserPermissions(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUserPermissions(id, options)(this.fetch, this.basePath);
    }

    /**
     * Lists role assignments for a user.
     * @summary List role assignments
     * @param {number} id The ID of the user
     * @param {number} [start] Pagination start
     * @param {number} [limit] Items shown per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoleAssignments(id: number, start?: number, limit?: number, options?: any) {
        return UsersApiFp(this.configuration).getUserRoleAssignments(id, start, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Lists the settings of user's assigned role.
     * @summary List user role settings
     * @param {number} id The ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoleSettings(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUserRoleSettings(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all users within the company.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: any) {
        return UsersApiFp(this.configuration).getUsers(options)(this.fetch, this.basePath);
    }

    /**
     * Updates the properties of a user. Currently, only `active_flag` can be updated.
     * @summary Update user details
     * @param {number} id The ID of the user
     * @param {UpdateUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: number, body?: UpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
export const WebhooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
         * @summary Create a new Webhook
         * @param {AddWebhookRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(body?: AddWebhookRequest, options: any = {}): FetchArgs {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddWebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified Webhook.
         * @summary Delete existing Webhook
         * @param {number} id The ID of the Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data about all the Webhooks of a company.
         * @summary Get all Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options: any = {}): FetchArgs {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_token")
					: configuration.apiKey;
                localVarQueryParameter["api_token"] = localVarApiKeyValue;
            }

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", ["deals:read", "deals:full", "goals:read", "goals:full", "leads:read", "leads:full", "activities:read", "activities:full", "contacts:read", "contacts:full", "admin", "recents:read", "search:read", "mail:read", "mail:full", "products:read", "products:full", "users:read", "base", "phone-integration"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
         * @summary Create a new Webhook
         * @param {AddWebhookRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(body?: AddWebhookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponse200> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).addWebhook(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes the specified Webhook.
         * @summary Delete existing Webhook
         * @param {number} id The ID of the Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse200> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).deleteWebhook(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns data about all the Webhooks of a company.
         * @summary Get all Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetWebhooksResponse200> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).getWebhooks(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
         * @summary Create a new Webhook
         * @param {AddWebhookRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(body?: AddWebhookRequest, options?: any) {
            return WebhooksApiFp(configuration).addWebhook(body, options)(fetch, basePath);
        },
        /**
         * Deletes the specified Webhook.
         * @summary Delete existing Webhook
         * @param {number} id The ID of the Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: number, options?: any) {
            return WebhooksApiFp(configuration).deleteWebhook(id, options)(fetch, basePath);
        },
        /**
         * Returns data about all the Webhooks of a company.
         * @summary Get all Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options?: any) {
            return WebhooksApiFp(configuration).getWebhooks(options)(fetch, basePath);
        },
    };
};

/**
 * WebhooksApi - interface
 * @export
 * @interface WebhooksApi
 */
export interface WebhooksApiInterface {
    /**
     * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
     * @summary Create a new Webhook
     * @param {AddWebhookRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    addWebhook(body?: AddWebhookRequest, options?: any): Promise<WebhookResponse200>;

    /**
     * Deletes the specified Webhook.
     * @summary Delete existing Webhook
     * @param {number} id The ID of the Webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    deleteWebhook(id: number, options?: any): Promise<BaseResponse200>;

    /**
     * Returns data about all the Webhooks of a company.
     * @summary Get all Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    getWebhooks(options?: any): Promise<GetWebhooksResponse200>;

}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
    /**
     * Creates a new Webhook and returns its details. Note that specifying an event which triggers the Webhook combines 2 parameters - `event_action` and `event_object`. E.g., use `*.*` for getting notifications about all events, `added.deal` for any newly added deals, `deleted.persons` for any deleted persons, etc. See <a href=\"https://pipedrive.readme.io/docs/guide-for-webhooks?ref=api_reference\" target=\"_blank\" rel=\"noopener noreferrer\">the guide for Webhooks</a> for more details.
     * @summary Create a new Webhook
     * @param {AddWebhookRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public addWebhook(body?: AddWebhookRequest, options?: any) {
        return WebhooksApiFp(this.configuration).addWebhook(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes the specified Webhook.
     * @summary Delete existing Webhook
     * @param {number} id The ID of the Webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(id: number, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhook(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns data about all the Webhooks of a company.
     * @summary Get all Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(options?: any) {
        return WebhooksApiFp(this.configuration).getWebhooks(options)(this.fetch, this.basePath);
    }

}
